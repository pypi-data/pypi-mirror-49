# coding: utf-8

"""
    Coinmarketcap API Swagger Implementation

    Define coinmarketcap's api in swagger 2.0 openapi standard  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from CmcClient.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def cryptocurrency_info_get(self, **kwargs):  # noqa: E501
        """Get metadata  # noqa: E501

        Returns all static metadata for one or more cryptocurrencies including name, symbol, logo, and its various registered URLs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cryptocurrency_info_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: One or more comma-separated CoinMarketCap cryptocurrency IDs. Example \"1,2\"
        :param str symbol: Alternatively pass one or more comma-separated cryptocurrency symbols. Example: \"BTC,ETH\". At least one \"id\" or \"symbol\" is required.
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cryptocurrency_info_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cryptocurrency_info_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def cryptocurrency_info_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get metadata  # noqa: E501

        Returns all static metadata for one or more cryptocurrencies including name, symbol, logo, and its various registered URLs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cryptocurrency_info_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: One or more comma-separated CoinMarketCap cryptocurrency IDs. Example \"1,2\"
        :param str symbol: Alternatively pass one or more comma-separated cryptocurrency symbols. Example: \"BTC,ETH\". At least one \"id\" or \"symbol\" is required.
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'symbol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cryptocurrency_info_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cryptocurrency/info', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2006',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cryptocurrency_listings_historical_get(self, **kwargs):  # noqa: E501
        """List all cryptocurrencies (historical)  # noqa: E501

        Get a paginated list of all cryptocurrencies with market data for a given historical time. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cryptocurrency_listings_historical_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str timestamp: Timestamp (Unix or ISO 8601) to return historical cryptocurrency listings for.
        :param int start: Optionally offset the start (1-based index) of the paginated list of items to return.
        :param int limit: Optionally specify the number of results to return. Use this parameter and the \"start\" parameter to determine your own pagination size.
        :param str convert: Optionally calculate market quotes in up to 120 currencies at once by passing a comma-separated list of cryptocurrency or fiat currency symbols. Each additional convert option beyond the first requires an additional call credit. A list of supported fiat options can be found here. Each conversion is returned in its own \"quote\" object.
        :param str sort: Valid values `name` `symbol` `date_added` `market_cap` `price` `circulating_supply` `total_supply` `max_supply` `num_market_pairs` `volume_24h` `percent_change_1h` `percent_change_24h` `percent_change_7d`   What field to sort the list of cryptocurrencies by.
        :param str sort_dir: Valid values `asc` `desc`. The direction in which to order cryptocurrencies against the specified sort.
        :param str cryptocurrency_type: Valid values `all` `coins` `tokens` The type of cryptocurrency to include.
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cryptocurrency_listings_historical_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cryptocurrency_listings_historical_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def cryptocurrency_listings_historical_get_with_http_info(self, **kwargs):  # noqa: E501
        """List all cryptocurrencies (historical)  # noqa: E501

        Get a paginated list of all cryptocurrencies with market data for a given historical time. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cryptocurrency_listings_historical_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str timestamp: Timestamp (Unix or ISO 8601) to return historical cryptocurrency listings for.
        :param int start: Optionally offset the start (1-based index) of the paginated list of items to return.
        :param int limit: Optionally specify the number of results to return. Use this parameter and the \"start\" parameter to determine your own pagination size.
        :param str convert: Optionally calculate market quotes in up to 120 currencies at once by passing a comma-separated list of cryptocurrency or fiat currency symbols. Each additional convert option beyond the first requires an additional call credit. A list of supported fiat options can be found here. Each conversion is returned in its own \"quote\" object.
        :param str sort: Valid values `name` `symbol` `date_added` `market_cap` `price` `circulating_supply` `total_supply` `max_supply` `num_market_pairs` `volume_24h` `percent_change_1h` `percent_change_24h` `percent_change_7d`   What field to sort the list of cryptocurrencies by.
        :param str sort_dir: Valid values `asc` `desc`. The direction in which to order cryptocurrencies against the specified sort.
        :param str cryptocurrency_type: Valid values `all` `coins` `tokens` The type of cryptocurrency to include.
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['timestamp', 'start', 'limit', 'convert', 'sort', 'sort_dir', 'cryptocurrency_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cryptocurrency_listings_historical_get" % key
                )
            params[key] = val
        del params['kwargs']

        if 'start' in params and params['start'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `start` when calling `cryptocurrency_listings_historical_get`, must be a value greater than or equal to `1`")  # noqa: E501
        if 'limit' in params and params['limit'] > 5000:  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `cryptocurrency_listings_historical_get`, must be a value less than or equal to `5000`")  # noqa: E501
        if 'limit' in params and params['limit'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `cryptocurrency_listings_historical_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'convert' in params:
            query_params.append(('convert', params['convert']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'sort_dir' in params:
            query_params.append(('sort_dir', params['sort_dir']))  # noqa: E501
        if 'cryptocurrency_type' in params:
            query_params.append(('cryptocurrency_type', params['cryptocurrency_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cryptocurrency/listings/historical', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2007',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cryptocurrency_listings_latest_get(self, **kwargs):  # noqa: E501
        """List all cryptocurrencies (latest)  # noqa: E501

        Get a paginated list of all cryptocurrencies with latest market data. You can configure this call to sort by market cap or another market ranking field. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cryptocurrency_listings_latest_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int start: Optionally offset the start (1-based index) of the paginated list of items to return.
        :param int limit: Optionally specify the number of results to return. Use this parameter and the \"start\" parameter to determine your own pagination size.
        :param str convert: Optionally calculate market quotes in up to 120 currencies at once by passing a comma-separated list of cryptocurrency or fiat currency symbols. Each additional convert option beyond the first requires an additional call credit. A list of supported fiat options can be found here. Each conversion is returned in its own \"quote\" object.
        :param str sort: Valid values `name` `symbol` `date_added` `market_cap` `price` `circulating_supply` `total_supply` `max_supply` `num_market_pairs` `volume_24h` `percent_change_1h` `percent_change_24h` `percent_change_7d`   What field to sort the list of cryptocurrencies by.
        :param str sort_dir: Valid values `asc` `desc`. The direction in which to order cryptocurrencies against the specified sort.
        :param str cryptocurrency_type: Valid values `all` `coins` `tokens` The type of cryptocurrency to include.
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cryptocurrency_listings_latest_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cryptocurrency_listings_latest_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def cryptocurrency_listings_latest_get_with_http_info(self, **kwargs):  # noqa: E501
        """List all cryptocurrencies (latest)  # noqa: E501

        Get a paginated list of all cryptocurrencies with latest market data. You can configure this call to sort by market cap or another market ranking field. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cryptocurrency_listings_latest_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int start: Optionally offset the start (1-based index) of the paginated list of items to return.
        :param int limit: Optionally specify the number of results to return. Use this parameter and the \"start\" parameter to determine your own pagination size.
        :param str convert: Optionally calculate market quotes in up to 120 currencies at once by passing a comma-separated list of cryptocurrency or fiat currency symbols. Each additional convert option beyond the first requires an additional call credit. A list of supported fiat options can be found here. Each conversion is returned in its own \"quote\" object.
        :param str sort: Valid values `name` `symbol` `date_added` `market_cap` `price` `circulating_supply` `total_supply` `max_supply` `num_market_pairs` `volume_24h` `percent_change_1h` `percent_change_24h` `percent_change_7d`   What field to sort the list of cryptocurrencies by.
        :param str sort_dir: Valid values `asc` `desc`. The direction in which to order cryptocurrencies against the specified sort.
        :param str cryptocurrency_type: Valid values `all` `coins` `tokens` The type of cryptocurrency to include.
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start', 'limit', 'convert', 'sort', 'sort_dir', 'cryptocurrency_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cryptocurrency_listings_latest_get" % key
                )
            params[key] = val
        del params['kwargs']

        if 'start' in params and params['start'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `start` when calling `cryptocurrency_listings_latest_get`, must be a value greater than or equal to `1`")  # noqa: E501
        if 'limit' in params and params['limit'] > 5000:  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `cryptocurrency_listings_latest_get`, must be a value less than or equal to `5000`")  # noqa: E501
        if 'limit' in params and params['limit'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `cryptocurrency_listings_latest_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'convert' in params:
            query_params.append(('convert', params['convert']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'sort_dir' in params:
            query_params.append(('sort_dir', params['sort_dir']))  # noqa: E501
        if 'cryptocurrency_type' in params:
            query_params.append(('cryptocurrency_type', params['cryptocurrency_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cryptocurrency/listings/latest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2007',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cryptocurrency_map_get(self, **kwargs):  # noqa: E501
        """Get CoinMarketCap ID map  # noqa: E501

        Returns a paginated list of all cryptocurrencies by CoinMarketCap ID. We recommend using this convenience endpoint to lookup and utilize our unique cryptocurrency id across all endpoints as typical identifiers like ticker symbols can match multiple cryptocurrencies and change over time. As a convenience you may pass a comma-separated list of cryptocurrency symbols as symbol to filter this list to only those you require.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cryptocurrency_map_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str listing_status: Only active coins are returned by default. Pass 'inactive' to get a list of coins that are no longer active.
        :param int start: Optionally offset the start (1-based index) of the paginated list of items to return.
        :param int limit: Optionally specify the number of results to return. Use this parameter and the \"start\" parameter to determine your own pagination size.
        :param str symbol: Optionally pass a comma-separated list of cryptocurrency symbols to return CoinMarketCap IDs for. If this option is passed, other options will be ignored.
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cryptocurrency_map_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cryptocurrency_map_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def cryptocurrency_map_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get CoinMarketCap ID map  # noqa: E501

        Returns a paginated list of all cryptocurrencies by CoinMarketCap ID. We recommend using this convenience endpoint to lookup and utilize our unique cryptocurrency id across all endpoints as typical identifiers like ticker symbols can match multiple cryptocurrencies and change over time. As a convenience you may pass a comma-separated list of cryptocurrency symbols as symbol to filter this list to only those you require.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cryptocurrency_map_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str listing_status: Only active coins are returned by default. Pass 'inactive' to get a list of coins that are no longer active.
        :param int start: Optionally offset the start (1-based index) of the paginated list of items to return.
        :param int limit: Optionally specify the number of results to return. Use this parameter and the \"start\" parameter to determine your own pagination size.
        :param str symbol: Optionally pass a comma-separated list of cryptocurrency symbols to return CoinMarketCap IDs for. If this option is passed, other options will be ignored.
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['listing_status', 'start', 'limit', 'symbol']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cryptocurrency_map_get" % key
                )
            params[key] = val
        del params['kwargs']

        if 'start' in params and params['start'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `start` when calling `cryptocurrency_map_get`, must be a value greater than or equal to `1`")  # noqa: E501
        if 'limit' in params and params['limit'] > 5000:  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `cryptocurrency_map_get`, must be a value less than or equal to `5000`")  # noqa: E501
        if 'limit' in params and params['limit'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `limit` when calling `cryptocurrency_map_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'listing_status' in params:
            query_params.append(('listing_status', params['listing_status']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cryptocurrency/map', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def global_metrics_quotes_historical_get(self, **kwargs):  # noqa: E501
        """List all cryptocurrencies (latest)  # noqa: E501

        Get a paginated list of all cryptocurrencies with latest market data. You can configure this call to sort by market cap or another market ranking field. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.global_metrics_quotes_historical_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str time_start: Timestamp (Unix or ISO 8601) to start returning quotes for. Optional, if not passed, we'll return quotes calculated in reverse from \"time_end\".
        :param str time_end: Timestamp (Unix or ISO 8601) to stop returning quotes for (inclusive). Optional, if not passed, we'll default to the current time. If no \"time_start\" is passed, we return quotes in reverse order starting from this time.
        :param int count: The number of interval periods to return results for. Optional, required if both \"time_start\" and \"time_end\" aren't supplied. The default is 10 items. The current query limit is 10000.
        :param str interval: Valid values \"yearly\" \"monthly\" \"weekly\" \"daily\" \"hourly\" \"5m\" \"10m\" \"15m\" \"30m\" \"45m\" \"1h\" \"2h\" \"3h\" \"6h\" \"12h\" \"24h\" \"1d\" \"2d\" \"3d\" \"7d\" \"14d\" \"15d\" \"30d\" \"60d\" \"90d\" \"365d\"   Interval of time to return data points for. See details in endpoint description.
        :param str convert_id: One or more comma-separated cryptocurrency CoinMarketCap IDs. Example 1,2
        :param str convert: By default market quotes are returned in USD. Optionally calculate market quotes in up to 3 other fiat currencies or cryptocurrencies.
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.global_metrics_quotes_historical_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.global_metrics_quotes_historical_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def global_metrics_quotes_historical_get_with_http_info(self, **kwargs):  # noqa: E501
        """List all cryptocurrencies (latest)  # noqa: E501

        Get a paginated list of all cryptocurrencies with latest market data. You can configure this call to sort by market cap or another market ranking field. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.global_metrics_quotes_historical_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str time_start: Timestamp (Unix or ISO 8601) to start returning quotes for. Optional, if not passed, we'll return quotes calculated in reverse from \"time_end\".
        :param str time_end: Timestamp (Unix or ISO 8601) to stop returning quotes for (inclusive). Optional, if not passed, we'll default to the current time. If no \"time_start\" is passed, we return quotes in reverse order starting from this time.
        :param int count: The number of interval periods to return results for. Optional, required if both \"time_start\" and \"time_end\" aren't supplied. The default is 10 items. The current query limit is 10000.
        :param str interval: Valid values \"yearly\" \"monthly\" \"weekly\" \"daily\" \"hourly\" \"5m\" \"10m\" \"15m\" \"30m\" \"45m\" \"1h\" \"2h\" \"3h\" \"6h\" \"12h\" \"24h\" \"1d\" \"2d\" \"3d\" \"7d\" \"14d\" \"15d\" \"30d\" \"60d\" \"90d\" \"365d\"   Interval of time to return data points for. See details in endpoint description.
        :param str convert_id: One or more comma-separated cryptocurrency CoinMarketCap IDs. Example 1,2
        :param str convert: By default market quotes are returned in USD. Optionally calculate market quotes in up to 3 other fiat currencies or cryptocurrencies.
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['time_start', 'time_end', 'count', 'interval', 'convert_id', 'convert']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method global_metrics_quotes_historical_get" % key
                )
            params[key] = val
        del params['kwargs']

        if 'count' in params and params['count'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `count` when calling `global_metrics_quotes_historical_get`, must be a value less than or equal to `10000`")  # noqa: E501
        if 'count' in params and params['count'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `count` when calling `global_metrics_quotes_historical_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'time_start' in params:
            query_params.append(('time_start', params['time_start']))  # noqa: E501
        if 'time_end' in params:
            query_params.append(('time_end', params['time_end']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'convert_id' in params:
            query_params.append(('convert_id', params['convert_id']))  # noqa: E501
        if 'convert' in params:
            query_params.append(('convert', params['convert']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/global-metrics/quotes/historical', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2009',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def global_metrics_quotes_latest_get(self, **kwargs):  # noqa: E501
        """Get aggregate market metrics (latest)  # noqa: E501

        Get the latest quote of aggregate market metrics. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.global_metrics_quotes_latest_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str convert_id: One or more comma-separated cryptocurrency CoinMarketCap IDs. Example 1,2
        :param str convert: Optionally calculate market quotes in up to 120 currencies at once by passing a comma-separated list of cryptocurrency or fiat currency symbols. Each additional convert option beyond the first requires an additional call credit. A list of supported fiat options can be found here. Each conversion is returned in its own \"quote\" object.
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.global_metrics_quotes_latest_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.global_metrics_quotes_latest_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def global_metrics_quotes_latest_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get aggregate market metrics (latest)  # noqa: E501

        Get the latest quote of aggregate market metrics. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.global_metrics_quotes_latest_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str convert_id: One or more comma-separated cryptocurrency CoinMarketCap IDs. Example 1,2
        :param str convert: Optionally calculate market quotes in up to 120 currencies at once by passing a comma-separated list of cryptocurrency or fiat currency symbols. Each additional convert option beyond the first requires an additional call credit. A list of supported fiat options can be found here. Each conversion is returned in its own \"quote\" object.
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['convert_id', 'convert']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method global_metrics_quotes_latest_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'convert_id' in params:
            query_params.append(('convert_id', params['convert_id']))  # noqa: E501
        if 'convert' in params:
            query_params.append(('convert', params['convert']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/global-metrics/quotes/latest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2008',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
