# Generated from FPCore.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\26")
        buf.write("\u00ca\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\3\2\7\2\24\n\2\f\2\16\2\27\13\2\3\2\3")
        buf.write("\2\3\3\7\3\34\n\3\f\3\16\3\37\13\3\3\3\3\3\3\4\3\4\3\4")
        buf.write("\3\4\7\4\'\n\4\f\4\16\4*\13\4\3\4\3\4\7\4.\n\4\f\4\16")
        buf.write("\4\61\13\4\3\4\3\4\3\4\3\5\3\5\3\5\3\5\7\5:\n\5\f\5\16")
        buf.write("\5=\13\5\3\5\3\5\5\5A\n\5\3\6\3\6\3\6\3\6\3\6\7\6H\n\6")
        buf.write("\f\6\16\6K\13\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write("\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6")
        buf.write("\7\6d\n\6\f\6\16\6g\13\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write("\6\3\6\3\6\3\6\3\6\7\6u\n\6\f\6\16\6x\13\6\3\6\3\6\3\6")
        buf.write("\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\7\6\u0088")
        buf.write("\n\6\f\6\16\6\u008b\13\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write("\6\3\6\3\6\3\6\3\6\3\6\3\6\7\6\u009b\n\6\f\6\16\6\u009e")
        buf.write("\13\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\7\6\u00a7\n\6\f\6\16")
        buf.write("\6\u00aa\13\6\3\6\5\6\u00ad\n\6\3\7\3\7\3\7\3\7\3\7\3")
        buf.write("\7\3\7\3\7\3\7\5\7\u00b8\n\7\3\b\3\b\3\b\3\t\3\t\3\t\3")
        buf.write("\t\3\t\7\t\u00c2\n\t\f\t\16\t\u00c5\13\t\3\t\5\t\u00c8")
        buf.write("\n\t\3\t\2\2\n\2\4\6\b\n\f\16\20\2\2\2\u00dd\2\25\3\2")
        buf.write("\2\2\4\35\3\2\2\2\6\"\3\2\2\2\b@\3\2\2\2\n\u00ac\3\2\2")
        buf.write("\2\f\u00b7\3\2\2\2\16\u00b9\3\2\2\2\20\u00c7\3\2\2\2\22")
        buf.write("\24\5\6\4\2\23\22\3\2\2\2\24\27\3\2\2\2\25\23\3\2\2\2")
        buf.write("\25\26\3\2\2\2\26\30\3\2\2\2\27\25\3\2\2\2\30\31\7\2\2")
        buf.write("\3\31\3\3\2\2\2\32\34\5\n\6\2\33\32\3\2\2\2\34\37\3\2")
        buf.write("\2\2\35\33\3\2\2\2\35\36\3\2\2\2\36 \3\2\2\2\37\35\3\2")
        buf.write("\2\2 !\7\2\2\3!\5\3\2\2\2\"#\7\f\2\2#$\7\3\2\2$(\7\f\2")
        buf.write("\2%\'\5\b\5\2&%\3\2\2\2\'*\3\2\2\2(&\3\2\2\2()\3\2\2\2")
        buf.write(")+\3\2\2\2*(\3\2\2\2+/\7\r\2\2,.\5\16\b\2-,\3\2\2\2.\61")
        buf.write("\3\2\2\2/-\3\2\2\2/\60\3\2\2\2\60\62\3\2\2\2\61/\3\2\2")
        buf.write("\2\62\63\5\n\6\2\63\64\7\r\2\2\64\7\3\2\2\2\65A\7\21\2")
        buf.write("\2\66\67\7\f\2\2\67;\7\4\2\28:\5\16\b\298\3\2\2\2:=\3")
        buf.write("\2\2\2;9\3\2\2\2;<\3\2\2\2<>\3\2\2\2=;\3\2\2\2>?\7\21")
        buf.write("\2\2?A\7\r\2\2@\65\3\2\2\2@\66\3\2\2\2A\t\3\2\2\2B\u00ad")
        buf.write("\5\f\7\2C\u00ad\7\21\2\2DE\7\f\2\2EI\7\4\2\2FH\5\16\b")
        buf.write("\2GF\3\2\2\2HK\3\2\2\2IG\3\2\2\2IJ\3\2\2\2JL\3\2\2\2K")
        buf.write("I\3\2\2\2LM\5\n\6\2MN\7\r\2\2N\u00ad\3\2\2\2OP\7\f\2\2")
        buf.write("PQ\7\5\2\2QR\5\n\6\2RS\7\r\2\2S\u00ad\3\2\2\2TU\7\f\2")
        buf.write("\2UV\7\6\2\2VW\5\n\6\2WX\5\n\6\2XY\5\n\6\2YZ\7\r\2\2Z")
        buf.write("\u00ad\3\2\2\2[\\\7\f\2\2\\]\7\7\2\2]e\7\f\2\2^_\7\f\2")
        buf.write("\2_`\7\21\2\2`a\5\n\6\2ab\7\r\2\2bd\3\2\2\2c^\3\2\2\2")
        buf.write("dg\3\2\2\2ec\3\2\2\2ef\3\2\2\2fh\3\2\2\2ge\3\2\2\2hi\7")
        buf.write("\r\2\2ij\5\n\6\2jk\7\r\2\2k\u00ad\3\2\2\2lm\7\f\2\2mn")
        buf.write("\7\b\2\2nv\7\f\2\2op\7\f\2\2pq\7\21\2\2qr\5\n\6\2rs\7")
        buf.write("\r\2\2su\3\2\2\2to\3\2\2\2ux\3\2\2\2vt\3\2\2\2vw\3\2\2")
        buf.write("\2wy\3\2\2\2xv\3\2\2\2yz\7\r\2\2z{\5\n\6\2{|\7\r\2\2|")
        buf.write("\u00ad\3\2\2\2}~\7\f\2\2~\177\7\t\2\2\177\u0080\5\n\6")
        buf.write("\2\u0080\u0089\7\f\2\2\u0081\u0082\7\f\2\2\u0082\u0083")
        buf.write("\7\21\2\2\u0083\u0084\5\n\6\2\u0084\u0085\5\n\6\2\u0085")
        buf.write("\u0086\7\r\2\2\u0086\u0088\3\2\2\2\u0087\u0081\3\2\2\2")
        buf.write("\u0088\u008b\3\2\2\2\u0089\u0087\3\2\2\2\u0089\u008a\3")
        buf.write("\2\2\2\u008a\u008c\3\2\2\2\u008b\u0089\3\2\2\2\u008c\u008d")
        buf.write("\7\r\2\2\u008d\u008e\5\n\6\2\u008e\u008f\7\r\2\2\u008f")
        buf.write("\u00ad\3\2\2\2\u0090\u0091\7\f\2\2\u0091\u0092\7\n\2\2")
        buf.write("\u0092\u0093\5\n\6\2\u0093\u009c\7\f\2\2\u0094\u0095\7")
        buf.write("\f\2\2\u0095\u0096\7\21\2\2\u0096\u0097\5\n\6\2\u0097")
        buf.write("\u0098\5\n\6\2\u0098\u0099\7\r\2\2\u0099\u009b\3\2\2\2")
        buf.write("\u009a\u0094\3\2\2\2\u009b\u009e\3\2\2\2\u009c\u009a\3")
        buf.write("\2\2\2\u009c\u009d\3\2\2\2\u009d\u009f\3\2\2\2\u009e\u009c")
        buf.write("\3\2\2\2\u009f\u00a0\7\r\2\2\u00a0\u00a1\5\n\6\2\u00a1")
        buf.write("\u00a2\7\r\2\2\u00a2\u00ad\3\2\2\2\u00a3\u00a4\7\f\2\2")
        buf.write("\u00a4\u00a8\7\21\2\2\u00a5\u00a7\5\n\6\2\u00a6\u00a5")
        buf.write("\3\2\2\2\u00a7\u00aa\3\2\2\2\u00a8\u00a6\3\2\2\2\u00a8")
        buf.write("\u00a9\3\2\2\2\u00a9\u00ab\3\2\2\2\u00aa\u00a8\3\2\2\2")
        buf.write("\u00ab\u00ad\7\r\2\2\u00acB\3\2\2\2\u00acC\3\2\2\2\u00ac")
        buf.write("D\3\2\2\2\u00acO\3\2\2\2\u00acT\3\2\2\2\u00ac[\3\2\2\2")
        buf.write("\u00acl\3\2\2\2\u00ac}\3\2\2\2\u00ac\u0090\3\2\2\2\u00ac")
        buf.write("\u00a3\3\2\2\2\u00ad\13\3\2\2\2\u00ae\u00b8\7\16\2\2\u00af")
        buf.write("\u00b8\7\17\2\2\u00b0\u00b8\7\20\2\2\u00b1\u00b2\7\f\2")
        buf.write("\2\u00b2\u00b3\7\13\2\2\u00b3\u00b4\7\16\2\2\u00b4\u00b5")
        buf.write("\7\16\2\2\u00b5\u00b6\7\16\2\2\u00b6\u00b8\7\r\2\2\u00b7")
        buf.write("\u00ae\3\2\2\2\u00b7\u00af\3\2\2\2\u00b7\u00b0\3\2\2\2")
        buf.write("\u00b7\u00b1\3\2\2\2\u00b8\r\3\2\2\2\u00b9\u00ba\7\21")
        buf.write("\2\2\u00ba\u00bb\5\20\t\2\u00bb\17\3\2\2\2\u00bc\u00c8")
        buf.write("\5\f\7\2\u00bd\u00c8\7\21\2\2\u00be\u00c8\7\22\2\2\u00bf")
        buf.write("\u00c3\7\f\2\2\u00c0\u00c2\5\20\t\2\u00c1\u00c0\3\2\2")
        buf.write("\2\u00c2\u00c5\3\2\2\2\u00c3\u00c1\3\2\2\2\u00c3\u00c4")
        buf.write("\3\2\2\2\u00c4\u00c6\3\2\2\2\u00c5\u00c3\3\2\2\2\u00c6")
        buf.write("\u00c8\7\r\2\2\u00c7\u00bc\3\2\2\2\u00c7\u00bd\3\2\2\2")
        buf.write("\u00c7\u00be\3\2\2\2\u00c7\u00bf\3\2\2\2\u00c8\21\3\2")
        buf.write("\2\2\22\25\35(/;@Iev\u0089\u009c\u00a8\u00ac\u00b7\u00c3")
        buf.write("\u00c7")
        return buf.getvalue()


class FPCoreParser ( Parser ):

    grammarFileName = "FPCore.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'FPCore'", "'!'", "'cast'", "'if'", "'let'", 
                     "'let*'", "'while'", "'while*'", "'digits'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "OPEN", "CLOSE", "DECNUM", 
                      "HEXNUM", "RATIONAL", "SYMBOL", "STRING", "WS", "BLOCK_COMMENT", 
                      "LINE_COMMENT", "UNK" ]

    RULE_parse_fpcore = 0
    RULE_parse_exprs = 1
    RULE_fpcore = 2
    RULE_argument = 3
    RULE_expr = 4
    RULE_number = 5
    RULE_prop = 6
    RULE_datum = 7

    ruleNames =  [ "parse_fpcore", "parse_exprs", "fpcore", "argument", 
                   "expr", "number", "prop", "datum" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    OPEN=10
    CLOSE=11
    DECNUM=12
    HEXNUM=13
    RATIONAL=14
    SYMBOL=15
    STRING=16
    WS=17
    BLOCK_COMMENT=18
    LINE_COMMENT=19
    UNK=20

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class Parse_fpcoreContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(FPCoreParser.EOF, 0)

        def fpcore(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FPCoreParser.FpcoreContext)
            else:
                return self.getTypedRuleContext(FPCoreParser.FpcoreContext,i)


        def getRuleIndex(self):
            return FPCoreParser.RULE_parse_fpcore

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParse_fpcore" ):
                return visitor.visitParse_fpcore(self)
            else:
                return visitor.visitChildren(self)




    def parse_fpcore(self):

        localctx = FPCoreParser.Parse_fpcoreContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_parse_fpcore)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 19
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==FPCoreParser.OPEN:
                self.state = 16
                self.fpcore()
                self.state = 21
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 22
            self.match(FPCoreParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Parse_exprsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(FPCoreParser.EOF, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FPCoreParser.ExprContext)
            else:
                return self.getTypedRuleContext(FPCoreParser.ExprContext,i)


        def getRuleIndex(self):
            return FPCoreParser.RULE_parse_exprs

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParse_exprs" ):
                return visitor.visitParse_exprs(self)
            else:
                return visitor.visitChildren(self)




    def parse_exprs(self):

        localctx = FPCoreParser.Parse_exprsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_parse_exprs)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 27
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FPCoreParser.OPEN) | (1 << FPCoreParser.DECNUM) | (1 << FPCoreParser.HEXNUM) | (1 << FPCoreParser.RATIONAL) | (1 << FPCoreParser.SYMBOL))) != 0):
                self.state = 24
                self.expr()
                self.state = 29
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 30
            self.match(FPCoreParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FpcoreContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._argument = None # ArgumentContext
            self.inputs = list() # of ArgumentContexts
            self._prop = None # PropContext
            self.props = list() # of PropContexts
            self.e = None # ExprContext

        def OPEN(self, i:int=None):
            if i is None:
                return self.getTokens(FPCoreParser.OPEN)
            else:
                return self.getToken(FPCoreParser.OPEN, i)

        def CLOSE(self, i:int=None):
            if i is None:
                return self.getTokens(FPCoreParser.CLOSE)
            else:
                return self.getToken(FPCoreParser.CLOSE, i)

        def expr(self):
            return self.getTypedRuleContext(FPCoreParser.ExprContext,0)


        def argument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FPCoreParser.ArgumentContext)
            else:
                return self.getTypedRuleContext(FPCoreParser.ArgumentContext,i)


        def prop(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FPCoreParser.PropContext)
            else:
                return self.getTypedRuleContext(FPCoreParser.PropContext,i)


        def getRuleIndex(self):
            return FPCoreParser.RULE_fpcore

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFpcore" ):
                return visitor.visitFpcore(self)
            else:
                return visitor.visitChildren(self)




    def fpcore(self):

        localctx = FPCoreParser.FpcoreContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_fpcore)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 32
            self.match(FPCoreParser.OPEN)
            self.state = 33
            self.match(FPCoreParser.T__0)
            self.state = 34
            self.match(FPCoreParser.OPEN)
            self.state = 38
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==FPCoreParser.OPEN or _la==FPCoreParser.SYMBOL:
                self.state = 35
                localctx._argument = self.argument()
                localctx.inputs.append(localctx._argument)
                self.state = 40
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 41
            self.match(FPCoreParser.CLOSE)
            self.state = 45
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,3,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 42
                    localctx._prop = self.prop()
                    localctx.props.append(localctx._prop) 
                self.state = 47
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,3,self._ctx)

            self.state = 48
            localctx.e = self.expr()
            self.state = 49
            self.match(FPCoreParser.CLOSE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token
            self._prop = None # PropContext
            self.props = list() # of PropContexts

        def SYMBOL(self):
            return self.getToken(FPCoreParser.SYMBOL, 0)

        def OPEN(self):
            return self.getToken(FPCoreParser.OPEN, 0)

        def CLOSE(self):
            return self.getToken(FPCoreParser.CLOSE, 0)

        def prop(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FPCoreParser.PropContext)
            else:
                return self.getTypedRuleContext(FPCoreParser.PropContext,i)


        def getRuleIndex(self):
            return FPCoreParser.RULE_argument

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgument" ):
                return visitor.visitArgument(self)
            else:
                return visitor.visitChildren(self)




    def argument(self):

        localctx = FPCoreParser.ArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_argument)
        try:
            self.state = 62
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [FPCoreParser.SYMBOL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 51
                localctx.name = self.match(FPCoreParser.SYMBOL)
                pass
            elif token in [FPCoreParser.OPEN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 52
                self.match(FPCoreParser.OPEN)
                self.state = 53
                self.match(FPCoreParser.T__1)
                self.state = 57
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 54
                        localctx._prop = self.prop()
                        localctx.props.append(localctx._prop) 
                    self.state = 59
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

                self.state = 60
                localctx.name = self.match(FPCoreParser.SYMBOL)
                self.state = 61
                self.match(FPCoreParser.CLOSE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FPCoreParser.RULE_expr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ExprSymContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FPCoreParser.ExprContext
            super().__init__(parser)
            self.x = None # Token
            self.copyFrom(ctx)

        def SYMBOL(self):
            return self.getToken(FPCoreParser.SYMBOL, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprSym" ):
                return visitor.visitExprSym(self)
            else:
                return visitor.visitChildren(self)


    class ExprCtxContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FPCoreParser.ExprContext
            super().__init__(parser)
            self._prop = None # PropContext
            self.props = list() # of PropContexts
            self.body = None # ExprContext
            self.copyFrom(ctx)

        def OPEN(self):
            return self.getToken(FPCoreParser.OPEN, 0)
        def CLOSE(self):
            return self.getToken(FPCoreParser.CLOSE, 0)
        def expr(self):
            return self.getTypedRuleContext(FPCoreParser.ExprContext,0)

        def prop(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FPCoreParser.PropContext)
            else:
                return self.getTypedRuleContext(FPCoreParser.PropContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprCtx" ):
                return visitor.visitExprCtx(self)
            else:
                return visitor.visitChildren(self)


    class ExprWhileContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FPCoreParser.ExprContext
            super().__init__(parser)
            self.cond = None # ExprContext
            self._SYMBOL = None # Token
            self.xs = list() # of Tokens
            self._expr = None # ExprContext
            self.e0s = list() # of ExprContexts
            self.es = list() # of ExprContexts
            self.body = None # ExprContext
            self.copyFrom(ctx)

        def OPEN(self, i:int=None):
            if i is None:
                return self.getTokens(FPCoreParser.OPEN)
            else:
                return self.getToken(FPCoreParser.OPEN, i)
        def CLOSE(self, i:int=None):
            if i is None:
                return self.getTokens(FPCoreParser.CLOSE)
            else:
                return self.getToken(FPCoreParser.CLOSE, i)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FPCoreParser.ExprContext)
            else:
                return self.getTypedRuleContext(FPCoreParser.ExprContext,i)

        def SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(FPCoreParser.SYMBOL)
            else:
                return self.getToken(FPCoreParser.SYMBOL, i)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprWhile" ):
                return visitor.visitExprWhile(self)
            else:
                return visitor.visitChildren(self)


    class ExprNumContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FPCoreParser.ExprContext
            super().__init__(parser)
            self.n = None # NumberContext
            self.copyFrom(ctx)

        def number(self):
            return self.getTypedRuleContext(FPCoreParser.NumberContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprNum" ):
                return visitor.visitExprNum(self)
            else:
                return visitor.visitChildren(self)


    class ExprLetContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FPCoreParser.ExprContext
            super().__init__(parser)
            self._SYMBOL = None # Token
            self.xs = list() # of Tokens
            self._expr = None # ExprContext
            self.es = list() # of ExprContexts
            self.body = None # ExprContext
            self.copyFrom(ctx)

        def OPEN(self, i:int=None):
            if i is None:
                return self.getTokens(FPCoreParser.OPEN)
            else:
                return self.getToken(FPCoreParser.OPEN, i)
        def CLOSE(self, i:int=None):
            if i is None:
                return self.getTokens(FPCoreParser.CLOSE)
            else:
                return self.getToken(FPCoreParser.CLOSE, i)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FPCoreParser.ExprContext)
            else:
                return self.getTypedRuleContext(FPCoreParser.ExprContext,i)

        def SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(FPCoreParser.SYMBOL)
            else:
                return self.getToken(FPCoreParser.SYMBOL, i)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprLet" ):
                return visitor.visitExprLet(self)
            else:
                return visitor.visitChildren(self)


    class ExprCastContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FPCoreParser.ExprContext
            super().__init__(parser)
            self.body = None # ExprContext
            self.copyFrom(ctx)

        def OPEN(self):
            return self.getToken(FPCoreParser.OPEN, 0)
        def CLOSE(self):
            return self.getToken(FPCoreParser.CLOSE, 0)
        def expr(self):
            return self.getTypedRuleContext(FPCoreParser.ExprContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprCast" ):
                return visitor.visitExprCast(self)
            else:
                return visitor.visitChildren(self)


    class ExprOpContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FPCoreParser.ExprContext
            super().__init__(parser)
            self.op = None # Token
            self._expr = None # ExprContext
            self.args = list() # of ExprContexts
            self.copyFrom(ctx)

        def OPEN(self):
            return self.getToken(FPCoreParser.OPEN, 0)
        def CLOSE(self):
            return self.getToken(FPCoreParser.CLOSE, 0)
        def SYMBOL(self):
            return self.getToken(FPCoreParser.SYMBOL, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FPCoreParser.ExprContext)
            else:
                return self.getTypedRuleContext(FPCoreParser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprOp" ):
                return visitor.visitExprOp(self)
            else:
                return visitor.visitChildren(self)


    class ExprWhileStarContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FPCoreParser.ExprContext
            super().__init__(parser)
            self.cond = None # ExprContext
            self._SYMBOL = None # Token
            self.xs = list() # of Tokens
            self._expr = None # ExprContext
            self.e0s = list() # of ExprContexts
            self.es = list() # of ExprContexts
            self.body = None # ExprContext
            self.copyFrom(ctx)

        def OPEN(self, i:int=None):
            if i is None:
                return self.getTokens(FPCoreParser.OPEN)
            else:
                return self.getToken(FPCoreParser.OPEN, i)
        def CLOSE(self, i:int=None):
            if i is None:
                return self.getTokens(FPCoreParser.CLOSE)
            else:
                return self.getToken(FPCoreParser.CLOSE, i)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FPCoreParser.ExprContext)
            else:
                return self.getTypedRuleContext(FPCoreParser.ExprContext,i)

        def SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(FPCoreParser.SYMBOL)
            else:
                return self.getToken(FPCoreParser.SYMBOL, i)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprWhileStar" ):
                return visitor.visitExprWhileStar(self)
            else:
                return visitor.visitChildren(self)


    class ExprIfContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FPCoreParser.ExprContext
            super().__init__(parser)
            self.cond = None # ExprContext
            self.then_body = None # ExprContext
            self.else_body = None # ExprContext
            self.copyFrom(ctx)

        def OPEN(self):
            return self.getToken(FPCoreParser.OPEN, 0)
        def CLOSE(self):
            return self.getToken(FPCoreParser.CLOSE, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FPCoreParser.ExprContext)
            else:
                return self.getTypedRuleContext(FPCoreParser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprIf" ):
                return visitor.visitExprIf(self)
            else:
                return visitor.visitChildren(self)


    class ExprLetStarContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FPCoreParser.ExprContext
            super().__init__(parser)
            self._SYMBOL = None # Token
            self.xs = list() # of Tokens
            self._expr = None # ExprContext
            self.es = list() # of ExprContexts
            self.body = None # ExprContext
            self.copyFrom(ctx)

        def OPEN(self, i:int=None):
            if i is None:
                return self.getTokens(FPCoreParser.OPEN)
            else:
                return self.getToken(FPCoreParser.OPEN, i)
        def CLOSE(self, i:int=None):
            if i is None:
                return self.getTokens(FPCoreParser.CLOSE)
            else:
                return self.getToken(FPCoreParser.CLOSE, i)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FPCoreParser.ExprContext)
            else:
                return self.getTypedRuleContext(FPCoreParser.ExprContext,i)

        def SYMBOL(self, i:int=None):
            if i is None:
                return self.getTokens(FPCoreParser.SYMBOL)
            else:
                return self.getToken(FPCoreParser.SYMBOL, i)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprLetStar" ):
                return visitor.visitExprLetStar(self)
            else:
                return visitor.visitChildren(self)



    def expr(self):

        localctx = FPCoreParser.ExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_expr)
        self._la = 0 # Token type
        try:
            self.state = 170
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                localctx = FPCoreParser.ExprNumContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 64
                localctx.n = self.number()
                pass

            elif la_ == 2:
                localctx = FPCoreParser.ExprSymContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 65
                localctx.x = self.match(FPCoreParser.SYMBOL)
                pass

            elif la_ == 3:
                localctx = FPCoreParser.ExprCtxContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 66
                self.match(FPCoreParser.OPEN)
                self.state = 67
                self.match(FPCoreParser.T__1)
                self.state = 71
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 68
                        localctx._prop = self.prop()
                        localctx.props.append(localctx._prop) 
                    self.state = 73
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

                self.state = 74
                localctx.body = self.expr()
                self.state = 75
                self.match(FPCoreParser.CLOSE)
                pass

            elif la_ == 4:
                localctx = FPCoreParser.ExprCastContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 77
                self.match(FPCoreParser.OPEN)
                self.state = 78
                self.match(FPCoreParser.T__2)
                self.state = 79
                localctx.body = self.expr()
                self.state = 80
                self.match(FPCoreParser.CLOSE)
                pass

            elif la_ == 5:
                localctx = FPCoreParser.ExprIfContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 82
                self.match(FPCoreParser.OPEN)
                self.state = 83
                self.match(FPCoreParser.T__3)
                self.state = 84
                localctx.cond = self.expr()
                self.state = 85
                localctx.then_body = self.expr()
                self.state = 86
                localctx.else_body = self.expr()
                self.state = 87
                self.match(FPCoreParser.CLOSE)
                pass

            elif la_ == 6:
                localctx = FPCoreParser.ExprLetContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 89
                self.match(FPCoreParser.OPEN)
                self.state = 90
                self.match(FPCoreParser.T__4)
                self.state = 91
                self.match(FPCoreParser.OPEN)
                self.state = 99
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==FPCoreParser.OPEN:
                    self.state = 92
                    self.match(FPCoreParser.OPEN)
                    self.state = 93
                    localctx._SYMBOL = self.match(FPCoreParser.SYMBOL)
                    localctx.xs.append(localctx._SYMBOL)
                    self.state = 94
                    localctx._expr = self.expr()
                    localctx.es.append(localctx._expr)
                    self.state = 95
                    self.match(FPCoreParser.CLOSE)
                    self.state = 101
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 102
                self.match(FPCoreParser.CLOSE)
                self.state = 103
                localctx.body = self.expr()
                self.state = 104
                self.match(FPCoreParser.CLOSE)
                pass

            elif la_ == 7:
                localctx = FPCoreParser.ExprLetStarContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 106
                self.match(FPCoreParser.OPEN)
                self.state = 107
                self.match(FPCoreParser.T__5)
                self.state = 108
                self.match(FPCoreParser.OPEN)
                self.state = 116
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==FPCoreParser.OPEN:
                    self.state = 109
                    self.match(FPCoreParser.OPEN)
                    self.state = 110
                    localctx._SYMBOL = self.match(FPCoreParser.SYMBOL)
                    localctx.xs.append(localctx._SYMBOL)
                    self.state = 111
                    localctx._expr = self.expr()
                    localctx.es.append(localctx._expr)
                    self.state = 112
                    self.match(FPCoreParser.CLOSE)
                    self.state = 118
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 119
                self.match(FPCoreParser.CLOSE)
                self.state = 120
                localctx.body = self.expr()
                self.state = 121
                self.match(FPCoreParser.CLOSE)
                pass

            elif la_ == 8:
                localctx = FPCoreParser.ExprWhileContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 123
                self.match(FPCoreParser.OPEN)
                self.state = 124
                self.match(FPCoreParser.T__6)
                self.state = 125
                localctx.cond = self.expr()
                self.state = 126
                self.match(FPCoreParser.OPEN)
                self.state = 135
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==FPCoreParser.OPEN:
                    self.state = 127
                    self.match(FPCoreParser.OPEN)
                    self.state = 128
                    localctx._SYMBOL = self.match(FPCoreParser.SYMBOL)
                    localctx.xs.append(localctx._SYMBOL)
                    self.state = 129
                    localctx._expr = self.expr()
                    localctx.e0s.append(localctx._expr)
                    self.state = 130
                    localctx._expr = self.expr()
                    localctx.es.append(localctx._expr)
                    self.state = 131
                    self.match(FPCoreParser.CLOSE)
                    self.state = 137
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 138
                self.match(FPCoreParser.CLOSE)
                self.state = 139
                localctx.body = self.expr()
                self.state = 140
                self.match(FPCoreParser.CLOSE)
                pass

            elif la_ == 9:
                localctx = FPCoreParser.ExprWhileStarContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 142
                self.match(FPCoreParser.OPEN)
                self.state = 143
                self.match(FPCoreParser.T__7)
                self.state = 144
                localctx.cond = self.expr()
                self.state = 145
                self.match(FPCoreParser.OPEN)
                self.state = 154
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==FPCoreParser.OPEN:
                    self.state = 146
                    self.match(FPCoreParser.OPEN)
                    self.state = 147
                    localctx._SYMBOL = self.match(FPCoreParser.SYMBOL)
                    localctx.xs.append(localctx._SYMBOL)
                    self.state = 148
                    localctx._expr = self.expr()
                    localctx.e0s.append(localctx._expr)
                    self.state = 149
                    localctx._expr = self.expr()
                    localctx.es.append(localctx._expr)
                    self.state = 150
                    self.match(FPCoreParser.CLOSE)
                    self.state = 156
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 157
                self.match(FPCoreParser.CLOSE)
                self.state = 158
                localctx.body = self.expr()
                self.state = 159
                self.match(FPCoreParser.CLOSE)
                pass

            elif la_ == 10:
                localctx = FPCoreParser.ExprOpContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 161
                self.match(FPCoreParser.OPEN)
                self.state = 162
                localctx.op = self.match(FPCoreParser.SYMBOL)
                self.state = 166
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FPCoreParser.OPEN) | (1 << FPCoreParser.DECNUM) | (1 << FPCoreParser.HEXNUM) | (1 << FPCoreParser.RATIONAL) | (1 << FPCoreParser.SYMBOL))) != 0):
                    self.state = 163
                    localctx._expr = self.expr()
                    localctx.args.append(localctx._expr)
                    self.state = 168
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 169
                self.match(FPCoreParser.CLOSE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FPCoreParser.RULE_number

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class NumberDecContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FPCoreParser.NumberContext
            super().__init__(parser)
            self.n = None # Token
            self.copyFrom(ctx)

        def DECNUM(self):
            return self.getToken(FPCoreParser.DECNUM, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberDec" ):
                return visitor.visitNumberDec(self)
            else:
                return visitor.visitChildren(self)


    class NumberDigitsContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FPCoreParser.NumberContext
            super().__init__(parser)
            self.m = None # Token
            self.e = None # Token
            self.b = None # Token
            self.copyFrom(ctx)

        def OPEN(self):
            return self.getToken(FPCoreParser.OPEN, 0)
        def CLOSE(self):
            return self.getToken(FPCoreParser.CLOSE, 0)
        def DECNUM(self, i:int=None):
            if i is None:
                return self.getTokens(FPCoreParser.DECNUM)
            else:
                return self.getToken(FPCoreParser.DECNUM, i)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberDigits" ):
                return visitor.visitNumberDigits(self)
            else:
                return visitor.visitChildren(self)


    class NumberRationalContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FPCoreParser.NumberContext
            super().__init__(parser)
            self.n = None # Token
            self.copyFrom(ctx)

        def RATIONAL(self):
            return self.getToken(FPCoreParser.RATIONAL, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberRational" ):
                return visitor.visitNumberRational(self)
            else:
                return visitor.visitChildren(self)


    class NumberHexContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FPCoreParser.NumberContext
            super().__init__(parser)
            self.n = None # Token
            self.copyFrom(ctx)

        def HEXNUM(self):
            return self.getToken(FPCoreParser.HEXNUM, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberHex" ):
                return visitor.visitNumberHex(self)
            else:
                return visitor.visitChildren(self)



    def number(self):

        localctx = FPCoreParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_number)
        try:
            self.state = 181
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [FPCoreParser.DECNUM]:
                localctx = FPCoreParser.NumberDecContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 172
                localctx.n = self.match(FPCoreParser.DECNUM)
                pass
            elif token in [FPCoreParser.HEXNUM]:
                localctx = FPCoreParser.NumberHexContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 173
                localctx.n = self.match(FPCoreParser.HEXNUM)
                pass
            elif token in [FPCoreParser.RATIONAL]:
                localctx = FPCoreParser.NumberRationalContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 174
                localctx.n = self.match(FPCoreParser.RATIONAL)
                pass
            elif token in [FPCoreParser.OPEN]:
                localctx = FPCoreParser.NumberDigitsContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 175
                self.match(FPCoreParser.OPEN)
                self.state = 176
                self.match(FPCoreParser.T__8)
                self.state = 177
                localctx.m = self.match(FPCoreParser.DECNUM)
                self.state = 178
                localctx.e = self.match(FPCoreParser.DECNUM)
                self.state = 179
                localctx.b = self.match(FPCoreParser.DECNUM)
                self.state = 180
                self.match(FPCoreParser.CLOSE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token
            self.d = None # DatumContext

        def SYMBOL(self):
            return self.getToken(FPCoreParser.SYMBOL, 0)

        def datum(self):
            return self.getTypedRuleContext(FPCoreParser.DatumContext,0)


        def getRuleIndex(self):
            return FPCoreParser.RULE_prop

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProp" ):
                return visitor.visitProp(self)
            else:
                return visitor.visitChildren(self)




    def prop(self):

        localctx = FPCoreParser.PropContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_prop)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 183
            localctx.name = self.match(FPCoreParser.SYMBOL)
            self.state = 184
            localctx.d = self.datum()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FPCoreParser.RULE_datum

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DatumStrContext(DatumContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FPCoreParser.DatumContext
            super().__init__(parser)
            self.s = None # Token
            self.copyFrom(ctx)

        def STRING(self):
            return self.getToken(FPCoreParser.STRING, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumStr" ):
                return visitor.visitDatumStr(self)
            else:
                return visitor.visitChildren(self)


    class DatumListContext(DatumContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FPCoreParser.DatumContext
            super().__init__(parser)
            self._datum = None # DatumContext
            self.data = list() # of DatumContexts
            self.copyFrom(ctx)

        def OPEN(self):
            return self.getToken(FPCoreParser.OPEN, 0)
        def CLOSE(self):
            return self.getToken(FPCoreParser.CLOSE, 0)
        def datum(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(FPCoreParser.DatumContext)
            else:
                return self.getTypedRuleContext(FPCoreParser.DatumContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumList" ):
                return visitor.visitDatumList(self)
            else:
                return visitor.visitChildren(self)


    class DatumNumContext(DatumContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FPCoreParser.DatumContext
            super().__init__(parser)
            self.n = None # NumberContext
            self.copyFrom(ctx)

        def number(self):
            return self.getTypedRuleContext(FPCoreParser.NumberContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumNum" ):
                return visitor.visitDatumNum(self)
            else:
                return visitor.visitChildren(self)


    class DatumSymContext(DatumContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a FPCoreParser.DatumContext
            super().__init__(parser)
            self.x = None # Token
            self.copyFrom(ctx)

        def SYMBOL(self):
            return self.getToken(FPCoreParser.SYMBOL, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumSym" ):
                return visitor.visitDatumSym(self)
            else:
                return visitor.visitChildren(self)



    def datum(self):

        localctx = FPCoreParser.DatumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_datum)
        self._la = 0 # Token type
        try:
            self.state = 197
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                localctx = FPCoreParser.DatumNumContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 186
                localctx.n = self.number()
                pass

            elif la_ == 2:
                localctx = FPCoreParser.DatumSymContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 187
                localctx.x = self.match(FPCoreParser.SYMBOL)
                pass

            elif la_ == 3:
                localctx = FPCoreParser.DatumStrContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 188
                localctx.s = self.match(FPCoreParser.STRING)
                pass

            elif la_ == 4:
                localctx = FPCoreParser.DatumListContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 189
                self.match(FPCoreParser.OPEN)
                self.state = 193
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FPCoreParser.OPEN) | (1 << FPCoreParser.DECNUM) | (1 << FPCoreParser.HEXNUM) | (1 << FPCoreParser.RATIONAL) | (1 << FPCoreParser.SYMBOL) | (1 << FPCoreParser.STRING))) != 0):
                    self.state = 190
                    localctx._datum = self.datum()
                    localctx.data.append(localctx._datum)
                    self.state = 195
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 196
                self.match(FPCoreParser.CLOSE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





