# coding: utf-8

"""
DefaultApi.py
Copyright 2016 SmartBear Software

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
"""

from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


__version__ = "2.8"


class DefaultApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def abort_experiment(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.abort_experiment(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: Experiment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method abort_experiment" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `abort_experiment`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/abort'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Experiment',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def abort_experiments(self, experiment_ids, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.abort_experiments(experiment_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[str] experiment_ids:  (required)
        :return: list[BatchExperimentUpdateResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_ids']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method abort_experiments" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_ids' is set
        if ('experiment_ids' not in params) or (params['experiment_ids'] is None):
            raise ValueError("Missing the required parameter `experiment_ids` when calling `abort_experiments`")


        resource_path = '/api/backend/v1/experiments/abort'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_ids' in params:
            body_params = params['experiment_ids']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[BatchExperimentUpdateResult]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def abort_group(self, group_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.abort_group(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id:  (required)
        :return: list[BatchExperimentUpdateResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method abort_group" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `abort_group`")


        resource_path = '/api/backend/v1/groups/{groupId}/abort'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['groupId'] = params['group_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[BatchExperimentUpdateResult]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def abort_groups(self, group_ids, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.abort_groups(group_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[str] group_ids:  (required)
        :return: list[BatchGroupUpdateResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_ids']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method abort_groups" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'group_ids' is set
        if ('group_ids' not in params) or (params['group_ids'] is None):
            raise ValueError("Missing the required parameter `group_ids` when calling `abort_groups`")


        resource_path = '/api/backend/v1/groups/abort'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'group_ids' in params:
            body_params = params['group_ids']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[BatchGroupUpdateResult]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def accept_access_request(self, invitation_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.accept_access_request(invitation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str invitation_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['invitation_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accept_access_request" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'invitation_id' is set
        if ('invitation_id' not in params) or (params['invitation_id'] is None):
            raise ValueError("Missing the required parameter `invitation_id` when calling `accept_access_request`")


        resource_path = '/api/backend/v1/accessRequests/{accessRequestId}/accept'.replace('{format}', 'json')
        path_params = {}
        if 'invitation_id' in params:
            path_params['invitationId'] = params['invitation_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def accept_invitation(self, invitation_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.accept_invitation(invitation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str invitation_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['invitation_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accept_invitation" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'invitation_id' is set
        if ('invitation_id' not in params) or (params['invitation_id'] is None):
            raise ValueError("Missing the required parameter `invitation_id` when calling `accept_invitation`")


        resource_path = '/api/backend/v1/invitations/{invitationId}/accept'.replace('{format}', 'json')
        path_params = {}
        if 'invitation_id' in params:
            path_params['invitationId'] = params['invitation_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def add_experiment_git_history(self, git_history_params, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_experiment_git_history(git_history_params, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param GitHistoryParams git_history_params:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['git_history_params']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_experiment_git_history" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'git_history_params' is set
        if ('git_history_params' not in params) or (params['git_history_params'] is None):
            raise ValueError("Missing the required parameter `git_history_params` when calling `add_experiment_git_history`")


        resource_path = '/api/backend/v1/experiments/gitHistory'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'git_history_params' in params:
            body_params = params['git_history_params']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def add_experiments_backups(self, backups, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_experiments_backups(backups, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ExperimentsBackups backups:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['backups']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_experiments_backups" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'backups' is set
        if ('backups' not in params) or (params['backups'] is None):
            raise ValueError("Missing the required parameter `backups` when calling `add_experiments_backups`")


        resource_path = '/api/backend/v1/experiments/backups'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'backups' in params:
            body_params = params['backups']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def add_organization_member(self, organization_name, member, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_organization_member(organization_name, member, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param NewOrganizationMember member:  (required)
        :return: OrganizationMember
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'member']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_organization_member" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `add_organization_member`")
        # verify the required parameter 'member' is set
        if ('member' not in params) or (params['member'] is None):
            raise ValueError("Missing the required parameter `member` when calling `add_organization_member`")


        resource_path = '/api/backend/v1/organizations/{organizationName}/members'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'member' in params:
            body_params = params['member']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='OrganizationMember',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def add_organizations_funds(self, organization_id, additional_funds, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_organizations_funds(organization_id, additional_funds, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :param AdditionalFunds additional_funds:  (required)
        :return: OrganizationsFunds
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'additional_funds']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_organizations_funds" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `add_organizations_funds`")
        # verify the required parameter 'additional_funds' is set
        if ('additional_funds' not in params) or (params['additional_funds'] is None):
            raise ValueError("Missing the required parameter `additional_funds` when calling `add_organizations_funds`")


        resource_path = '/api/backend/v1/organizations/{organizationId}/funds/add'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'additional_funds' in params:
            body_params = params['additional_funds']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='OrganizationsFunds',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def add_project_bookmark(self, organization_name, project_name, bookmark, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_project_bookmark(organization_name, project_name, bookmark, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param str project_name:  (required)
        :param NewProjectBookmark bookmark:  (required)
        :return: ProjectBookmark
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'project_name', 'bookmark']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_project_bookmark" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `add_project_bookmark`")
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params) or (params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `add_project_bookmark`")
        # verify the required parameter 'bookmark' is set
        if ('bookmark' not in params) or (params['bookmark'] is None):
            raise ValueError("Missing the required parameter `bookmark` when calling `add_project_bookmark`")


        resource_path = '/api/backend/v1/organizations/{organizationName}/projects/{projectName}/bookmarks'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']
        if 'project_name' in params:
            path_params['projectName'] = params['project_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bookmark' in params:
            body_params = params['bookmark']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ProjectBookmark',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def add_project_member(self, project_id, member, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_project_member(project_id, member, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :param NewProjectMember member:  (required)
        :return: ProjectMember
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'member']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_project_member" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `add_project_member`")
        # verify the required parameter 'member' is set
        if ('member' not in params) or (params['member'] is None):
            raise ValueError("Missing the required parameter `member` when calling `add_project_member`")


        resource_path = '/api/backend/v1/projects/{projectId}/members'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'member' in params:
            body_params = params['member']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ProjectMember',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def add_user_profile_link(self, link, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_user_profile_link(link, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param Link link:  (required)
        :return: TypedLink
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['link']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_user_profile_link" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'link' is set
        if ('link' not in params) or (params['link'] is None):
            raise ValueError("Missing the required parameter `link` when calling `add_user_profile_link`")


        resource_path = '/api/backend/v1/userProfile/links'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'link' in params:
            body_params = params['link']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='TypedLink',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def cancel_subscription(self, organization_id, subscription_cancel, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.cancel_subscription(organization_id, subscription_cancel, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :param SubscriptionCancel subscription_cancel:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'subscription_cancel']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_subscription" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `cancel_subscription`")
        # verify the required parameter 'subscription_cancel' is set
        if ('subscription_cancel' not in params) or (params['subscription_cancel'] is None):
            raise ValueError("Missing the required parameter `subscription_cancel` when calling `cancel_subscription`")


        resource_path = '/api/backend/v1/organizations/{organizationId}/cancelSubscription'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'subscription_cancel' in params:
            body_params = params['subscription_cancel']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def change_password(self, password_to_update, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.change_password(password_to_update, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param PasswordChange password_to_update:  (required)
        :return: PasswordChange
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['password_to_update']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_password" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'password_to_update' is set
        if ('password_to_update' not in params) or (params['password_to_update'] is None):
            raise ValueError("Missing the required parameter `password_to_update` when calling `change_password`")


        resource_path = '/api/backend/v1/userProfile/password'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'password_to_update' in params:
            body_params = params['password_to_update']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='PasswordChange',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def clone_experiments(self, experiment_ids, target_project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.clone_experiments(experiment_ids, target_project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[str] experiment_ids:  (required)
        :param str target_project_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_ids', 'target_project_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clone_experiments" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_ids' is set
        if ('experiment_ids' not in params) or (params['experiment_ids'] is None):
            raise ValueError("Missing the required parameter `experiment_ids` when calling `clone_experiments`")
        # verify the required parameter 'target_project_id' is set
        if ('target_project_id' not in params) or (params['target_project_id'] is None):
            raise ValueError("Missing the required parameter `target_project_id` when calling `clone_experiments`")


        resource_path = '/api/backend/v1/experiments/clone'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'target_project_id' in params:
            body_params = params['target_project_id']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def config_info_get(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.config_info_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: ConfigInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method config_info_get" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/v1/configInfo'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ConfigInfo',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def count_matching_leaderboard_entries(self, named_filter_params, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.count_matching_leaderboard_entries(named_filter_params, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param NamedFilterParams named_filter_params:  (required)
        :return: LeaderboardEntryCount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['named_filter_params']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method count_matching_leaderboard_entries" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'named_filter_params' is set
        if ('named_filter_params' not in params) or (params['named_filter_params'] is None):
            raise ValueError("Missing the required parameter `named_filter_params` when calling `count_matching_leaderboard_entries`")


        resource_path = '/api/backend/v1/namedFilters/count'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'named_filter_params' in params:
            body_params = params['named_filter_params']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='LeaderboardEntryCount',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def create_alias(self, alias_to_create, project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_alias(alias_to_create, project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param AliasParams alias_to_create:  (required)
        :param str project_id:  (required)
        :return: Alias
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['alias_to_create', 'project_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_alias" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'alias_to_create' is set
        if ('alias_to_create' not in params) or (params['alias_to_create'] is None):
            raise ValueError("Missing the required parameter `alias_to_create` when calling `create_alias`")
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `create_alias`")


        resource_path = '/api/backend/v1/aliases'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'project_id' in params:
            query_params['projectId'] = params['project_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'alias_to_create' in params:
            body_params = params['alias_to_create']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Alias',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def create_channel(self, experiment_id, channel_to_create, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_channel(experiment_id, channel_to_create, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param ChannelParams channel_to_create:  (required)
        :return: Channel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'channel_to_create']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_channel" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `create_channel`")
        # verify the required parameter 'channel_to_create' is set
        if ('channel_to_create' not in params) or (params['channel_to_create'] is None):
            raise ValueError("Missing the required parameter `channel_to_create` when calling `create_channel`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/channels'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'channel_to_create' in params:
            body_params = params['channel_to_create']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Channel',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def create_chart(self, chart_to_create, chart_set_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_chart(chart_to_create, chart_set_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ChartDefinition chart_to_create:  (required)
        :param str chart_set_id:  (required)
        :return: Chart
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['chart_to_create', 'chart_set_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_chart" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'chart_to_create' is set
        if ('chart_to_create' not in params) or (params['chart_to_create'] is None):
            raise ValueError("Missing the required parameter `chart_to_create` when calling `create_chart`")
        # verify the required parameter 'chart_set_id' is set
        if ('chart_set_id' not in params) or (params['chart_set_id'] is None):
            raise ValueError("Missing the required parameter `chart_set_id` when calling `create_chart`")


        resource_path = '/api/backend/v1/chartSets/{chartSetId}/charts'.replace('{format}', 'json')
        path_params = {}
        if 'chart_set_id' in params:
            path_params['chartSetId'] = params['chart_set_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'chart_to_create' in params:
            body_params = params['chart_to_create']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Chart',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def create_chart_set(self, chart_set_to_create, project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_chart_set(chart_set_to_create, project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ChartSetParams chart_set_to_create:  (required)
        :param str project_id:  (required)
        :return: ChartSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['chart_set_to_create', 'project_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_chart_set" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'chart_set_to_create' is set
        if ('chart_set_to_create' not in params) or (params['chart_set_to_create'] is None):
            raise ValueError("Missing the required parameter `chart_set_to_create` when calling `create_chart_set`")
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `create_chart_set`")


        resource_path = '/api/backend/v1/chartSets'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'project_id' in params:
            query_params['projectId'] = params['project_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'chart_set_to_create' in params:
            body_params = params['chart_set_to_create']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ChartSet',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def create_experiment(self, experiment_creation_params, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_experiment(experiment_creation_params, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ExperimentCreationParams experiment_creation_params:  (required)
        :param str x_neptune_cli_version: 
        :return: Experiment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_creation_params', 'x_neptune_cli_version']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_experiment" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_creation_params' is set
        if ('experiment_creation_params' not in params) or (params['experiment_creation_params'] is None):
            raise ValueError("Missing the required parameter `experiment_creation_params` when calling `create_experiment`")


        resource_path = '/api/backend/v1/experiments'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}
        if 'x_neptune_cli_version' in params:
            header_params['X-Neptune-CliVersion'] = params['x_neptune_cli_version']

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_creation_params' in params:
            body_params = params['experiment_creation_params']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Experiment',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def create_experiment_with_notebook(self, params, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_experiment_with_notebook(params, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param NotebookExperimentParams params:  (required)
        :return: Experiment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['params']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_experiment_with_notebook" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'params' is set
        if ('params' not in params) or (params['params'] is None):
            raise ValueError("Missing the required parameter `params` when calling `create_experiment_with_notebook`")


        resource_path = '/api/backend/v1/experiments/jupyterNotebooks'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'params' in params:
            body_params = params['params']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Experiment',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def create_group(self, group_creation_params, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_group(group_creation_params, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param GroupCreationParams group_creation_params:  (required)
        :param str x_neptune_cli_version: 
        :return: Group
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_creation_params', 'x_neptune_cli_version']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_group" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'group_creation_params' is set
        if ('group_creation_params' not in params) or (params['group_creation_params'] is None):
            raise ValueError("Missing the required parameter `group_creation_params` when calling `create_group`")


        resource_path = '/api/backend/v1/groups'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}
        if 'x_neptune_cli_version' in params:
            header_params['X-Neptune-CliVersion'] = params['x_neptune_cli_version']

        form_params = []
        local_var_files = {}

        body_params = None
        if 'group_creation_params' in params:
            body_params = params['group_creation_params']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Group',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def create_named_filter(self, named_filter_to_create, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_named_filter(named_filter_to_create, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param NamedFilterParams named_filter_to_create:  (required)
        :return: NamedFilter
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['named_filter_to_create']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_named_filter" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'named_filter_to_create' is set
        if ('named_filter_to_create' not in params) or (params['named_filter_to_create'] is None):
            raise ValueError("Missing the required parameter `named_filter_to_create` when calling `create_named_filter`")


        resource_path = '/api/backend/v1/namedFilters'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'named_filter_to_create' in params:
            body_params = params['named_filter_to_create']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='NamedFilter',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def create_organization(self, organization_to_create, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_organization(organization_to_create, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param OrganizationCreationParams organization_to_create:  (required)
        :return: Organization
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_to_create']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_organization" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_to_create' is set
        if ('organization_to_create' not in params) or (params['organization_to_create'] is None):
            raise ValueError("Missing the required parameter `organization_to_create` when calling `create_organization`")


        resource_path = '/api/backend/v1/organizations'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_to_create' in params:
            body_params = params['organization_to_create']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Organization',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def create_project(self, project_to_create, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_project(project_to_create, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param ProjectCreationParams project_to_create:  (required)
        :return: ProjectWithRole
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_to_create']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_project" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_to_create' is set
        if ('project_to_create' not in params) or (params['project_to_create'] is None):
            raise ValueError("Missing the required parameter `project_to_create` when calling `create_project`")


        resource_path = '/api/backend/v1/projects'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_to_create' in params:
            body_params = params['project_to_create']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ProjectWithRole',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def create_project_page(self, organization_name, project_name, project_page, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_project_page(organization_name, project_name, project_page, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param str project_name:  (required)
        :param NewProjectPageDTO project_page:  (required)
        :return: ProjectPageDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'project_name', 'project_page']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_project_page" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `create_project_page`")
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params) or (params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `create_project_page`")
        # verify the required parameter 'project_page' is set
        if ('project_page' not in params) or (params['project_page'] is None):
            raise ValueError("Missing the required parameter `project_page` when calling `create_project_page`")


        resource_path = '/api/backend/v1/pages/organizations/{organizationName}/projects/{projectName}'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']
        if 'project_name' in params:
            path_params['projectName'] = params['project_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_page' in params:
            body_params = params['project_page']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ProjectPageDTO',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def create_system_channel(self, experiment_id, channel_to_create, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_system_channel(experiment_id, channel_to_create, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param ChannelParams channel_to_create:  (required)
        :return: Channel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'channel_to_create']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_system_channel" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `create_system_channel`")
        # verify the required parameter 'channel_to_create' is set
        if ('channel_to_create' not in params) or (params['channel_to_create'] is None):
            raise ValueError("Missing the required parameter `channel_to_create` when calling `create_system_channel`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/system/channels'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'channel_to_create' in params:
            body_params = params['channel_to_create']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Channel',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def create_system_metric(self, experiment_id, metric_to_create, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_system_metric(experiment_id, metric_to_create, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param SystemMetricParams metric_to_create:  (required)
        :return: SystemMetric
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'metric_to_create']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_system_metric" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `create_system_metric`")
        # verify the required parameter 'metric_to_create' is set
        if ('metric_to_create' not in params) or (params['metric_to_create'] is None):
            raise ValueError("Missing the required parameter `metric_to_create` when calling `create_system_metric`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/system/metrics'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'metric_to_create' in params:
            body_params = params['metric_to_create']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SystemMetric',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def delete_alias(self, alias_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_alias(alias_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str alias_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['alias_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_alias" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'alias_id' is set
        if ('alias_id' not in params) or (params['alias_id'] is None):
            raise ValueError("Missing the required parameter `alias_id` when calling `delete_alias`")


        resource_path = '/api/backend/v1/aliases/{aliasId}'.replace('{format}', 'json')
        path_params = {}
        if 'alias_id' in params:
            path_params['aliasId'] = params['alias_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def delete_channel(self, experiment_id, channel_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_channel(experiment_id, channel_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param str channel_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'channel_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_channel" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `delete_channel`")
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params) or (params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `delete_channel`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/channel/{channelId}'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def delete_channel_values(self, experiment_id, channel_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_channel_values(experiment_id, channel_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param str channel_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'channel_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_channel_values" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `delete_channel_values`")
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params) or (params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `delete_channel_values`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/channel/{channelId}/values'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def delete_chart(self, chart_id, chart_set_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_chart(chart_id, chart_set_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str chart_id:  (required)
        :param str chart_set_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['chart_id', 'chart_set_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_chart" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'chart_id' is set
        if ('chart_id' not in params) or (params['chart_id'] is None):
            raise ValueError("Missing the required parameter `chart_id` when calling `delete_chart`")
        # verify the required parameter 'chart_set_id' is set
        if ('chart_set_id' not in params) or (params['chart_set_id'] is None):
            raise ValueError("Missing the required parameter `chart_set_id` when calling `delete_chart`")


        resource_path = '/api/backend/v1/chartSets/{chartSetId}/charts/{chartId}'.replace('{format}', 'json')
        path_params = {}
        if 'chart_id' in params:
            path_params['chartId'] = params['chart_id']
        if 'chart_set_id' in params:
            path_params['chartSetId'] = params['chart_set_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def delete_chart_set(self, chart_set_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_chart_set(chart_set_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str chart_set_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['chart_set_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_chart_set" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'chart_set_id' is set
        if ('chart_set_id' not in params) or (params['chart_set_id'] is None):
            raise ValueError("Missing the required parameter `chart_set_id` when calling `delete_chart_set`")


        resource_path = '/api/backend/v1/chartSets/{chartSetId}'.replace('{format}', 'json')
        path_params = {}
        if 'chart_set_id' in params:
            path_params['chartSetId'] = params['chart_set_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def delete_named_filter(self, named_filter_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_named_filter(named_filter_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str named_filter_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['named_filter_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_named_filter" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'named_filter_id' is set
        if ('named_filter_id' not in params) or (params['named_filter_id'] is None):
            raise ValueError("Missing the required parameter `named_filter_id` when calling `delete_named_filter`")


        resource_path = '/api/backend/v1/namedFilters/{namedFilterId}'.replace('{format}', 'json')
        path_params = {}
        if 'named_filter_id' in params:
            path_params['namedFilterId'] = params['named_filter_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def delete_notebooks(self, experiment_ids, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_notebooks(experiment_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[str] experiment_ids:  (required)
        :return: list[BatchExperimentUpdateResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_ids']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_notebooks" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_ids' is set
        if ('experiment_ids' not in params) or (params['experiment_ids'] is None):
            raise ValueError("Missing the required parameter `experiment_ids` when calling `delete_notebooks`")


        resource_path = '/api/backend/v1/experiments/jupyterNotebooks/delete'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_ids' in params:
            body_params = params['experiment_ids']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[BatchExperimentUpdateResult]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def delete_organization(self, organization_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_organization(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_organization" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `delete_organization`")


        resource_path = '/api/backend/v1/organizations/{organizationId}'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def delete_organization_member(self, organization_name, user_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_organization_member(organization_name, user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param str user_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'user_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_organization_member" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `delete_organization_member`")
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_organization_member`")


        resource_path = '/api/backend/v1/organizations/{organizationName}/members/{userId}'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']
        if 'user_id' in params:
            path_params['userId'] = params['user_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def delete_project(self, project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_project(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_project" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `delete_project`")


        resource_path = '/api/backend/v1/projects/{projectId}'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def delete_project_bookmark(self, organization_name, project_name, bookmark_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_project_bookmark(organization_name, project_name, bookmark_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param str project_name:  (required)
        :param str bookmark_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'project_name', 'bookmark_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_project_bookmark" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `delete_project_bookmark`")
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params) or (params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `delete_project_bookmark`")
        # verify the required parameter 'bookmark_id' is set
        if ('bookmark_id' not in params) or (params['bookmark_id'] is None):
            raise ValueError("Missing the required parameter `bookmark_id` when calling `delete_project_bookmark`")


        resource_path = '/api/backend/v1/organizations/{organizationName}/projects/{projectName}/bookmarks/{bookmarkId}'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']
        if 'project_name' in params:
            path_params['projectName'] = params['project_name']
        if 'bookmark_id' in params:
            path_params['bookmarkId'] = params['bookmark_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def delete_project_member(self, project_id, user_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_project_member(project_id, user_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :param str user_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'user_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_project_member" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `delete_project_member`")
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_project_member`")


        resource_path = '/api/backend/v1/projects/{projectId}/members/{userId}'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']
        if 'user_id' in params:
            path_params['userId'] = params['user_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def delete_project_page(self, organization_name, project_name, page_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_project_page(organization_name, project_name, page_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param str project_name:  (required)
        :param str page_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'project_name', 'page_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_project_page" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `delete_project_page`")
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params) or (params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `delete_project_page`")
        # verify the required parameter 'page_id' is set
        if ('page_id' not in params) or (params['page_id'] is None):
            raise ValueError("Missing the required parameter `page_id` when calling `delete_project_page`")


        resource_path = '/api/backend/v1/pages/organizations/{organizationName}/projects/{projectName}/{pageId}'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']
        if 'project_name' in params:
            path_params['projectName'] = params['project_name']
        if 'page_id' in params:
            path_params['pageId'] = params['page_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def delete_user_profile_link(self, link, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_user_profile_link(link, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param Link link:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['link']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_profile_link" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'link' is set
        if ('link' not in params) or (params['link'] is None):
            raise ValueError("Missing the required parameter `link` when calling `delete_user_profile_link`")


        resource_path = '/api/backend/v1/userProfile/links'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'link' in params:
            body_params = params['link']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def download_cli(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.download_cli(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_cli" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/cli'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='File',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def download_path(self, path_param, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.download_path(path_param, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path_param:  (required)
        :param bool preview: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path_param', 'preview']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_path" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'path_param' is set
        if ('path_param' not in params) or (params['path_param'] is None):
            raise ValueError("Missing the required parameter `path_param` when calling `download_path`")


        resource_path = '/api/backend/v1/storage/download'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'path_param' in params:
            query_params['pathParam'] = params['path_param']
        if 'preview' in params:
            query_params['preview'] = params['preview']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def empty_experiments_trash(self, experiment_ids, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.empty_experiments_trash(experiment_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[str] experiment_ids:  (required)
        :return: list[BatchExperimentUpdateResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_ids']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method empty_experiments_trash" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_ids' is set
        if ('experiment_ids' not in params) or (params['experiment_ids'] is None):
            raise ValueError("Missing the required parameter `experiment_ids` when calling `empty_experiments_trash`")


        resource_path = '/api/backend/v1/experiments/trash/empty'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_ids' in params:
            body_params = params['experiment_ids']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[BatchExperimentUpdateResult]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def empty_groups_trash(self, group_ids, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.empty_groups_trash(group_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[str] group_ids:  (required)
        :return: list[BatchGroupUpdateResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_ids']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method empty_groups_trash" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'group_ids' is set
        if ('group_ids' not in params) or (params['group_ids'] is None):
            raise ValueError("Missing the required parameter `group_ids` when calling `empty_groups_trash`")


        resource_path = '/api/backend/v1/groups/trash/empty'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'group_ids' in params:
            body_params = params['group_ids']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[BatchGroupUpdateResult]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def exchange_api_token(self, x_neptune_api_token, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.exchange_api_token(x_neptune_api_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str x_neptune_api_token:  (required)
        :return: NeptuneOauthToken
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['x_neptune_api_token']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method exchange_api_token" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'x_neptune_api_token' is set
        if ('x_neptune_api_token' not in params) or (params['x_neptune_api_token'] is None):
            raise ValueError("Missing the required parameter `x_neptune_api_token` when calling `exchange_api_token`")


        resource_path = '/api/backend/v1/authorization/oauth-token'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}
        if 'x_neptune_api_token' in params:
            header_params['X-Neptune-Api-Token'] = params['x_neptune_api_token']

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='NeptuneOauthToken',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def finalize_experiment_upload(self, experiment_id, target_experiment_ids, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.finalize_experiment_upload(experiment_id, target_experiment_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param list[str] target_experiment_ids:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'target_experiment_ids']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method finalize_experiment_upload" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `finalize_experiment_upload`")
        # verify the required parameter 'target_experiment_ids' is set
        if ('target_experiment_ids' not in params) or (params['target_experiment_ids'] is None):
            raise ValueError("Missing the required parameter `target_experiment_ids` when calling `finalize_experiment_upload`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/finalizeExperimentUpload'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'target_experiment_ids' in params:
            body_params = params['target_experiment_ids']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def generate_project_key(self, organization_id, project_name, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.generate_project_key(organization_id, project_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :param str project_name:  (required)
        :return: ProjectKey
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'project_name']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_project_key" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `generate_project_key`")
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params) or (params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `generate_project_key`")


        resource_path = '/api/backend/v1/organizations/{organizationId}/generateProjectKey'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}
        if 'project_name' in params:
            query_params['projectName'] = params['project_name']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ProjectKey',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_action_events(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_action_events(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: list[ActionEvent]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_action_events" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_action_events`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/actionEvents'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[ActionEvent]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_action_invocations(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_action_invocations(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: list[ActionInvocation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_action_invocations" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_action_invocations`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/actionInvocations'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[ActionInvocation]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_alias(self, alias_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_alias(alias_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str alias_id:  (required)
        :return: Alias
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['alias_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_alias" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'alias_id' is set
        if ('alias_id' not in params) or (params['alias_id'] is None):
            raise ValueError("Missing the required parameter `alias_id` when calling `get_alias`")


        resource_path = '/api/backend/v1/aliases/{aliasId}'.replace('{format}', 'json')
        path_params = {}
        if 'alias_id' in params:
            path_params['aliasId'] = params['alias_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Alias',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_api_token(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_api_token(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_api_token" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/v1/authorization/api-token'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_automatic_renewal(self, organization_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_automatic_renewal(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :return: AutomaticRenewal
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_automatic_renewal" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `get_automatic_renewal`")


        resource_path = '/api/backend/v1/organizations/{organizationId}/funds/renewal'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='AutomaticRenewal',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_billing(self, organization_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_billing(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :param datetime start_date: 
        :param datetime end_date: 
        :return: Billing
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'start_date', 'end_date']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_billing" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `get_billing`")


        resource_path = '/api/backend/v1/organizations/{organizationId}/billing'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}
        if 'start_date' in params:
            query_params['startDate'] = params['start_date']
        if 'end_date' in params:
            query_params['endDate'] = params['end_date']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Billing',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_bills_summary(self, organization_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_bills_summary(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :param datetime start_date: 
        :param datetime end_date: 
        :return: BillsSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'start_date', 'end_date']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bills_summary" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `get_bills_summary`")


        resource_path = '/api/backend/v1/organizations/{organizationId}/billsSummary'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}
        if 'start_date' in params:
            query_params['startDate'] = params['start_date']
        if 'end_date' in params:
            query_params['endDate'] = params['end_date']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='BillsSummary',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_channel_values(self, experiment_id, channel_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_channel_values(experiment_id, channel_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param str channel_id:  (required)
        :param int offset: 
        :param int limit: 
        :return: LimitedChannelValues
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'channel_id', 'offset', 'limit']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_channel_values" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_channel_values`")
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params) or (params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `get_channel_values`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/channel/{channelId}/values'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']

        query_params = {}
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'limit' in params:
            query_params['limit'] = params['limit']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='LimitedChannelValues',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_channel_values_csv(self, experiment_id, channel_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_channel_values_csv(experiment_id, channel_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param str channel_id:  (required)
        :param bool gzipped: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'channel_id', 'gzipped']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_channel_values_csv" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_channel_values_csv`")
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params) or (params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `get_channel_values_csv`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/channel/{channelId}/csv'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']

        query_params = {}
        if 'gzipped' in params:
            query_params['gzipped'] = params['gzipped']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_channels_last_values(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_channels_last_values(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: list[ChannelWithValue]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_channels_last_values" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_channels_last_values`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/lastChannelValues'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[ChannelWithValue]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_chart(self, chart_set_id, chart_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_chart(chart_set_id, chart_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str chart_set_id:  (required)
        :param str chart_id:  (required)
        :return: Chart
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['chart_set_id', 'chart_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_chart" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'chart_set_id' is set
        if ('chart_set_id' not in params) or (params['chart_set_id'] is None):
            raise ValueError("Missing the required parameter `chart_set_id` when calling `get_chart`")
        # verify the required parameter 'chart_id' is set
        if ('chart_id' not in params) or (params['chart_id'] is None):
            raise ValueError("Missing the required parameter `chart_id` when calling `get_chart`")


        resource_path = '/api/backend/v1/chartSets/{chartSetId}/charts/{chartId}'.replace('{format}', 'json')
        path_params = {}
        if 'chart_set_id' in params:
            path_params['chartSetId'] = params['chart_set_id']
        if 'chart_id' in params:
            path_params['chartId'] = params['chart_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Chart',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_chart_set(self, chart_set_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_chart_set(chart_set_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str chart_set_id:  (required)
        :return: ChartSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['chart_set_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_chart_set" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'chart_set_id' is set
        if ('chart_set_id' not in params) or (params['chart_set_id'] is None):
            raise ValueError("Missing the required parameter `chart_set_id` when calling `get_chart_set`")


        resource_path = '/api/backend/v1/chartSets/{chartSetId}'.replace('{format}', 'json')
        path_params = {}
        if 'chart_set_id' in params:
            path_params['chartSetId'] = params['chart_set_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ChartSet',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_chart_values(self, experiment_id, chart_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_chart_values(experiment_id, chart_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param str chart_id:  (required)
        :param float start_point: 
        :param float end_point: 
        :param int item_count: 
        :return: list[ChartValues]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'chart_id', 'start_point', 'end_point', 'item_count']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_chart_values" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_chart_values`")
        # verify the required parameter 'chart_id' is set
        if ('chart_id' not in params) or (params['chart_id'] is None):
            raise ValueError("Missing the required parameter `chart_id` when calling `get_chart_values`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/charts/{chartId}/values'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']
        if 'chart_id' in params:
            path_params['chartId'] = params['chart_id']

        query_params = {}
        if 'start_point' in params:
            query_params['startPoint'] = params['start_point']
        if 'end_point' in params:
            query_params['endPoint'] = params['end_point']
        if 'item_count' in params:
            query_params['itemCount'] = params['item_count']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[ChartValues]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_download_payment_info(self, path_param, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_download_payment_info(path_param, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path_param:  (required)
        :return: DownloadPaymentInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path_param']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_download_payment_info" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'path_param' is set
        if ('path_param' not in params) or (params['path_param'] is None):
            raise ValueError("Missing the required parameter `path_param` when calling `get_download_payment_info`")


        resource_path = '/api/backend/v1/storage/downloadPaymentInfo'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'path_param' in params:
            query_params['pathParam'] = params['path_param']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='DownloadPaymentInfo',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_entities_path(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_entities_path(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id: 
        :param str organization_name: 
        :param str project_name: 
        :param str group_id: 
        :param str experiment_id: 
        :return: EntitiesPath
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'organization_name', 'project_name', 'group_id', 'experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_entities_path" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/v1/entitiesPath'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'organization_id' in params:
            query_params['organizationId'] = params['organization_id']
        if 'organization_name' in params:
            query_params['organizationName'] = params['organization_name']
        if 'project_name' in params:
            query_params['projectName'] = params['project_name']
        if 'group_id' in params:
            query_params['groupId'] = params['group_id']
        if 'experiment_id' in params:
            query_params['experimentId'] = params['experiment_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='EntitiesPath',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_execution_info(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_execution_info(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: ExecutionInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_execution_info" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_execution_info`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/executionInfo'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ExecutionInfo',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_experiment(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_experiment(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: Experiment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_experiment" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_experiment`")


        resource_path = '/api/backend/v1/experiments/{experimentId}'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Experiment',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_experiment_backups(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_experiment_backups(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_experiment_backups" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_experiment_backups`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/backups'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[str]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_experiment_charts(self, experiment_id, chart_set_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_experiment_charts(experiment_id, chart_set_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param str chart_set_id:  (required)
        :return: Charts
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'chart_set_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_experiment_charts" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_experiment_charts`")
        # verify the required parameter 'chart_set_id' is set
        if ('chart_set_id' not in params) or (params['chart_set_id'] is None):
            raise ValueError("Missing the required parameter `chart_set_id` when calling `get_experiment_charts`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/charts'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}
        if 'chart_set_id' in params:
            query_params['chartSetId'] = params['chart_set_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Charts',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_experiment_paths(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_experiment_paths(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: ExperimentPaths
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_experiment_paths" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_experiment_paths`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/paths'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ExperimentPaths',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_experiment_with_costs(self, organization_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_experiment_with_costs(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :param datetime start_date: 
        :param datetime end_date: 
        :return: LeaderboardEntryWithCostsList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'start_date', 'end_date']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_experiment_with_costs" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `get_experiment_with_costs`")


        resource_path = '/api/backend/v1/organizations/{organizationId}/costs/experimentCosts'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}
        if 'start_date' in params:
            query_params['startDate'] = params['start_date']
        if 'end_date' in params:
            query_params['endDate'] = params['end_date']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='LeaderboardEntryWithCostsList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_experiments(self, project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_experiments(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :param str filter_id: 
        :param list[str] sort_by: 
        :param list[str] sort_field_type: 
        :param list[str] sort_direction: 
        :param int offset: 
        :param int limit: 
        :param list[str] states: 
        :param list[str] owners: 
        :param str search_term: 
        :param list[str] tags: 
        :param datetime start_date: 
        :param datetime end_date: 
        :param bool trashed: 
        :return: LeaderboardList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'filter_id', 'sort_by', 'sort_field_type', 'sort_direction', 'offset', 'limit', 'states', 'owners', 'search_term', 'tags', 'start_date', 'end_date', 'trashed']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_experiments" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_experiments`")


        resource_path = '/api/backend/v1/experiments'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'project_id' in params:
            query_params['projectId'] = params['project_id']
        if 'filter_id' in params:
            query_params['filterId'] = params['filter_id']
        if 'sort_by' in params:
            query_params['sortBy'] = params['sort_by']
        if 'sort_field_type' in params:
            query_params['sortFieldType'] = params['sort_field_type']
        if 'sort_direction' in params:
            query_params['sortDirection'] = params['sort_direction']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'states' in params:
            query_params['states'] = params['states']
        if 'owners' in params:
            query_params['owners'] = params['owners']
        if 'search_term' in params:
            query_params['searchTerm'] = params['search_term']
        if 'tags' in params:
            query_params['tags'] = params['tags']
        if 'start_date' in params:
            query_params['startDate'] = params['start_date']
        if 'end_date' in params:
            query_params['endDate'] = params['end_date']
        if 'trashed' in params:
            query_params['trashed'] = params['trashed']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='LeaderboardList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_feature(self, id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_feature(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id:  (required)
        :return: FeatureDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_feature" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_feature`")


        resource_path = '/api/backend/v1/features/{id}'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='FeatureDTO',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_features(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_features(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[FeatureDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_features" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/v1/features'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[FeatureDTO]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_git_history(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_git_history(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: ExperimentGitHistory
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_git_history" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_git_history`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/gitHistory'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ExperimentGitHistory',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_group(self, group_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_group(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id:  (required)
        :return: Group
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_group" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `get_group`")


        resource_path = '/api/backend/v1/groups/{groupId}'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['groupId'] = params['group_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Group',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_image(self, experiment_id, channel_id, filename, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_image(experiment_id, channel_id, filename, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param str channel_id:  (required)
        :param str filename:  (required)
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'channel_id', 'filename']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_image" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_image`")
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in params) or (params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `get_image`")
        # verify the required parameter 'filename' is set
        if ('filename' not in params) or (params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `get_image`")


        resource_path = '/api/backend/images/{experimentId}/{channelId}/{filename}'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']
        if 'channel_id' in params:
            path_params['channelId'] = params['channel_id']
        if 'filename' in params:
            path_params['filename'] = params['filename']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='File',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_jupyter_notebook_as_html(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_jupyter_notebook_as_html(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_jupyter_notebook_as_html" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_jupyter_notebook_as_html`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/jupyterNotebook/html'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_jupyter_notebook_in_ipynb_format(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_jupyter_notebook_in_ipynb_format(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_jupyter_notebook_in_ipynb_format" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_jupyter_notebook_in_ipynb_format`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/jupyterNotebook/ipynb'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_named_filter(self, named_filter_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_named_filter(named_filter_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str named_filter_id:  (required)
        :return: NamedFilter
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['named_filter_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_named_filter" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'named_filter_id' is set
        if ('named_filter_id' not in params) or (params['named_filter_id'] is None):
            raise ValueError("Missing the required parameter `named_filter_id` when calling `get_named_filter`")


        resource_path = '/api/backend/v1/namedFilters/{namedFilterId}'.replace('{format}', 'json')
        path_params = {}
        if 'named_filter_id' in params:
            path_params['namedFilterId'] = params['named_filter_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='NamedFilter',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_new_features(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_new_features(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[FeatureDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_new_features" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/v1/features/new'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[FeatureDTO]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_organization(self, organization, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_organization(organization, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization:  (required)
        :param str input_format: 
        :return: Organization
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization', 'input_format']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_organization" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization' is set
        if ('organization' not in params) or (params['organization'] is None):
            raise ValueError("Missing the required parameter `organization` when calling `get_organization`")


        resource_path = '/api/backend/v1/organizations/{organization}'.replace('{format}', 'json')
        path_params = {}
        if 'organization' in params:
            path_params['organization'] = params['organization']

        query_params = {}
        if 'input_format' in params:
            query_params['inputFormat'] = params['input_format']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Organization',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_organization_account(self, organization_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_organization_account(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :return: OrganizationAccount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_organization_account" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `get_organization_account`")


        resource_path = '/api/backend/v1/organizations/{organizationId}/account'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='OrganizationAccount',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_organization_avatar(self, organization_name, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_organization_avatar(organization_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_organization_avatar" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `get_organization_avatar`")


        resource_path = '/api/backend/v1/organizations/{organizationName}/avatar'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_organization_payments_info(self, organization_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_organization_payments_info(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_organization_payments_info" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `get_organization_payments_info`")


        resource_path = '/api/backend/v1/organizations/{organizationId}/payments/info'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_organizations_seats(self, organization_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_organizations_seats(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :return: OrganizationsSeats
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_organizations_seats" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `get_organizations_seats`")


        resource_path = '/api/backend/v1/organizations/{organizationId}/seats'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='OrganizationsSeats',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_path_details(self, path_param, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_path_details(path_param, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path_param:  (required)
        :return: FileDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path_param']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_path_details" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'path_param' is set
        if ('path_param' not in params) or (params['path_param'] is None):
            raise ValueError("Missing the required parameter `path_param` when calling `get_path_details`")


        resource_path = '/api/backend/v1/storage/details'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'path_param' in params:
            query_params['pathParam'] = params['path_param']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='FileDetails',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_project(self, project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_project(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :return: ProjectWithRole
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_project`")


        resource_path = '/api/backend/v1/projects/{projectId}'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ProjectWithRole',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_project_avatar(self, project_name, organization_name, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_project_avatar(project_name, organization_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_name:  (required)
        :param str organization_name:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_name', 'organization_name']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_avatar" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_name' is set
        if ('project_name' not in params) or (params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `get_project_avatar`")
        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `get_project_avatar`")


        resource_path = '/api/backend/v1/organizations/{organizationName}/projects/{projectName}/avatar'.replace('{format}', 'json')
        path_params = {}
        if 'project_name' in params:
            path_params['projectName'] = params['project_name']
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['image/png'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_project_background(self, organization_name, project_name, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_project_background(organization_name, project_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param str project_name:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'project_name']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_background" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `get_project_background`")
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params) or (params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `get_project_background`")


        resource_path = '/api/backend/v1/organizations/{organizationName}/projects/{projectName}/background'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']
        if 'project_name' in params:
            path_params['projectName'] = params['project_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_project_by_name(self, organization_name, project_name, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_project_by_name(organization_name, project_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param str project_name:  (required)
        :return: ProjectWithRole
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'project_name']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_by_name" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `get_project_by_name`")
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params) or (params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `get_project_by_name`")


        resource_path = '/api/backend/v1/organizations/{organizationName}/projects/{projectName}'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']
        if 'project_name' in params:
            path_params['projectName'] = params['project_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ProjectWithRole',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_project_leaderboard_settings(self, project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_project_leaderboard_settings(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :return: LeaderboardSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_leaderboard_settings" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_project_leaderboard_settings`")


        resource_path = '/api/backend/v1/projects/{projectId}/leaderboard/settings'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='LeaderboardSettings',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_project_numeric_channels(self, project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_project_numeric_channels(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_numeric_channels" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_project_numeric_channels`")


        resource_path = '/api/backend/v1/projects/{projectId}/numericChannels'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[str]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_project_page(self, organization_name, project_name, page_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_project_page(organization_name, project_name, page_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param str project_name:  (required)
        :param str page_id:  (required)
        :return: ProjectPageDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'project_name', 'page_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_page" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `get_project_page`")
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params) or (params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `get_project_page`")
        # verify the required parameter 'page_id' is set
        if ('page_id' not in params) or (params['page_id'] is None):
            raise ValueError("Missing the required parameter `page_id` when calling `get_project_page`")


        resource_path = '/api/backend/v1/pages/organizations/{organizationName}/projects/{projectName}/{pageId}'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']
        if 'project_name' in params:
            path_params['projectName'] = params['project_name']
        if 'page_id' in params:
            path_params['pageId'] = params['page_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ProjectPageDTO',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_project_paths(self, organization_name, project_name, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_project_paths(organization_name, project_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param str project_name:  (required)
        :return: ProjectPaths
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'project_name']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_paths" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `get_project_paths`")
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params) or (params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `get_project_paths`")


        resource_path = '/api/backend/v1/organizations/{organizationName}/projects/{projectName}/paths'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']
        if 'project_name' in params:
            path_params['projectName'] = params['project_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ProjectPaths',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_project_settings(self, project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_project_settings(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :return: ProjectSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_settings" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_project_settings`")


        resource_path = '/api/backend/v1/projects/{projectId}/settings'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ProjectSettings',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_project_size(self, project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_project_size(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :return: ProjectSize
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_size" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_project_size`")


        resource_path = '/api/backend/v1/projects/{projectId}/size'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ProjectSize',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_running_experiment_costs(self, organization_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_running_experiment_costs(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :return: LeaderboardEntryWithCostsList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_running_experiment_costs" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `get_running_experiment_costs`")


        resource_path = '/api/backend/v1/organizations/{organizationId}/costs/runningExperimentCosts'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='LeaderboardEntryWithCostsList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_storage_cost_per_day(self, organization_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_storage_cost_per_day(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :param datetime start_date: 
        :param datetime end_date: 
        :return: StorageCostReport
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'start_date', 'end_date']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_storage_cost_per_day" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `get_storage_cost_per_day`")


        resource_path = '/api/backend/v1/organizations/{organizationId}/costs/storagePerDay'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}
        if 'start_date' in params:
            query_params['startDate'] = params['start_date']
        if 'end_date' in params:
            query_params['endDate'] = params['end_date']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='StorageCostReport',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_storage_info(self, project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_storage_info(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :return: StorageInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_storage_info" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_storage_info`")


        resource_path = '/api/backend/v1/projects/{projectId}/storageInfo'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='StorageInfo',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_system_channels(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_system_channels(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: list[Channel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_system_channels" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_system_channels`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/system/channels'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[Channel]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_system_metric_values(self, experiment_id, metric_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_system_metric_values(experiment_id, metric_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param str metric_id:  (required)
        :param int start_point: 
        :param int end_point: 
        :param int item_count: 
        :return: list[SystemMetricValues]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'metric_id', 'start_point', 'end_point', 'item_count']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_system_metric_values" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_system_metric_values`")
        # verify the required parameter 'metric_id' is set
        if ('metric_id' not in params) or (params['metric_id'] is None):
            raise ValueError("Missing the required parameter `metric_id` when calling `get_system_metric_values`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/system/metrics/{metricId}/values'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']
        if 'metric_id' in params:
            path_params['metricId'] = params['metric_id']

        query_params = {}
        if 'start_point' in params:
            query_params['startPoint'] = params['start_point']
        if 'end_point' in params:
            query_params['endPoint'] = params['end_point']
        if 'item_count' in params:
            query_params['itemCount'] = params['item_count']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[SystemMetricValues]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_system_metrics(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_system_metrics(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: list[SystemMetric]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_system_metrics" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_system_metrics`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/system/metrics'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[SystemMetric]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_system_metrics_csv(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_system_metrics_csv(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param bool gzipped: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'gzipped']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_system_metrics_csv" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_system_metrics_csv`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/system/metrics/csv'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}
        if 'gzipped' in params:
            query_params['gzipped'] = params['gzipped']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_tensorflow_graphs(self, experiment_id, ids, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_tensorflow_graphs(experiment_id, ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param list[str] ids:  (required)
        :return: list[TensorflowGraph]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'ids']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tensorflow_graphs" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `get_tensorflow_graphs`")
        # verify the required parameter 'ids' is set
        if ('ids' not in params) or (params['ids'] is None):
            raise ValueError("Missing the required parameter `ids` when calling `get_tensorflow_graphs`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/thirdPartyData/tensorflowGraph'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}
        if 'ids' in params:
            query_params['ids'] = params['ids']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[TensorflowGraph]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_user(self, username, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_user(username, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username:  (required)
        :return: PublicUserProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'username' is set
        if ('username' not in params) or (params['username'] is None):
            raise ValueError("Missing the required parameter `username` when calling `get_user`")


        resource_path = '/api/backend/v1/users/{username}'.replace('{format}', 'json')
        path_params = {}
        if 'username' in params:
            path_params['username'] = params['username']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='PublicUserProfile',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_user_avatar(self, username, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_user_avatar(username, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_avatar" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'username' is set
        if ('username' not in params) or (params['username'] is None):
            raise ValueError("Missing the required parameter `username` when calling `get_user_avatar`")


        resource_path = '/api/backend/v1/users/{username}/avatar'.replace('{format}', 'json')
        path_params = {}
        if 'username' in params:
            path_params['username'] = params['username']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_user_profile(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_user_profile(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: UserProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_profile" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/v1/userProfile'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UserProfile',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def get_user_profile_avatar(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_user_profile_avatar(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_profile_avatar" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/v1/userProfile/avatar'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def group_leaderboard(self, group_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.group_leaderboard(group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id:  (required)
        :param list[str] sort_by: 
        :param list[str] sort_field_type: 
        :param list[str] sort_direction: 
        :param int offset: 
        :param int limit: 
        :param list[str] states: 
        :param list[str] owners: 
        :param str search_term: 
        :param list[str] tags: 
        :param datetime start_date: 
        :param datetime end_date: 
        :param bool trashed: 
        :return: LeaderboardList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'sort_by', 'sort_field_type', 'sort_direction', 'offset', 'limit', 'states', 'owners', 'search_term', 'tags', 'start_date', 'end_date', 'trashed']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method group_leaderboard" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `group_leaderboard`")


        resource_path = '/api/backend/v1/groups/{groupId}/leaderboard'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['groupId'] = params['group_id']

        query_params = {}
        if 'sort_by' in params:
            query_params['sortBy'] = params['sort_by']
        if 'sort_field_type' in params:
            query_params['sortFieldType'] = params['sort_field_type']
        if 'sort_direction' in params:
            query_params['sortDirection'] = params['sort_direction']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'states' in params:
            query_params['states'] = params['states']
        if 'owners' in params:
            query_params['owners'] = params['owners']
        if 'search_term' in params:
            query_params['searchTerm'] = params['search_term']
        if 'tags' in params:
            query_params['tags'] = params['tags']
        if 'start_date' in params:
            query_params['startDate'] = params['start_date']
        if 'end_date' in params:
            query_params['endDate'] = params['end_date']
        if 'trashed' in params:
            query_params['trashed'] = params['trashed']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='LeaderboardList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def guess_project(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.guess_project(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id: 
        :param str organization_name: 
        :param str project_key: 
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'organization_name', 'project_key']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method guess_project" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/v1/project'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'organization_id' in params:
            query_params['organizationId'] = params['organization_id']
        if 'organization_name' in params:
            query_params['organizationName'] = params['organization_name']
        if 'project_key' in params:
            query_params['projectKey'] = params['project_key']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Project',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def healthz(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.healthz(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[ComponentStatus]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method healthz" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/healthz'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[ComponentStatus]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def invoke_action(self, experiment_id, action_id, invocation_params, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.invoke_action(experiment_id, action_id, invocation_params, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param str action_id:  (required)
        :param ActionInvocationParams invocation_params:  (required)
        :return: ActionInvocationConfirmation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'action_id', 'invocation_params']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method invoke_action" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `invoke_action`")
        # verify the required parameter 'action_id' is set
        if ('action_id' not in params) or (params['action_id'] is None):
            raise ValueError("Missing the required parameter `action_id` when calling `invoke_action`")
        # verify the required parameter 'invocation_params' is set
        if ('invocation_params' not in params) or (params['invocation_params'] is None):
            raise ValueError("Missing the required parameter `invocation_params` when calling `invoke_action`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/actions/{actionId}/invoke'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']
        if 'action_id' in params:
            path_params['actionId'] = params['action_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'invocation_params' in params:
            body_params = params['invocation_params']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ActionInvocationConfirmation',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def join_project(self, organization_name, project_name, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.join_project(organization_name, project_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param str project_name:  (required)
        :return: AccessRequestInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'project_name']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method join_project" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `join_project`")
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params) or (params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `join_project`")


        resource_path = '/api/backend/v1/organizations/{organizationName}/projects/{projectName}/join'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']
        if 'project_name' in params:
            path_params['projectName'] = params['project_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='AccessRequestInfo',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_environments(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_environments(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[Environment]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_environments" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/v1/environments'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[Environment]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_experiment_billing_data_from_period(self, organization_id, **kwargs):
        """
        List experiments of the given organization.
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_experiment_billing_data_from_period(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :param datetime from_: 
        :param datetime to: 
        :param str after: 
        :param int limit: 
        :return: list[ExperimentBillingEntryDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'from_', 'to', 'after', 'limit']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_experiment_billing_data_from_period" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `list_experiment_billing_data_from_period`")


        resource_path = '/api/backend/v1/newLeaderboard/organizations/{organizationId}/billing/experiments'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}
        if 'from_' in params:
            query_params['from'] = params['from_']
        if 'to' in params:
            query_params['to'] = params['to']
        if 'after' in params:
            query_params['after'] = params['after']
        if 'limit' in params:
            query_params['limit'] = params['limit']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[ExperimentBillingEntryDTO]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_experiments_in_organization(self, organization_id, **kwargs):
        """
        List experiments in organization
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_experiments_in_organization(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :param str after: 
        :param int limit: 
        :return: list[ExperimentEntryDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'after', 'limit']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_experiments_in_organization" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `list_experiments_in_organization`")


        resource_path = '/api/backend/v1/newLeaderboard/organizations/{organizationId}/experiments'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}
        if 'after' in params:
            query_params['after'] = params['after']
        if 'limit' in params:
            query_params['limit'] = params['limit']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[ExperimentEntryDTO]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_experiments_with_notebooks(self, organization_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_experiments_with_notebooks(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :param list[str] states: 
        :return: LeaderboardList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'states']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_experiments_with_notebooks" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `list_experiments_with_notebooks`")


        resource_path = '/api/backend/v1/experiments/jupyterNotebooks'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'organization_id' in params:
            query_params['organizationId'] = params['organization_id']
        if 'states' in params:
            query_params['states'] = params['states']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='LeaderboardList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_groups(self, organization_id, **kwargs):
        """
        List groups of the given organization.
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_groups(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :param str after: 
        :param int limit: 
        :return: list[GroupBillingEntryDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'after', 'limit']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_groups" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `list_groups`")


        resource_path = '/api/backend/v1/newLeaderboard/organizations/{organizationId}/billing/groups'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}
        if 'after' in params:
            query_params['after'] = params['after']
        if 'limit' in params:
            query_params['limit'] = params['limit']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[GroupBillingEntryDTO]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_groups_in_organization(self, organization_id, **kwargs):
        """
        List groups in organization
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_groups_in_organization(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :param str after: 
        :param int limit: 
        :return: list[GroupEntryDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'after', 'limit']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_groups_in_organization" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `list_groups_in_organization`")


        resource_path = '/api/backend/v1/newLeaderboard/organizations/{organizationId}/groups'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}
        if 'after' in params:
            query_params['after'] = params['after']
        if 'limit' in params:
            query_params['limit'] = params['limit']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[GroupEntryDTO]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_members(self, organization_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_members(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_members" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `list_members`")


        resource_path = '/api/backend/v1/members'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'organization_id' in params:
            query_params['organizationId'] = params['organization_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[User]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_named_filters(self, organization_name, project_name, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_named_filters(organization_name, project_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param str project_name:  (required)
        :return: list[NamedFilter]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'project_name']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_named_filters" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `list_named_filters`")
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params) or (params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `list_named_filters`")


        resource_path = '/api/backend/v1/organizations/{organizationName}/projects/{projectName}/namedFilters'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']
        if 'project_name' in params:
            path_params['projectName'] = params['project_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[NamedFilter]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_organization_members(self, organization_name, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_organization_members(organization_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :return: list[OrganizationMember]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_organization_members" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `list_organization_members`")


        resource_path = '/api/backend/v1/organizations/{organizationName}/members'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[OrganizationMember]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_organizations(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_organizations(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[OrganizationWithRole]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_organizations" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/v1/organizations'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[OrganizationWithRole]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_payments(self, organization_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_payments(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :param datetime start_date: 
        :param datetime end_date: 
        :return: list[Payment]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'start_date', 'end_date']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_payments" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `list_payments`")


        resource_path = '/api/backend/v1/organizations/{organizationId}/payments/history'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}
        if 'start_date' in params:
            query_params['startDate'] = params['start_date']
        if 'end_date' in params:
            query_params['endDate'] = params['end_date']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[Payment]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_pricing_plans(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_pricing_plans(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[PricingPlan]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_pricing_plans" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/v1/pricingPlans'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[PricingPlan]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_project_aliases(self, project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_project_aliases(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :return: list[Alias]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_project_aliases" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `list_project_aliases`")


        resource_path = '/api/backend/v1/aliases'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'project_id' in params:
            query_params['projectId'] = params['project_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[Alias]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_project_bookmarks(self, organization_name, project_name, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_project_bookmarks(organization_name, project_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param str project_name:  (required)
        :return: list[ProjectBookmark]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'project_name']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_project_bookmarks" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `list_project_bookmarks`")
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params) or (params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `list_project_bookmarks`")


        resource_path = '/api/backend/v1/organizations/{organizationName}/projects/{projectName}/bookmarks'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']
        if 'project_name' in params:
            path_params['projectName'] = params['project_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[ProjectBookmark]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_project_chart_sets(self, project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_project_chart_sets(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :return: list[ChartSet]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_project_chart_sets" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `list_project_chart_sets`")


        resource_path = '/api/backend/v1/chartSets'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'project_id' in params:
            query_params['projectId'] = params['project_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[ChartSet]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_project_members(self, organization_name, project_name, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_project_members(organization_name, project_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param str project_name:  (required)
        :return: list[ProjectMember]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'project_name']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_project_members" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `list_project_members`")
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params) or (params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `list_project_members`")


        resource_path = '/api/backend/v1/organizations/{organizationName}/projects/{projectName}/members'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']
        if 'project_name' in params:
            path_params['projectName'] = params['project_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[ProjectMember]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_project_pages(self, organization_name, project_name, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_project_pages(organization_name, project_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param str project_name:  (required)
        :return: list[ProjectPageSimpleDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'project_name']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_project_pages" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `list_project_pages`")
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params) or (params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `list_project_pages`")


        resource_path = '/api/backend/v1/pages/organizations/{organizationName}/projects/{projectName}'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']
        if 'project_name' in params:
            path_params['projectName'] = params['project_name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[ProjectPageSimpleDTO]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_projects_for_current_user(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_projects_for_current_user(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id: 
        :param str organization_name: 
        :param str search_term: 
        :param bool starred_by_me: 
        :param bool managed_by_me_only: 
        :param bool show_private_in_team: 
        :param str visibility: 
        :param list[str] sort_by: 
        :param list[str] sort_direction: 
        :param int offset: 
        :param int limit: 
        :return: ProjectList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'organization_name', 'search_term', 'starred_by_me', 'managed_by_me_only', 'show_private_in_team', 'visibility', 'sort_by', 'sort_direction', 'offset', 'limit']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_projects_for_current_user" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/v1/projects'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'organization_id' in params:
            query_params['organizationId'] = params['organization_id']
        if 'organization_name' in params:
            query_params['organizationName'] = params['organization_name']
        if 'search_term' in params:
            query_params['searchTerm'] = params['search_term']
        if 'starred_by_me' in params:
            query_params['starredByMe'] = params['starred_by_me']
        if 'managed_by_me_only' in params:
            query_params['managedByMeOnly'] = params['managed_by_me_only']
        if 'show_private_in_team' in params:
            query_params['showPrivateInTeam'] = params['show_private_in_team']
        if 'visibility' in params:
            query_params['visibility'] = params['visibility']
        if 'sort_by' in params:
            query_params['sortBy'] = params['sort_by']
        if 'sort_direction' in params:
            query_params['sortDirection'] = params['sort_direction']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'limit' in params:
            query_params['limit'] = params['limit']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ProjectList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_projects_in_organization(self, organization_name, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_projects_in_organization(organization_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param str search_term: 
        :param bool starred_by_me: 
        :param list[str] sort_by: 
        :param list[str] sort_direction: 
        :param int offset: 
        :param int limit: 
        :return: ProjectList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'search_term', 'starred_by_me', 'sort_by', 'sort_direction', 'offset', 'limit']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_projects_in_organization" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `list_projects_in_organization`")


        resource_path = '/api/backend/v1/organizations/{organizationName}/projects'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']

        query_params = {}
        if 'search_term' in params:
            query_params['searchTerm'] = params['search_term']
        if 'starred_by_me' in params:
            query_params['starredByMe'] = params['starred_by_me']
        if 'sort_by' in params:
            query_params['sortBy'] = params['sort_by']
        if 'sort_direction' in params:
            query_params['sortDirection'] = params['sort_direction']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'limit' in params:
            query_params['limit'] = params['limit']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ProjectList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_public_projects(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_public_projects(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str search_term: 
        :param bool starred_by_me: 
        :param list[str] sort_by: 
        :param list[str] sort_direction: 
        :param int offset: 
        :param int limit: 
        :return: ProjectList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search_term', 'starred_by_me', 'sort_by', 'sort_direction', 'offset', 'limit']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_public_projects" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/v1/projects/public'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'search_term' in params:
            query_params['searchTerm'] = params['search_term']
        if 'starred_by_me' in params:
            query_params['starredByMe'] = params['starred_by_me']
        if 'sort_by' in params:
            query_params['sortBy'] = params['sort_by']
        if 'sort_direction' in params:
            query_params['sortDirection'] = params['sort_direction']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'limit' in params:
            query_params['limit'] = params['limit']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ProjectList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_storage_quotas(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_storage_quotas(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[StorageQuota]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_storage_quotas" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/v1/storageQuotas'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[StorageQuota]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_user_recent_projects(self, organization_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_user_recent_projects(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :return: list[ProjectWithRole]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_user_recent_projects" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `list_user_recent_projects`")


        resource_path = '/api/backend/v1/projects/recentForUser'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'organization_id' in params:
            query_params['organizationId'] = params['organization_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[ProjectWithRole]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_users(self, username_prefix, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_users(username_prefix, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username_prefix:  (required)
        :param str organization_members_first: 
        :return: list[UserListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username_prefix', 'organization_members_first']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_users" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'username_prefix' is set
        if ('username_prefix' not in params) or (params['username_prefix'] is None):
            raise ValueError("Missing the required parameter `username_prefix` when calling `list_users`")


        resource_path = '/api/backend/v1/users'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'organization_members_first' in params:
            query_params['organizationMembersFirst'] = params['organization_members_first']
        if 'username_prefix' in params:
            query_params['usernamePrefix'] = params['username_prefix']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[UserListItem]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def list_worker_types(self, organization_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_worker_types(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :return: list[WorkerTypeWithCost]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_worker_types" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `list_worker_types`")


        resource_path = '/api/backend/v1/{organizationId}/workerTypes'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[WorkerTypeWithCost]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def login(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.login(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method login" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/v1/login'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def ls_data(self, project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.ls_data(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :param str path_param: 
        :param bool recursive: 
        :return: list[FileEntry]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'path_param', 'recursive']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ls_data" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `ls_data`")


        resource_path = '/api/backend/v1/data'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'project_id' in params:
            query_params['projectId'] = params['project_id']
        if 'path_param' in params:
            query_params['pathParam'] = params['path_param']
        if 'recursive' in params:
            query_params['recursive'] = params['recursive']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[FileEntry]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def ls_path(self, path_param, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.ls_path(path_param, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str path_param:  (required)
        :param bool recursive: 
        :return: list[FileEntry]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path_param', 'recursive']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ls_path" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'path_param' is set
        if ('path_param' not in params) or (params['path_param'] is None):
            raise ValueError("Missing the required parameter `path_param` when calling `ls_path`")


        resource_path = '/api/backend/v1/storage/ls'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'path_param' in params:
            query_params['pathParam'] = params['path_param']
        if 'recursive' in params:
            query_params['recursive'] = params['recursive']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[FileEntry]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def mark_action_invocation_completed(self, experiment_id, action_id, action_invocation_id, completed_action_params, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.mark_action_invocation_completed(experiment_id, action_id, action_invocation_id, completed_action_params, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param str action_id:  (required)
        :param str action_invocation_id:  (required)
        :param CompletedActionParams completed_action_params:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'action_id', 'action_invocation_id', 'completed_action_params']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_action_invocation_completed" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `mark_action_invocation_completed`")
        # verify the required parameter 'action_id' is set
        if ('action_id' not in params) or (params['action_id'] is None):
            raise ValueError("Missing the required parameter `action_id` when calling `mark_action_invocation_completed`")
        # verify the required parameter 'action_invocation_id' is set
        if ('action_invocation_id' not in params) or (params['action_invocation_id'] is None):
            raise ValueError("Missing the required parameter `action_invocation_id` when calling `mark_action_invocation_completed`")
        # verify the required parameter 'completed_action_params' is set
        if ('completed_action_params' not in params) or (params['completed_action_params'] is None):
            raise ValueError("Missing the required parameter `completed_action_params` when calling `mark_action_invocation_completed`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/actions/{actionId}/invocations/{actionInvocationId}/markCompleted'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']
        if 'action_id' in params:
            path_params['actionId'] = params['action_id']
        if 'action_invocation_id' in params:
            path_params['actionInvocationId'] = params['action_invocation_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'completed_action_params' in params:
            body_params = params['completed_action_params']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def mark_experiment_cleaning(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.mark_experiment_cleaning(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: Experiment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_experiment_cleaning" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `mark_experiment_cleaning`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/markCleaning'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Experiment',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def mark_experiment_completed(self, experiment_id, completed_experiment_params, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.mark_experiment_completed(experiment_id, completed_experiment_params, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param CompletedExperimentParams completed_experiment_params:  (required)
        :return: Experiment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'completed_experiment_params']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_experiment_completed" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `mark_experiment_completed`")
        # verify the required parameter 'completed_experiment_params' is set
        if ('completed_experiment_params' not in params) or (params['completed_experiment_params'] is None):
            raise ValueError("Missing the required parameter `completed_experiment_params` when calling `mark_experiment_completed`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/markCompleted'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'completed_experiment_params' in params:
            body_params = params['completed_experiment_params']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Experiment',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def mark_experiment_initializing(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.mark_experiment_initializing(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: Experiment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_experiment_initializing" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `mark_experiment_initializing`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/markInitializing'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Experiment',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def mark_experiment_running(self, experiment_id, running_experiment_params, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.mark_experiment_running(experiment_id, running_experiment_params, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param RunningExperimentParams running_experiment_params:  (required)
        :return: Experiment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'running_experiment_params']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_experiment_running" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `mark_experiment_running`")
        # verify the required parameter 'running_experiment_params' is set
        if ('running_experiment_params' not in params) or (params['running_experiment_params'] is None):
            raise ValueError("Missing the required parameter `running_experiment_params` when calling `mark_experiment_running`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/markRunning'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'running_experiment_params' in params:
            body_params = params['running_experiment_params']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Experiment',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def mark_experiment_waiting(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.mark_experiment_waiting(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: Experiment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_experiment_waiting" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `mark_experiment_waiting`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/markWaiting'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Experiment',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def mark_feature_viewed(self, id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.mark_feature_viewed(id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_feature_viewed" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `mark_feature_viewed`")


        resource_path = '/api/backend/v1/features/{id}/markViewed'.replace('{format}', 'json')
        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def mkdir_data(self, project_id, path_param, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.mkdir_data(project_id, path_param, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :param str path_param:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'path_param']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mkdir_data" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `mkdir_data`")
        # verify the required parameter 'path_param' is set
        if ('path_param' not in params) or (params['path_param'] is None):
            raise ValueError("Missing the required parameter `path_param` when calling `mkdir_data`")


        resource_path = '/api/backend/v1/data'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'project_id' in params:
            query_params['projectId'] = params['project_id']
        if 'path_param' in params:
            query_params['pathParam'] = params['path_param']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def ping_experiment(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.ping_experiment(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ping_experiment" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `ping_experiment`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/ping'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def post_channel_values(self, experiment_id, channels_values, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_channel_values(experiment_id, channels_values, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param list[InputChannelValues] channels_values:  (required)
        :return: list[BatchChannelValueError]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'channels_values']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_channel_values" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `post_channel_values`")
        # verify the required parameter 'channels_values' is set
        if ('channels_values' not in params) or (params['channels_values'] is None):
            raise ValueError("Missing the required parameter `channels_values` when calling `post_channel_values`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/channels/values'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'channels_values' in params:
            body_params = params['channels_values']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[BatchChannelValueError]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def post_system_metric_values(self, experiment_id, metric_values, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_system_metric_values(experiment_id, metric_values, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param list[SystemMetricValues] metric_values:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'metric_values']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_system_metric_values" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `post_system_metric_values`")
        # verify the required parameter 'metric_values' is set
        if ('metric_values' not in params) or (params['metric_values'] is None):
            raise ValueError("Missing the required parameter `metric_values` when calling `post_system_metric_values`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/system/metrics/values'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'metric_values' in params:
            body_params = params['metric_values']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def project_leaderboard(self, organization_name, project_name, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.project_leaderboard(organization_name, project_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param str project_name:  (required)
        :param str filter_id: 
        :param list[str] sort_by: 
        :param list[str] sort_field_type: 
        :param list[str] sort_direction: 
        :param int offset: 
        :param int limit: 
        :param list[str] states: 
        :param list[str] owners: 
        :param str search_term: 
        :param list[str] tags: 
        :param datetime start_date: 
        :param datetime end_date: 
        :param bool trashed: 
        :return: LeaderboardList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'project_name', 'filter_id', 'sort_by', 'sort_field_type', 'sort_direction', 'offset', 'limit', 'states', 'owners', 'search_term', 'tags', 'start_date', 'end_date', 'trashed']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_leaderboard" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `project_leaderboard`")
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params) or (params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `project_leaderboard`")


        resource_path = '/api/backend/v1/organizations/{organizationName}/projects/{projectName}/leaderboard'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']
        if 'project_name' in params:
            path_params['projectName'] = params['project_name']

        query_params = {}
        if 'filter_id' in params:
            query_params['filterId'] = params['filter_id']
        if 'sort_by' in params:
            query_params['sortBy'] = params['sort_by']
        if 'sort_field_type' in params:
            query_params['sortFieldType'] = params['sort_field_type']
        if 'sort_direction' in params:
            query_params['sortDirection'] = params['sort_direction']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'states' in params:
            query_params['states'] = params['states']
        if 'owners' in params:
            query_params['owners'] = params['owners']
        if 'search_term' in params:
            query_params['searchTerm'] = params['search_term']
        if 'tags' in params:
            query_params['tags'] = params['tags']
        if 'start_date' in params:
            query_params['startDate'] = params['start_date']
        if 'end_date' in params:
            query_params['endDate'] = params['end_date']
        if 'trashed' in params:
            query_params['trashed'] = params['trashed']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='LeaderboardList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def put_tensorflow_graph(self, experiment_id, tensorflow_graph, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_tensorflow_graph(experiment_id, tensorflow_graph, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param CompressedTensorflowGraph tensorflow_graph:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'tensorflow_graph']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_tensorflow_graph" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `put_tensorflow_graph`")
        # verify the required parameter 'tensorflow_graph' is set
        if ('tensorflow_graph' not in params) or (params['tensorflow_graph'] is None):
            raise ValueError("Missing the required parameter `tensorflow_graph` when calling `put_tensorflow_graph`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/thirdPartyData/tensorflowGraph'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tensorflow_graph' in params:
            body_params = params['tensorflow_graph']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def quota_get(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.quota_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: Quota
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method quota_get" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/v1/quota'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Quota',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def reject_access_request(self, invitation_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.reject_access_request(invitation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str invitation_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['invitation_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reject_access_request" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'invitation_id' is set
        if ('invitation_id' not in params) or (params['invitation_id'] is None):
            raise ValueError("Missing the required parameter `invitation_id` when calling `reject_access_request`")


        resource_path = '/api/backend/v1/accessRequests/{accessRequestId}/reject'.replace('{format}', 'json')
        path_params = {}
        if 'invitation_id' in params:
            path_params['invitationId'] = params['invitation_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def reject_invitation(self, invitation_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.reject_invitation(invitation_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str invitation_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['invitation_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reject_invitation" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'invitation_id' is set
        if ('invitation_id' not in params) or (params['invitation_id'] is None):
            raise ValueError("Missing the required parameter `invitation_id` when calling `reject_invitation`")


        resource_path = '/api/backend/v1/invitations/{invitationId}/reject'.replace('{format}', 'json')
        path_params = {}
        if 'invitation_id' in params:
            path_params['invitationId'] = params['invitation_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def request_enterprise(self, request_enterprise, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.request_enterprise(request_enterprise, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param RequestEnterpriseParams request_enterprise:  (required)
        :return: list[SendEmailResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['request_enterprise']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method request_enterprise" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'request_enterprise' is set
        if ('request_enterprise' not in params) or (params['request_enterprise'] is None):
            raise ValueError("Missing the required parameter `request_enterprise` when calling `request_enterprise`")


        resource_path = '/api/backend/v1/paymentPlans/requestEnterpriseVersion'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request_enterprise' in params:
            body_params = params['request_enterprise']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[SendEmailResponse]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def restore_experiments(self, experiment_ids, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.restore_experiments(experiment_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[str] experiment_ids:  (required)
        :return: list[BatchExperimentUpdateResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_ids']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restore_experiments" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_ids' is set
        if ('experiment_ids' not in params) or (params['experiment_ids'] is None):
            raise ValueError("Missing the required parameter `experiment_ids` when calling `restore_experiments`")


        resource_path = '/api/backend/v1/experiments/trash/restore'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_ids' in params:
            body_params = params['experiment_ids']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[BatchExperimentUpdateResult]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def restore_groups(self, group_ids, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.restore_groups(group_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[str] group_ids:  (required)
        :return: list[BatchGroupUpdateResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_ids']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restore_groups" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'group_ids' is set
        if ('group_ids' not in params) or (params['group_ids'] is None):
            raise ValueError("Missing the required parameter `group_ids` when calling `restore_groups`")


        resource_path = '/api/backend/v1/groups/trash/restore'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'group_ids' in params:
            body_params = params['group_ids']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[BatchGroupUpdateResult]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def rm_data(self, project_id, path_param, recursive, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.rm_data(project_id, path_param, recursive, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :param list[str] path_param:  (required)
        :param bool recursive:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'path_param', 'recursive']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rm_data" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `rm_data`")
        # verify the required parameter 'path_param' is set
        if ('path_param' not in params) or (params['path_param'] is None):
            raise ValueError("Missing the required parameter `path_param` when calling `rm_data`")
        # verify the required parameter 'recursive' is set
        if ('recursive' not in params) or (params['recursive'] is None):
            raise ValueError("Missing the required parameter `recursive` when calling `rm_data`")


        resource_path = '/api/backend/v1/data'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'project_id' in params:
            query_params['projectId'] = params['project_id']
        if 'path_param' in params:
            query_params['pathParam'] = params['path_param']
        if 'recursive' in params:
            query_params['recursive'] = params['recursive']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def set_automatic_renewal(self, organization_id, automatic_renewal, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_automatic_renewal(organization_id, automatic_renewal, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :param AutomaticRenewal automatic_renewal:  (required)
        :return: AutomaticRenewal
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'automatic_renewal']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_automatic_renewal" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `set_automatic_renewal`")
        # verify the required parameter 'automatic_renewal' is set
        if ('automatic_renewal' not in params) or (params['automatic_renewal'] is None):
            raise ValueError("Missing the required parameter `automatic_renewal` when calling `set_automatic_renewal`")


        resource_path = '/api/backend/v1/organizations/{organizationId}/funds/renewal'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'automatic_renewal' in params:
            body_params = params['automatic_renewal']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='AutomaticRenewal',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def set_group_best_experiment(self, group_id, best_experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_group_best_experiment(group_id, best_experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id:  (required)
        :param OptionalBestExperimentId best_experiment_id:  (required)
        :return: Group
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'best_experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_group_best_experiment" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `set_group_best_experiment`")
        # verify the required parameter 'best_experiment_id' is set
        if ('best_experiment_id' not in params) or (params['best_experiment_id'] is None):
            raise ValueError("Missing the required parameter `best_experiment_id` when calling `set_group_best_experiment`")


        resource_path = '/api/backend/v1/groups/{groupId}/bestExperiment'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['groupId'] = params['group_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'best_experiment_id' in params:
            body_params = params['best_experiment_id']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Group',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def set_organizations_seats(self, organization_id, organizations_seats_params, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_organizations_seats(organization_id, organizations_seats_params, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :param OrganizationsSeatsParams organizations_seats_params:  (required)
        :return: OrganizationsSeats
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'organizations_seats_params']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_organizations_seats" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `set_organizations_seats`")
        # verify the required parameter 'organizations_seats_params' is set
        if ('organizations_seats_params' not in params) or (params['organizations_seats_params'] is None):
            raise ValueError("Missing the required parameter `organizations_seats_params` when calling `set_organizations_seats`")


        resource_path = '/api/backend/v1/organizations/{organizationId}/seats'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organizations_seats_params' in params:
            body_params = params['organizations_seats_params']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='OrganizationsSeats',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def set_payments_info(self, organization_id, payments_info, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_payments_info(organization_id, payments_info, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :param PaymentsInfo payments_info:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'payments_info']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_payments_info" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `set_payments_info`")
        # verify the required parameter 'payments_info' is set
        if ('payments_info' not in params) or (params['payments_info'] is None):
            raise ValueError("Missing the required parameter `payments_info` when calling `set_payments_info`")


        resource_path = '/api/backend/v1/organizations/{organizationId}/payments/info'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payments_info' in params:
            body_params = params['payments_info']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def set_project_leaderboard_settings(self, project_id, leaderboard_settings, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_project_leaderboard_settings(project_id, leaderboard_settings, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :param LeaderboardSettings leaderboard_settings:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'leaderboard_settings']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_project_leaderboard_settings" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `set_project_leaderboard_settings`")
        # verify the required parameter 'leaderboard_settings' is set
        if ('leaderboard_settings' not in params) or (params['leaderboard_settings'] is None):
            raise ValueError("Missing the required parameter `leaderboard_settings` when calling `set_project_leaderboard_settings`")


        resource_path = '/api/backend/v1/projects/{projectId}/leaderboard/settings'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'leaderboard_settings' in params:
            body_params = params['leaderboard_settings']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def set_project_settings(self, project_id, project_settings, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_project_settings(project_id, project_settings, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :param ProjectSettings project_settings:  (required)
        :return: ProjectSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'project_settings']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_project_settings" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `set_project_settings`")
        # verify the required parameter 'project_settings' is set
        if ('project_settings' not in params) or (params['project_settings'] is None):
            raise ValueError("Missing the required parameter `project_settings` when calling `set_project_settings`")


        resource_path = '/api/backend/v1/projects/{projectId}/settings'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_settings' in params:
            body_params = params['project_settings']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ProjectSettings',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def set_storage_quota(self, project_id, storage_quota_params, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_storage_quota(project_id, storage_quota_params, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :param StorageQuotaParams storage_quota_params:  (required)
        :return: StorageQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'storage_quota_params']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_storage_quota" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `set_storage_quota`")
        # verify the required parameter 'storage_quota_params' is set
        if ('storage_quota_params' not in params) or (params['storage_quota_params'] is None):
            raise ValueError("Missing the required parameter `storage_quota_params` when calling `set_storage_quota`")


        resource_path = '/api/backend/v1/projects/{projectId}/storageQuota'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'storage_quota_params' in params:
            body_params = params['storage_quota_params']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='StorageQuota',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def star_project(self, project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.star_project(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :return: StarCount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method star_project" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `star_project`")


        resource_path = '/api/backend/v1/projects/{projectId}/stars'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='StarCount',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def status_get(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.status_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: Status
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method status_get" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/status'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Status',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def stop_notebooks(self, experiment_ids, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.stop_notebooks(experiment_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[str] experiment_ids:  (required)
        :return: list[BatchExperimentUpdateResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_ids']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stop_notebooks" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_ids' is set
        if ('experiment_ids' not in params) or (params['experiment_ids'] is None):
            raise ValueError("Missing the required parameter `experiment_ids` when calling `stop_notebooks`")


        resource_path = '/api/backend/v1/experiments/jupyterNotebooks/stop'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_ids' in params:
            body_params = params['experiment_ids']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[BatchExperimentUpdateResult]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def storage_usage(self, organization_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.storage_usage(organization_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :return: StorageUsage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_usage" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `storage_usage`")


        resource_path = '/api/backend/v1/organizations/{organizationId}/storageUsage'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='StorageUsage',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def tags_get(self, project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.tags_get(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tags_get" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `tags_get`")


        resource_path = '/api/backend/v1/tags'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'project_id' in params:
            query_params['projectId'] = params['project_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[str]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def trash_experiments(self, experiment_ids, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.trash_experiments(experiment_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[str] experiment_ids:  (required)
        :return: list[BatchExperimentUpdateResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_ids']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method trash_experiments" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_ids' is set
        if ('experiment_ids' not in params) or (params['experiment_ids'] is None):
            raise ValueError("Missing the required parameter `experiment_ids` when calling `trash_experiments`")


        resource_path = '/api/backend/v1/experiments/trash'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_ids' in params:
            body_params = params['experiment_ids']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[BatchExperimentUpdateResult]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def trash_groups(self, group_ids, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.trash_groups(group_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[str] group_ids:  (required)
        :return: list[BatchGroupUpdateResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_ids']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method trash_groups" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'group_ids' is set
        if ('group_ids' not in params) or (params['group_ids'] is None):
            raise ValueError("Missing the required parameter `group_ids` when calling `trash_groups`")


        resource_path = '/api/backend/v1/groups/trash'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'group_ids' in params:
            body_params = params['group_ids']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='list[BatchGroupUpdateResult]',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def unstar_project(self, project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.unstar_project(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :return: StarCount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unstar_project" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `unstar_project`")


        resource_path = '/api/backend/v1/projects/{projectId}/stars'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='StarCount',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_alias(self, alias_id, alias_to_update, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_alias(alias_id, alias_to_update, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str alias_id:  (required)
        :param AliasParams alias_to_update:  (required)
        :return: Alias
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['alias_id', 'alias_to_update']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_alias" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'alias_id' is set
        if ('alias_id' not in params) or (params['alias_id'] is None):
            raise ValueError("Missing the required parameter `alias_id` when calling `update_alias`")
        # verify the required parameter 'alias_to_update' is set
        if ('alias_to_update' not in params) or (params['alias_to_update'] is None):
            raise ValueError("Missing the required parameter `alias_to_update` when calling `update_alias`")


        resource_path = '/api/backend/v1/aliases/{aliasId}'.replace('{format}', 'json')
        path_params = {}
        if 'alias_id' in params:
            path_params['aliasId'] = params['alias_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'alias_to_update' in params:
            body_params = params['alias_to_update']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Alias',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_chart(self, chart_id, chart_set_id, chart_to_update, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_chart(chart_id, chart_set_id, chart_to_update, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str chart_id:  (required)
        :param str chart_set_id:  (required)
        :param ChartDefinition chart_to_update:  (required)
        :return: Chart
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['chart_id', 'chart_set_id', 'chart_to_update']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_chart" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'chart_id' is set
        if ('chart_id' not in params) or (params['chart_id'] is None):
            raise ValueError("Missing the required parameter `chart_id` when calling `update_chart`")
        # verify the required parameter 'chart_set_id' is set
        if ('chart_set_id' not in params) or (params['chart_set_id'] is None):
            raise ValueError("Missing the required parameter `chart_set_id` when calling `update_chart`")
        # verify the required parameter 'chart_to_update' is set
        if ('chart_to_update' not in params) or (params['chart_to_update'] is None):
            raise ValueError("Missing the required parameter `chart_to_update` when calling `update_chart`")


        resource_path = '/api/backend/v1/chartSets/{chartSetId}/charts/{chartId}'.replace('{format}', 'json')
        path_params = {}
        if 'chart_id' in params:
            path_params['chartId'] = params['chart_id']
        if 'chart_set_id' in params:
            path_params['chartSetId'] = params['chart_set_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'chart_to_update' in params:
            body_params = params['chart_to_update']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Chart',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_chart_set(self, chart_set_id, chart_set_to_update, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_chart_set(chart_set_id, chart_set_to_update, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str chart_set_id:  (required)
        :param ChartSetParams chart_set_to_update:  (required)
        :return: ChartSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['chart_set_id', 'chart_set_to_update']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_chart_set" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'chart_set_id' is set
        if ('chart_set_id' not in params) or (params['chart_set_id'] is None):
            raise ValueError("Missing the required parameter `chart_set_id` when calling `update_chart_set`")
        # verify the required parameter 'chart_set_to_update' is set
        if ('chart_set_to_update' not in params) or (params['chart_set_to_update'] is None):
            raise ValueError("Missing the required parameter `chart_set_to_update` when calling `update_chart_set`")


        resource_path = '/api/backend/v1/chartSets/{chartSetId}'.replace('{format}', 'json')
        path_params = {}
        if 'chart_set_id' in params:
            path_params['chartSetId'] = params['chart_set_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'chart_set_to_update' in params:
            body_params = params['chart_set_to_update']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ChartSet',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_experiment(self, experiment_id, edit_experiment_params, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_experiment(experiment_id, edit_experiment_params, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :param EditExperimentParams edit_experiment_params:  (required)
        :return: Experiment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id', 'edit_experiment_params']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_experiment" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `update_experiment`")
        # verify the required parameter 'edit_experiment_params' is set
        if ('edit_experiment_params' not in params) or (params['edit_experiment_params'] is None):
            raise ValueError("Missing the required parameter `edit_experiment_params` when calling `update_experiment`")


        resource_path = '/api/backend/v1/experiments/{experimentId}'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'edit_experiment_params' in params:
            body_params = params['edit_experiment_params']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Experiment',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_group(self, group_id, edit_group_params, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_group(group_id, edit_group_params, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str group_id:  (required)
        :param EditGroupParams edit_group_params:  (required)
        :return: Group
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'edit_group_params']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_group" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'group_id' is set
        if ('group_id' not in params) or (params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `update_group`")
        # verify the required parameter 'edit_group_params' is set
        if ('edit_group_params' not in params) or (params['edit_group_params'] is None):
            raise ValueError("Missing the required parameter `edit_group_params` when calling `update_group`")


        resource_path = '/api/backend/v1/groups/{groupId}'.replace('{format}', 'json')
        path_params = {}
        if 'group_id' in params:
            path_params['groupId'] = params['group_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'edit_group_params' in params:
            body_params = params['edit_group_params']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Group',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_last_viewed(self, project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_last_viewed(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_last_viewed" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `update_last_viewed`")


        resource_path = '/api/backend/v1/projects/{projectId}/updateLastViewed'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_named_filter(self, named_filter_id, named_filter_update, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_named_filter(named_filter_id, named_filter_update, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str named_filter_id:  (required)
        :param NamedFilterUpdate named_filter_update:  (required)
        :return: NamedFilter
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['named_filter_id', 'named_filter_update']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_named_filter" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'named_filter_id' is set
        if ('named_filter_id' not in params) or (params['named_filter_id'] is None):
            raise ValueError("Missing the required parameter `named_filter_id` when calling `update_named_filter`")
        # verify the required parameter 'named_filter_update' is set
        if ('named_filter_update' not in params) or (params['named_filter_update'] is None):
            raise ValueError("Missing the required parameter `named_filter_update` when calling `update_named_filter`")


        resource_path = '/api/backend/v1/namedFilters/{namedFilterId}'.replace('{format}', 'json')
        path_params = {}
        if 'named_filter_id' in params:
            path_params['namedFilterId'] = params['named_filter_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'named_filter_update' in params:
            body_params = params['named_filter_update']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='NamedFilter',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_organization(self, organization_id, organization_to_update, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_organization(organization_id, organization_to_update, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :param OrganizationUpdateParams organization_to_update:  (required)
        :return: Organization
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'organization_to_update']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_organization" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `update_organization`")
        # verify the required parameter 'organization_to_update' is set
        if ('organization_to_update' not in params) or (params['organization_to_update'] is None):
            raise ValueError("Missing the required parameter `organization_to_update` when calling `update_organization`")


        resource_path = '/api/backend/v1/organizations/{organizationId}'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_to_update' in params:
            body_params = params['organization_to_update']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Organization',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_organization_avatar(self, organization_id, avatar_file, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_organization_avatar(organization_id, avatar_file, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :param file avatar_file:  (required)
        :return: Link
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'avatar_file']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_organization_avatar" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `update_organization_avatar`")
        # verify the required parameter 'avatar_file' is set
        if ('avatar_file' not in params) or (params['avatar_file'] is None):
            raise ValueError("Missing the required parameter `avatar_file` when calling `update_organization_avatar`")


        resource_path = '/api/backend/v1/organizations/{organizationId}/avatar'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'avatar_file' in params:
            local_var_files['avatarFile'] = params['avatar_file']

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Link',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_organization_member(self, organization_name, user_id, member, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_organization_member(organization_name, user_id, member, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param str user_id:  (required)
        :param OrganizationMemberUpdate member:  (required)
        :return: OrganizationMember
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'user_id', 'member']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_organization_member" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `update_organization_member`")
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `update_organization_member`")
        # verify the required parameter 'member' is set
        if ('member' not in params) or (params['member'] is None):
            raise ValueError("Missing the required parameter `member` when calling `update_organization_member`")


        resource_path = '/api/backend/v1/organizations/{organizationName}/members/{userId}'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']
        if 'user_id' in params:
            path_params['userId'] = params['user_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'member' in params:
            body_params = params['member']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='OrganizationMember',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_pricing_plan(self, organization_id, pricing_plan_update, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_pricing_plan(organization_id, pricing_plan_update, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_id:  (required)
        :param PricingPlanUpdate pricing_plan_update:  (required)
        :return: PricingPlanUpdateResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'pricing_plan_update']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_pricing_plan" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `update_pricing_plan`")
        # verify the required parameter 'pricing_plan_update' is set
        if ('pricing_plan_update' not in params) or (params['pricing_plan_update'] is None):
            raise ValueError("Missing the required parameter `pricing_plan_update` when calling `update_pricing_plan`")


        resource_path = '/api/backend/v1/organizations/{organizationId}/pricingPlan'.replace('{format}', 'json')
        path_params = {}
        if 'organization_id' in params:
            path_params['organizationId'] = params['organization_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pricing_plan_update' in params:
            body_params = params['pricing_plan_update']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='PricingPlanUpdateResult',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_project(self, project_id, project_to_update, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_project(project_id, project_to_update, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :param ProjectEditParams project_to_update:  (required)
        :return: ProjectWithRole
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'project_to_update']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_project" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `update_project`")
        # verify the required parameter 'project_to_update' is set
        if ('project_to_update' not in params) or (params['project_to_update'] is None):
            raise ValueError("Missing the required parameter `project_to_update` when calling `update_project`")


        resource_path = '/api/backend/v1/projects/{projectId}'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_to_update' in params:
            body_params = params['project_to_update']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ProjectWithRole',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_project_avatar(self, project_id, project_id2, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_project_avatar(project_id, project_id2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :param file project_id2:  (required)
        :return: Link
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'project_id2']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_project_avatar" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `update_project_avatar`")
        # verify the required parameter 'project_id2' is set
        if ('project_id2' not in params) or (params['project_id2'] is None):
            raise ValueError("Missing the required parameter `project_id2` when calling `update_project_avatar`")


        resource_path = '/api/backend/v1/projects/{projectId}/avatar'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'project_id2' in params:
            local_var_files['projectId'] = params['project_id2']

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Link',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_project_background(self, project_id, background_file, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_project_background(project_id, background_file, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :param file background_file:  (required)
        :return: Link
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'background_file']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_project_background" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `update_project_background`")
        # verify the required parameter 'background_file' is set
        if ('background_file' not in params) or (params['background_file'] is None):
            raise ValueError("Missing the required parameter `background_file` when calling `update_project_background`")


        resource_path = '/api/backend/v1/projects/{projectId}/background'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'background_file' in params:
            local_var_files['backgroundFile'] = params['background_file']

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Link',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_project_bookmark(self, organization_name, project_name, bookmark_id, bookmark, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_project_bookmark(organization_name, project_name, bookmark_id, bookmark, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param str project_name:  (required)
        :param str bookmark_id:  (required)
        :param NewProjectBookmark bookmark:  (required)
        :return: ProjectBookmark
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'project_name', 'bookmark_id', 'bookmark']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_project_bookmark" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `update_project_bookmark`")
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params) or (params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `update_project_bookmark`")
        # verify the required parameter 'bookmark_id' is set
        if ('bookmark_id' not in params) or (params['bookmark_id'] is None):
            raise ValueError("Missing the required parameter `bookmark_id` when calling `update_project_bookmark`")
        # verify the required parameter 'bookmark' is set
        if ('bookmark' not in params) or (params['bookmark'] is None):
            raise ValueError("Missing the required parameter `bookmark` when calling `update_project_bookmark`")


        resource_path = '/api/backend/v1/organizations/{organizationName}/projects/{projectName}/bookmarks/{bookmarkId}'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']
        if 'project_name' in params:
            path_params['projectName'] = params['project_name']
        if 'bookmark_id' in params:
            path_params['bookmarkId'] = params['bookmark_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bookmark' in params:
            body_params = params['bookmark']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ProjectBookmark',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_project_member(self, project_id, user_id, member, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_project_member(project_id, user_id, member, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :param str user_id:  (required)
        :param ProjectMemberUpdate member:  (required)
        :return: ProjectMember
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'user_id', 'member']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_project_member" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `update_project_member`")
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `update_project_member`")
        # verify the required parameter 'member' is set
        if ('member' not in params) or (params['member'] is None):
            raise ValueError("Missing the required parameter `member` when calling `update_project_member`")


        resource_path = '/api/backend/v1/projects/{projectId}/members/{userId}'.replace('{format}', 'json')
        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']
        if 'user_id' in params:
            path_params['userId'] = params['user_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'member' in params:
            body_params = params['member']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='ProjectMember',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_project_page(self, organization_name, project_name, page_id, update, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_project_page(organization_name, project_name, page_id, update, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str organization_name:  (required)
        :param str project_name:  (required)
        :param str page_id:  (required)
        :param ProjectPageUpdateDTO update:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_name', 'project_name', 'page_id', 'update']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_project_page" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'organization_name' is set
        if ('organization_name' not in params) or (params['organization_name'] is None):
            raise ValueError("Missing the required parameter `organization_name` when calling `update_project_page`")
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params) or (params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `update_project_page`")
        # verify the required parameter 'page_id' is set
        if ('page_id' not in params) or (params['page_id'] is None):
            raise ValueError("Missing the required parameter `page_id` when calling `update_project_page`")
        # verify the required parameter 'update' is set
        if ('update' not in params) or (params['update'] is None):
            raise ValueError("Missing the required parameter `update` when calling `update_project_page`")


        resource_path = '/api/backend/v1/pages/organizations/{organizationName}/projects/{projectName}/{pageId}'.replace('{format}', 'json')
        path_params = {}
        if 'organization_name' in params:
            path_params['organizationName'] = params['organization_name']
        if 'project_name' in params:
            path_params['projectName'] = params['project_name']
        if 'page_id' in params:
            path_params['pageId'] = params['page_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update' in params:
            body_params = params['update']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_tags(self, update_tags_params, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_tags(update_tags_params, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UpdateTagsParams update_tags_params:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['update_tags_params']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_tags" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'update_tags_params' is set
        if ('update_tags_params' not in params) or (params['update_tags_params'] is None):
            raise ValueError("Missing the required parameter `update_tags_params` when calling `update_tags`")


        resource_path = '/api/backend/v1/tags'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_tags_params' in params:
            body_params = params['update_tags_params']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_user_profile(self, user_profile_update, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_user_profile(user_profile_update, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UserProfileUpdate user_profile_update:  (required)
        :return: UserProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_profile_update']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user_profile" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'user_profile_update' is set
        if ('user_profile_update' not in params) or (params['user_profile_update'] is None):
            raise ValueError("Missing the required parameter `user_profile_update` when calling `update_user_profile`")


        resource_path = '/api/backend/v1/userProfile'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user_profile_update' in params:
            body_params = params['user_profile_update']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UserProfile',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def update_user_profile_avatar(self, avatar_file, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_user_profile_avatar(avatar_file, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param file avatar_file:  (required)
        :return: Link
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['avatar_file']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user_profile_avatar" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'avatar_file' is set
        if ('avatar_file' not in params) or (params['avatar_file'] is None):
            raise ValueError("Missing the required parameter `avatar_file` when calling `update_user_profile_avatar`")


        resource_path = '/api/backend/v1/userProfile/avatar'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'avatar_file' in params:
            local_var_files['avatarFile'] = params['avatar_file']

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Link',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def upload_cli(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_cli(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_cli" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/cli'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def upload_data(self, project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_data(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :param str upload_id: 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'upload_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_data" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `upload_data`")


        resource_path = '/api/backend/v1/data/upload'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'project_id' in params:
            query_params['projectId'] = params['project_id']
        if 'upload_id' in params:
            query_params['uploadId'] = params['upload_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def upload_data_as_tarstream(self, project_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_data_as_tarstream(project_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_data_as_tarstream" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `upload_data_as_tarstream`")


        resource_path = '/api/backend/v1/data/uploadTarstream'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'project_id' in params:
            query_params['projectId'] = params['project_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def upload_experiment_backups(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_experiment_backups(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_experiment_backups" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `upload_experiment_backups`")


        resource_path = '/api/backend/v1/data/backups/{experimentId}'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def upload_experiment_output(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_experiment_output(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_experiment_output" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `upload_experiment_output`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/output'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def upload_experiment_output_as_tarstream(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_experiment_output_as_tarstream(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_experiment_output_as_tarstream" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `upload_experiment_output_as_tarstream`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/uploadTarstream'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def upload_experiment_source(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_experiment_source(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_experiment_source" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `upload_experiment_source`")


        resource_path = '/api/backend/v1/data/source/{experimentId}'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def upload_experiment_source_as_tarstream(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_experiment_source_as_tarstream(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_experiment_source_as_tarstream" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `upload_experiment_source_as_tarstream`")


        resource_path = '/api/backend/v1/data/uploadSourceTarstream/{experimentId}'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def upload_experiment_stderr(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_experiment_stderr(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_experiment_stderr" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `upload_experiment_stderr`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/stderr'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def upload_experiment_stdout(self, experiment_id, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_experiment_stdout(experiment_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str experiment_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experiment_id']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_experiment_stdout" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in params) or (params['experiment_id'] is None):
            raise ValueError("Missing the required parameter `experiment_id` when calling `upload_experiment_stdout`")


        resource_path = '/api/backend/v1/experiments/{experimentId}/stdout'.replace('{format}', 'json')
        path_params = {}
        if 'experiment_id' in params:
            path_params['experimentId'] = params['experiment_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type=None,
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def verify_upload_data(self, project_id, path, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.verify_upload_data(project_id, path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str project_id:  (required)
        :param str path:  (required)
        :return: UploadVerification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'path']
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_upload_data" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']

        # verify the required parameter 'project_id' is set
        if ('project_id' not in params) or (params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `verify_upload_data`")
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `verify_upload_data`")


        resource_path = '/api/backend/v1/data/verifyUpload'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'project_id' in params:
            query_params['projectId'] = params['project_id']
        if 'path' in params:
            query_params['path'] = params['path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UploadVerification',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def version(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.version(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: Version
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method version" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/api/backend/version'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Version',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response

    def version_get(self, **kwargs):
        """
        
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.version_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: Version
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params += ['callback', 'binary_data', 'binary_filename', 'binary_range', 'binary_permissions', 'headers_handler']

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method version_get" % key
                )
            if val is not None:
                params[key] = val
        del params['kwargs']



        resource_path = '/version'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept([])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type([])

        if 'binary_data' in kwargs:
            header_params['Content-Type'] = 'application/octet-stream'
            if 'binary_filename' in kwargs:
                header_params['Content-Filename'] = kwargs['binary_filename']
            if 'binary_range' in kwargs:
                header_params['Range'] = kwargs['binary_range']
            if 'binary_permissions' in kwargs:
                header_params['X-File-Permissions'] = kwargs['binary_permissions']
            form_params = kwargs['binary_data']

        # Authentication setting
        auth_settings = ['oauth2']

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Version',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            headers_handler=params.get('headers_handler'))
        return response
