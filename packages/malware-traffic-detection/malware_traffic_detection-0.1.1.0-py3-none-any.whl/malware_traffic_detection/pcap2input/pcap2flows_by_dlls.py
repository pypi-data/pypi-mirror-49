"""
    Recommend Splitcap.exe to extract flows from .pcap (only can be use in windows).
    In order to achieve the same function, we can use python call the corresponding DLLs (wireshare), and reimplement the functions we need.

    Scapy needs too much time to do the same thing.

"""
from ctypes import *

from collections import OrderedDict

# from libpcap import pcap, ct, PCAP_ERRBUF_SIZE, open_offline, pcap_t, fopen_offline, pcap_next, pkthdr
from scapy.all import PcapReader, wrpcap
import os

PT_NUM = 10000  # print interval


# please do not remove.
# def parse_pcap_by_libpcap_python_interface(in_file):
#     ebuf = ct.create_string_buffer(PCAP_ERRBUF_SIZE)
#     # ebuf.value = b""
#     # a=c_void_p(in_file)
#     pd = open_offline(in_file, ebuf)
#
#     pkthdr_= pkthdr()
#     packet=pcap_next(pd,pkthdr_)
#
#     not finished yet.
#     TODO
#     print(packet)


def parse_pcap_by_libpcap(in_file):
    """
        https://www.tcpdump.org/pcap.html
        https://www.rhyous.com/2011/11/13/how-to-read-a-pcap-file-from-wireshark-with-c/
        http://tonylukasavage.com/blog/2010/12/19/offline-packet-capture-analysis-with-c-c----amp--libpcap/

    :param in_file:
    :return:
    """

    # give location of dll
    lib_pcap = cdll.LoadLibrary('/usr/lib/libpcap.dylib')

    # open capture file for offline processing
    errbuf = create_string_buffer(256)
    handle = lib_pcap.pcap_open_offline(in_file, errbuf)
    print(handle)
    if handle == None:
        print("pcap_open_live() failed.")

    # lib_pcap.pcap_loop(descr,0,,None)

    ## struct   pcap_pkthdr
    ##  Header of a packet in the dump file.
    class timeval(Structure):
        pass

    timeval._fields_ = [('tv_sec', c_long),
                        ('tv_usec', c_long)]
    bpf_u_int32 = c_int

    class pcap_pkthdr(Structure):
        _fields_ = [('ts', timeval),
                    ('caplen', bpf_u_int32),
                    ('len', bpf_u_int32)]

    pkthdr_ = pcap_pkthdr()
    packet = lib_pcap.pcap_next(handle, pkthdr_)
    # print(f'packet:{packet}')

    # lib_pcap.pcap_close(handle)

    ###  not finished yet.
    # TODO

    return -1


def extract_meta_info_from_packet(pkt, idx=0):
    five_tuple_lst = []
    time = ''
    while pkt.name.upper() != "RAW":
        key = pkt.name.upper()
        if key == "NOPAYLOAD" or key == "PADDING":
            break

        # print(key)
        if key == "ETHERNET":  # Ethernet
            time = pkt.time  # Ethernet time
            pkt = pkt.payload
            #  print('other protrocols, please analyze them manually.')
            continue
        if key == "IP":
            five_tuple_lst = [pkt.src, pkt.dst]
        elif key == "TCP" or key == "UDP":
            five_tuple_lst.extend([str(pkt.sport), str(pkt.dport), key])
            payload = pkt.payload.original  # only bytes

            return five_tuple_lst, payload
        else:
            payload = b''
            print(
                f'idx={idx}, other protrocols={key}, {five_tuple_lst}, {time}, paylaod={payload}, please analyze them manually.')
            break
        pkt = pkt.payload

    return five_tuple_lst, payload


def extract_flows_from_pcap(in_file='.pcap', biflow=True, pkts_num_in_flow=-1, storage_mode="RAW"):
    """

    :param in_file:
    :param biflow: Ture, represents store sessions.
    :param pkts_num_in_flow: -1 (negative) means save all packets of each flow. Otherwise, only extract the first num (such as 300) packets of each flow.
    :return:
    """
    sess_order_dict = OrderedDict()
    pcap_stats = {'pkts_n': 0, 'sessions_n': 0, 'tcp_n': 0, 'udp_n': 0, 'others_n': 0}

    pcap_reader = PcapReader(in_file)
    pkt = pcap_reader.read_packet()
    while pkt:
        pcap_stats['pkts_n'] += 1
        if storage_mode.upper() == "L7":
            five_tuple_lst, payload = extract_meta_info_from_packet(pkt, idx=pcap_stats['pkts_n'])
        else:  # storage_mode.upper() == "RAW":  # save as .pcap, default
            five_tuple_lst, payload = extract_meta_info_from_packet(pkt, idx=pcap_stats['pkts_n'])
            payload = pkt  # save all information of each packet.

        if "TCP" in five_tuple_lst:
            pcap_stats['tcp_n'] += 1
        elif "UDP" in five_tuple_lst:
            pcap_stats['udp_n'] += 1
        else:  # # does not have five_tuple, such ARP protocol.
            pcap_stats['others_n'] += 1
            pkt = pcap_reader.read_packet()
            continue

        five_tuple_1 = five_tuple_lst[0] + ":" + five_tuple_lst[2] + "-" + five_tuple_lst[1] + ":" + five_tuple_lst[
            3] + "-" + five_tuple_lst[-1]
        if biflow:  # session
            five_tuple_2 = five_tuple_lst[1] + ":" + five_tuple_lst[3] + "-" + five_tuple_lst[0] + ":" + five_tuple_lst[
                2] + "-" + five_tuple_lst[-1]
        else:
            five_tuple_2 = five_tuple_1  # uniflow

        if pcap_stats['pkts_n'] % PT_NUM == 0:
            n_tmp = pcap_stats['pkts_n']
            print(
                f'pcap_stats[\'pkts_n\']={n_tmp}, biflow={biflow}, five_tuple_1={five_tuple_1}, five_tuple_2={five_tuple_2}')

        if five_tuple_1 not in sess_order_dict.keys() and five_tuple_2 not in sess_order_dict.keys():
            sess_order_dict[five_tuple_1] = [payload]
        else:
            if five_tuple_1 not in sess_order_dict.keys():
                five_tuple_1 = five_tuple_2  # only save five_tuple_1, if biflow = True.
            if pkts_num_in_flow < 0:
                # print(f'{five_tuple_1}')
                sess_order_dict[five_tuple_1].append(payload)
            else:
                if len(sess_order_dict[
                           five_tuple_1]) > pkts_num_in_flow:  # only store the first num (such as 300) packets
                    sess_order_dict[five_tuple_1].append(payload)

        pkt = pcap_reader.read_packet()

    pcap_stats['sessions_n'] = len(sess_order_dict)
    print(f'pcap_stats:{pcap_stats}')

    return sess_order_dict, pcap_stats


def write_sessions_to_files(sess_order_dict, out_dir, storage_mode="RAW"):
    if not os.path.exists(out_dir):
        os.makedirs(out_dir)

    def write_session_to_file(out_file, value, storage_mode):
        if storage_mode == "L7":
            with open(out_file, 'wb') as out_hdr:
                str = b''
                for v in value:  #
                    str += v
                out_hdr.write(str)
        else:  # default
            str = b''
            for v in value:  #
                str += v.original  #
            wrpcap(out_file, value)  # be careful for "wrpcap", which cannot save original bytes directly.

        return len(str)

    for idx, (key, value) in enumerate(sess_order_dict.items()):
        if storage_mode.upper() == "L7":
            out_file = os.path.join(out_dir, key + '.bin')
        else:  # default
            out_file = os.path.join(out_dir, key + '.pcap')
        data_len = write_session_to_file(out_file, value, storage_mode)
        if (idx) % PT_NUM == 0:
            print(f'idx={idx}, out_file={out_file}, bytes_len={data_len}')


def main():
    in_file = '../data/Skype.pcap'
    # in_file = '../data/Monday-WorkingHours_output_00001_20170703081536.pcap'
    # parse_pcap_by_libpcap_python_interface(in_file)
    parse_pcap_by_libpcap(in_file)
    # storage_mode = "L7"
    # sess_order_dict, pcap_stats = extract_flows_from_pcap(in_file, biflow=True, pkts_num_in_flow=2, storage_mode=storage_mode)
    #
    # # out_dir = os.path.join(os.path.dirname(in_file), os.path.splitext(in_file))
    # out_dir = os.path.splitext(in_file)[0]
    # write_sessions_to_files(sess_order_dict, out_dir, storage_mode=storage_mode)


if __name__ == '__main__':
    main()
