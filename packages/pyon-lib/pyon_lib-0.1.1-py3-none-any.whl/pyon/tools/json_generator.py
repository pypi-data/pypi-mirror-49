from pyon.tools import path_parser


def generate_json(object_path_list, allow_overwrite=False):
    """
    Generates an object out of the object_path_list by using their paths
    Example:    [({"title":"Object 1"},"/123/"),({"title":"Object 2"},"/123/456/)]
                -> {123:{"title":"Object 1",456:{"title":"Object 2"}}}
    :param object_path_list: List consisting out of Python Dicts and Path Strings
    :param allow_overwrite: Whether objects that are written later can overwrite those that were written earlier
    :return: The finished object
    """

    base_json = []

    object_at_root_level = None
    list_was_created = False

    object_segments_list = []

    for obj, path in object_path_list:
        path_segments = path_parser.parse(path)
        current_segment = path_segments[0] if len(path_segments) >= 1 else None

        if not(current_segment == "*" or isinstance(current_segment, int)):
            base_json = {}

        if current_segment == "*":
            list_was_created = True

        elif current_segment is None:
            if object_at_root_level is None or allow_overwrite:
                object_at_root_level = obj

        else:
            object_segments_list.append((obj, path_segments))

    if not list_was_created and base_json == []:
        base_json = {}

    if object_at_root_level is not None:
        base_json = object_at_root_level

    for obj, path_segments in object_segments_list:
        recursive_generator(base_json, path_segments, obj, allow_overwrite=allow_overwrite)

    return base_json


def recursive_generator(json, path_segments, obj, allow_overwrite=False):
    """
    Recursively generate the json structure specified be the path and inserts the object
    :param json: The current json structure to be edited
    :param path_segments: The Segments of the Path generated by the path_parser.parse method
    :param obj: The object that should be inserted at the end
    :param allow_overwrite: Whether objects that are written later can overwrite those that were written earlier
    """

    current_segment = path_segments[0] if len(path_segments) >= 1 else None
    next_segment = path_segments[1] if len(path_segments) >= 2 else None

    if current_segment != "*" and next_segment == "*":
        if isinstance(json, dict):
            if current_segment in json.keys():
                pass
            else:
                json[current_segment] = []
        else:
            raise TypeError("Expected type '{}', got type '{}'".format("dict", type(json).__name__))
    elif current_segment != "*" and next_segment != "*":
        if isinstance(json, dict):
            if current_segment in json.keys():
                if next_segment is None:
                    if allow_overwrite:
                        json[current_segment] = obj
            else:
                if next_segment is None:
                    json[current_segment] = obj
                else:
                    json[current_segment] = {}
        elif isinstance(json, list):
            if isinstance(current_segment, int):
                if len(json) > current_segment >= 0:
                    if next_segment is None:
                        if allow_overwrite:
                            json[current_segment] = obj

        else:
            raise TypeError("Expected type '{}' or '{}', got type '{}'".format("list", "dict", type(json).__name__))
    elif current_segment == "*" and next_segment != "*":
        if isinstance(json, list):
            if next_segment is None:
                json.append(obj)

        else:
            raise TypeError("Expected type '{}', got type '{}'".format("list", type(json).__name__))
    else:
        raise TypeError("Multidimensional lists are not supported")

    next_json = json[current_segment] if current_segment != "*" else json[-1]

    if len(path_segments) > 1:
        recursive_generator(next_json, path_segments[1:], obj, allow_overwrite=allow_overwrite)
