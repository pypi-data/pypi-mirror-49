import json
import time
import csv

class Table:

	name     = ''
	desc     = ''
	colnames = []
	rows     = []
	stats    = {}
	
	def __init__(self, name, desc=''):
		self.name     = name
		self.desc     = desc
		self.colnames = []
		self.rows     = []
		self.stats    = {}

		self.stats ['column-count'] = 0
		self.stats ['row-count'] = 0
		self.stats ['table-load-time-ms'] = 0
		
	def add_column_with_name (self, colname):
		if colname in self.colnames:
			raise Exception ('Column [' + colname + '] already exists or was autogenerated')
		self.colnames.append (colname)
		self.stats ['column-count'] += 1
	
	def add_column (self, colname=''):
		if colname=='':
			num_existing_columns = len(self.colnames)
			colname = 'Column_' + str(num_existing_columns + 1)
		self.add_column_with_name (colname)
	
	def add_row (self, values=[]):
		while len(self.colnames) < len(values):
			self.add_column ()
		self.rows.append (values)
		self.stats ['row-count'] += 1

	def load_from_delimited_file (self, fname, d=',', includesHeader=True):
		startms = int(round(time.time() * 1000))
		with open (fname, 'r') as csvfile:
			csvreader = csv.reader (csvfile, delimiter=d)
			if includesHeader:
				for cn in next (csvreader):
					self.add_column (cn)
			for row in csvreader:
				self.add_row (row)
		endms = int(round(time.time() * 1000))
		self.stats ['table-load-time-ms'] += (endms - startms)

	def toJSON (self):
		return json.dumps (self, default=lambda o: o.__dict__, sort_keys=True, indent=4)

	def __str__ (self):
		return self.toJSON ()

	def get_column_index (self, colname=''):
		col_index = 0
		for c in self.colnames:
			if c == colname:
				return col_index
			col_index += 1
		return -1

	def get_grouping_method_and_column (self, s_inp):
		# Example input = '  MAX ( Column 4  ) '
		s = s_inp.replace (')', '(')
		sparts = s.split ('(')
		if (len(sparts) != 3):
			raise Exception ('Found unexpected tokens in grouped column [' + s_inp + ']' + str(len(sparts)))
		return sparts[0].strip(), sparts[1].strip()

	def do_operation (self, op, vector):
		startms = int(round(time.time() * 1000))
		rval = None
		if (len(vector) == 0):
			return None
		elif (op.lower() == 'count'):
			rval = len(vector)
		elif (op.lower() == 'min'):
			rval = vector[0]
			for v in vector:
				if v is None:
					return v
				if v < rval:
					rval = v
		elif (op.lower() == 'max'):
			rval = vector[0]
			for v in vector:
				if v is not None and v > rval:
					rval = v
		elif (op.lower() == 'sum'):
			rval = 0
			for v in vector:
				if v is not None:
					rval += v
		else:
			raise Exception ('Unknown grouping function [' + op + ']')
		endms = int(round(time.time() * 1000))
		stacode = 'table-op-' + op.lower () + '-time-ms'
		if not stacode in self.stats.keys ():
			self.stats [stacode] = 0
		self.stats [stacode] += (endms - startms)
		return rval
			
	
	def group_by (self, group_by, select_columns):

		exception_rows = []
		result_key     = {}
		result_val     = {}
		group_by_cols  = []
		select_cols    = []

		for c in group_by.split (','):
			group_by_cols.append (c.strip())
		for c in group_by_cols:
			if c not in self.colnames:
				raise Exception ('Group by column [' + c + '] not found')

		for c in select_columns.split (','):
			select_cols.append (c.strip())
		for s in select_cols:
			m,c = self.get_grouping_method_and_column (s)
			if c not in self.colnames:
				raise Exception ('Select column [' + c + '] not found')
			if c in group_by_cols:
				raise Exception ('Column [' + c + '] part of Select as well as Group By column list. It can be in either but not both.')

		for r in self.rows:
			keys = []
			key = ''
			for g in group_by_cols:
				gindex = self.get_column_index (g)
				val_at_gindex = None
				if gindex < len(r):
					val_at_gindex = r[gindex]
				keys.append (val_at_gindex)
				key += str(val_at_gindex).strip()
			if key in result_val.keys():
				val = result_val.get (key)
			else:
				val = []
				for s in select_cols:
					newarr = []
					val.append (newarr)

			sindex = 0
			for s in select_cols:
				m,c = self.get_grouping_method_and_column (s)
				gindex = self.get_column_index (c)
				val[sindex].append (r[gindex])
				sindex += 1
				
			result_key [key] = keys
			result_val [key] = val

		for key in result_val.keys():
			vectors = result_val.get (key)
			vectorindex = 0
			for s in select_cols:
				m,c = self.get_grouping_method_and_column (s)
				op_result = self.do_operation (m, vectors[vectorindex])
				vectors[vectorindex] = op_result
				vectorindex += 1
				
		return result_key, result_val, exception_rows
