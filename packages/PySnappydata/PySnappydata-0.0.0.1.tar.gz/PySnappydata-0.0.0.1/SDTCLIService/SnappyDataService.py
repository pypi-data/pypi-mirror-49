#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def getPreferredServer(self, serverTypes, serverGroups, failedServers):
        """
        Parameters:
         - serverTypes
         - serverGroups
         - failedServers
        """
        pass

    def getAllServersWithPreferredServer(self, serverTypes, serverGroups, failedServers):
        """
        Parameters:
         - serverTypes
         - serverGroups
         - failedServers
        """
        pass

    def openConnection(self, arguments):
        """
        Parameters:
         - arguments
        """
        pass

    def execute(self, connId, sql, outputParams, attrs, token):
        """
        Parameters:
         - connId
         - sql
         - outputParams
         - attrs
         - token
        """
        pass

    def executeUpdate(self, connId, sqls, attrs, token):
        """
        Parameters:
         - connId
         - sqls
         - attrs
         - token
        """
        pass

    def executeQuery(self, connId, sql, attrs, token):
        """
        Parameters:
         - connId
         - sql
         - attrs
         - token
        """
        pass

    def prepareStatement(self, connId, sql, outputParams, attrs, token):
        """
        Parameters:
         - connId
         - sql
         - outputParams
         - attrs
         - token
        """
        pass

    def executePrepared(self, stmtId, params, outputParams, attrs, token):
        """
        Parameters:
         - stmtId
         - params
         - outputParams
         - attrs
         - token
        """
        pass

    def executePreparedUpdate(self, stmtId, params, attrs, token):
        """
        Parameters:
         - stmtId
         - params
         - attrs
         - token
        """
        pass

    def executePreparedQuery(self, stmtId, params, attrs, token):
        """
        Parameters:
         - stmtId
         - params
         - attrs
         - token
        """
        pass

    def executePreparedBatch(self, stmtId, paramsBatch, attrs, token):
        """
        Parameters:
         - stmtId
         - paramsBatch
         - attrs
         - token
        """
        pass

    def prepareAndExecute(self, connId, sql, paramsBatch, outputParams, attrs, token):
        """
        Parameters:
         - connId
         - sql
         - paramsBatch
         - outputParams
         - attrs
         - token
        """
        pass

    def beginTransaction(self, connId, isolationLevel, flags, token):
        """
        Parameters:
         - connId
         - isolationLevel
         - flags
         - token
        """
        pass

    def setTransactionAttributes(self, connId, flags, token):
        """
        Parameters:
         - connId
         - flags
         - token
        """
        pass

    def getTransactionAttributes(self, connId, token):
        """
        Parameters:
         - connId
         - token
        """
        pass

    def commitTransaction(self, connId, startNewTransaction, flags, token):
        """
        Parameters:
         - connId
         - startNewTransaction
         - flags
         - token
        """
        pass

    def rollbackTransaction(self, connId, startNewTransaction, flags, token):
        """
        Parameters:
         - connId
         - startNewTransaction
         - flags
         - token
        """
        pass

    def getNextResultSet(self, cursorId, otherResultSetBehaviour, token):
        """
        Parameters:
         - cursorId
         - otherResultSetBehaviour
         - token
        """
        pass

    def getBlobChunk(self, connId, lobId, offset, size, freeLobAtEnd, token):
        """
        Parameters:
         - connId
         - lobId
         - offset
         - size
         - freeLobAtEnd
         - token
        """
        pass

    def getClobChunk(self, connId, lobId, offset, size, freeLobAtEnd, token):
        """
        Parameters:
         - connId
         - lobId
         - offset
         - size
         - freeLobAtEnd
         - token
        """
        pass

    def sendBlobChunk(self, chunk, connId, token):
        """
        Parameters:
         - chunk
         - connId
         - token
        """
        pass

    def sendClobChunk(self, chunk, connId, token):
        """
        Parameters:
         - chunk
         - connId
         - token
        """
        pass

    def freeLob(self, connId, lobId, token):
        """
        Parameters:
         - connId
         - lobId
         - token
        """
        pass

    def scrollCursor(self, cursorId, offset, offsetIsAbsolute, fetchReverse, fetchSize, token):
        """
        Parameters:
         - cursorId
         - offset
         - offsetIsAbsolute
         - fetchReverse
         - fetchSize
         - token
        """
        pass

    def executeCursorUpdate(self, cursorId, operations, changedRows, changedColumnsList, changedRowIndexes, token):
        """
        Parameters:
         - cursorId
         - operations
         - changedRows
         - changedColumnsList
         - changedRowIndexes
         - token
        """
        pass

    def startXATransaction(self, connId, xid, timeoutInSeconds, flags, token):
        """
        Parameters:
         - connId
         - xid
         - timeoutInSeconds
         - flags
         - token
        """
        pass

    def prepareXATransaction(self, connId, xid, token):
        """
        Parameters:
         - connId
         - xid
         - token
        """
        pass

    def commitXATransaction(self, connId, xid, onePhase, token):
        """
        Parameters:
         - connId
         - xid
         - onePhase
         - token
        """
        pass

    def rollbackXATransaction(self, connId, xid, token):
        """
        Parameters:
         - connId
         - xid
         - token
        """
        pass

    def forgetXATransaction(self, connId, xid, token):
        """
        Parameters:
         - connId
         - xid
         - token
        """
        pass

    def endXATransaction(self, connId, xid, flags, token):
        """
        Parameters:
         - connId
         - xid
         - flags
         - token
        """
        pass

    def recoverXATransaction(self, connId, flag, token):
        """
        Parameters:
         - connId
         - flag
         - token
        """
        pass

    def getServiceMetaData(self, connId, token):
        """
        Parameters:
         - connId
         - token
        """
        pass

    def getSchemaMetaData(self, schemaCall, metadataArgs):
        """
        Parameters:
         - schemaCall
         - metadataArgs
        """
        pass

    def getIndexInfo(self, metadataArgs, unique, approximate):
        """
        Parameters:
         - metadataArgs
         - unique
         - approximate
        """
        pass

    def getUDTs(self, metadataArgs, types):
        """
        Parameters:
         - metadataArgs
         - types
        """
        pass

    def getBestRowIdentifier(self, metadataArgs, scope, nullable):
        """
        Parameters:
         - metadataArgs
         - scope
         - nullable
        """
        pass

    def fetchActiveConnections(self, connId, token):
        """
        Parameters:
         - connId
         - token
        """
        pass

    def fetchActiveStatements(self, connId, token):
        """
        Parameters:
         - connId
         - token
        """
        pass

    def cancelStatement(self, stmtId, token):
        """
        Parameters:
         - stmtId
         - token
        """
        pass

    def cancelCurrentStatement(self, connId, token):
        """
        Parameters:
         - connId
         - token
        """
        pass

    def closeResultSet(self, cursorId, token):
        """
        Parameters:
         - cursorId
         - token
        """
        pass

    def closeStatement(self, stmtId, token):
        """
        Parameters:
         - stmtId
         - token
        """
        pass

    def closeConnection(self, connId, closeSocket, token):
        """
        Parameters:
         - connId
         - closeSocket
         - token
        """
        pass

    def bulkClose(self, entities):
        """
        Parameters:
         - entities
        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def getPreferredServer(self, serverTypes, serverGroups, failedServers):
        """
        Parameters:
         - serverTypes
         - serverGroups
         - failedServers
        """
        self.send_getPreferredServer(serverTypes, serverGroups, failedServers)
        return self.recv_getPreferredServer()

    def send_getPreferredServer(self, serverTypes, serverGroups, failedServers):
        self._oprot.writeMessageBegin('getPreferredServer', TMessageType.CALL, self._seqid)
        args = getPreferredServer_args()
        args.serverTypes = serverTypes
        args.serverGroups = serverGroups
        args.failedServers = failedServers
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getPreferredServer(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getPreferredServer_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getPreferredServer failed: unknown result")

    def getAllServersWithPreferredServer(self, serverTypes, serverGroups, failedServers):
        """
        Parameters:
         - serverTypes
         - serverGroups
         - failedServers
        """
        self.send_getAllServersWithPreferredServer(serverTypes, serverGroups, failedServers)
        return self.recv_getAllServersWithPreferredServer()

    def send_getAllServersWithPreferredServer(self, serverTypes, serverGroups, failedServers):
        self._oprot.writeMessageBegin('getAllServersWithPreferredServer', TMessageType.CALL, self._seqid)
        args = getAllServersWithPreferredServer_args()
        args.serverTypes = serverTypes
        args.serverGroups = serverGroups
        args.failedServers = failedServers
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAllServersWithPreferredServer(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAllServersWithPreferredServer_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllServersWithPreferredServer failed: unknown result")

    def openConnection(self, arguments):
        """
        Parameters:
         - arguments
        """
        self.send_openConnection(arguments)
        return self.recv_openConnection()

    def send_openConnection(self, arguments):
        self._oprot.writeMessageBegin('openConnection', TMessageType.CALL, self._seqid)
        args = openConnection_args()
        args.arguments = arguments
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_openConnection(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = openConnection_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "openConnection failed: unknown result")

    def execute(self, connId, sql, outputParams, attrs, token):
        """
        Parameters:
         - connId
         - sql
         - outputParams
         - attrs
         - token
        """
        self.send_execute(connId, sql, outputParams, attrs, token)
        return self.recv_execute()

    def send_execute(self, connId, sql, outputParams, attrs, token):
        self._oprot.writeMessageBegin('execute', TMessageType.CALL, self._seqid)
        args = execute_args()
        args.connId = connId
        args.sql = sql
        args.outputParams = outputParams
        args.attrs = attrs
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_execute(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = execute_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "execute failed: unknown result")

    def executeUpdate(self, connId, sqls, attrs, token):
        """
        Parameters:
         - connId
         - sqls
         - attrs
         - token
        """
        self.send_executeUpdate(connId, sqls, attrs, token)
        return self.recv_executeUpdate()

    def send_executeUpdate(self, connId, sqls, attrs, token):
        self._oprot.writeMessageBegin('executeUpdate', TMessageType.CALL, self._seqid)
        args = executeUpdate_args()
        args.connId = connId
        args.sqls = sqls
        args.attrs = attrs
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executeUpdate(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executeUpdate_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "executeUpdate failed: unknown result")

    def executeQuery(self, connId, sql, attrs, token):
        """
        Parameters:
         - connId
         - sql
         - attrs
         - token
        """
        self.send_executeQuery(connId, sql, attrs, token)
        return self.recv_executeQuery()

    def send_executeQuery(self, connId, sql, attrs, token):
        self._oprot.writeMessageBegin('executeQuery', TMessageType.CALL, self._seqid)
        args = executeQuery_args()
        args.connId = connId
        args.sql = sql
        args.attrs = attrs
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executeQuery(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executeQuery_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "executeQuery failed: unknown result")

    def prepareStatement(self, connId, sql, outputParams, attrs, token):
        """
        Parameters:
         - connId
         - sql
         - outputParams
         - attrs
         - token
        """
        self.send_prepareStatement(connId, sql, outputParams, attrs, token)
        return self.recv_prepareStatement()

    def send_prepareStatement(self, connId, sql, outputParams, attrs, token):
        self._oprot.writeMessageBegin('prepareStatement', TMessageType.CALL, self._seqid)
        args = prepareStatement_args()
        args.connId = connId
        args.sql = sql
        args.outputParams = outputParams
        args.attrs = attrs
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_prepareStatement(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = prepareStatement_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "prepareStatement failed: unknown result")

    def executePrepared(self, stmtId, params, outputParams, attrs, token):
        """
        Parameters:
         - stmtId
         - params
         - outputParams
         - attrs
         - token
        """
        self.send_executePrepared(stmtId, params, outputParams, attrs, token)
        return self.recv_executePrepared()

    def send_executePrepared(self, stmtId, params, outputParams, attrs, token):
        self._oprot.writeMessageBegin('executePrepared', TMessageType.CALL, self._seqid)
        args = executePrepared_args()
        args.stmtId = stmtId
        args.params = params
        args.outputParams = outputParams
        args.attrs = attrs
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executePrepared(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executePrepared_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "executePrepared failed: unknown result")

    def executePreparedUpdate(self, stmtId, params, attrs, token):
        """
        Parameters:
         - stmtId
         - params
         - attrs
         - token
        """
        self.send_executePreparedUpdate(stmtId, params, attrs, token)
        return self.recv_executePreparedUpdate()

    def send_executePreparedUpdate(self, stmtId, params, attrs, token):
        self._oprot.writeMessageBegin('executePreparedUpdate', TMessageType.CALL, self._seqid)
        args = executePreparedUpdate_args()
        args.stmtId = stmtId
        args.params = params
        args.attrs = attrs
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executePreparedUpdate(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executePreparedUpdate_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "executePreparedUpdate failed: unknown result")

    def executePreparedQuery(self, stmtId, params, attrs, token):
        """
        Parameters:
         - stmtId
         - params
         - attrs
         - token
        """
        self.send_executePreparedQuery(stmtId, params, attrs, token)
        return self.recv_executePreparedQuery()

    def send_executePreparedQuery(self, stmtId, params, attrs, token):
        self._oprot.writeMessageBegin('executePreparedQuery', TMessageType.CALL, self._seqid)
        args = executePreparedQuery_args()
        args.stmtId = stmtId
        args.params = params
        args.attrs = attrs
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executePreparedQuery(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executePreparedQuery_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "executePreparedQuery failed: unknown result")

    def executePreparedBatch(self, stmtId, paramsBatch, attrs, token):
        """
        Parameters:
         - stmtId
         - paramsBatch
         - attrs
         - token
        """
        self.send_executePreparedBatch(stmtId, paramsBatch, attrs, token)
        return self.recv_executePreparedBatch()

    def send_executePreparedBatch(self, stmtId, paramsBatch, attrs, token):
        self._oprot.writeMessageBegin('executePreparedBatch', TMessageType.CALL, self._seqid)
        args = executePreparedBatch_args()
        args.stmtId = stmtId
        args.paramsBatch = paramsBatch
        args.attrs = attrs
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executePreparedBatch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executePreparedBatch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "executePreparedBatch failed: unknown result")

    def prepareAndExecute(self, connId, sql, paramsBatch, outputParams, attrs, token):
        """
        Parameters:
         - connId
         - sql
         - paramsBatch
         - outputParams
         - attrs
         - token
        """
        self.send_prepareAndExecute(connId, sql, paramsBatch, outputParams, attrs, token)
        return self.recv_prepareAndExecute()

    def send_prepareAndExecute(self, connId, sql, paramsBatch, outputParams, attrs, token):
        self._oprot.writeMessageBegin('prepareAndExecute', TMessageType.CALL, self._seqid)
        args = prepareAndExecute_args()
        args.connId = connId
        args.sql = sql
        args.paramsBatch = paramsBatch
        args.outputParams = outputParams
        args.attrs = attrs
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_prepareAndExecute(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = prepareAndExecute_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "prepareAndExecute failed: unknown result")

    def beginTransaction(self, connId, isolationLevel, flags, token):
        """
        Parameters:
         - connId
         - isolationLevel
         - flags
         - token
        """
        self.send_beginTransaction(connId, isolationLevel, flags, token)
        return self.recv_beginTransaction()

    def send_beginTransaction(self, connId, isolationLevel, flags, token):
        self._oprot.writeMessageBegin('beginTransaction', TMessageType.CALL, self._seqid)
        args = beginTransaction_args()
        args.connId = connId
        args.isolationLevel = isolationLevel
        args.flags = flags
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_beginTransaction(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = beginTransaction_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "beginTransaction failed: unknown result")

    def setTransactionAttributes(self, connId, flags, token):
        """
        Parameters:
         - connId
         - flags
         - token
        """
        self.send_setTransactionAttributes(connId, flags, token)
        self.recv_setTransactionAttributes()

    def send_setTransactionAttributes(self, connId, flags, token):
        self._oprot.writeMessageBegin('setTransactionAttributes', TMessageType.CALL, self._seqid)
        args = setTransactionAttributes_args()
        args.connId = connId
        args.flags = flags
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setTransactionAttributes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setTransactionAttributes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def getTransactionAttributes(self, connId, token):
        """
        Parameters:
         - connId
         - token
        """
        self.send_getTransactionAttributes(connId, token)
        return self.recv_getTransactionAttributes()

    def send_getTransactionAttributes(self, connId, token):
        self._oprot.writeMessageBegin('getTransactionAttributes', TMessageType.CALL, self._seqid)
        args = getTransactionAttributes_args()
        args.connId = connId
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTransactionAttributes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTransactionAttributes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTransactionAttributes failed: unknown result")

    def commitTransaction(self, connId, startNewTransaction, flags, token):
        """
        Parameters:
         - connId
         - startNewTransaction
         - flags
         - token
        """
        self.send_commitTransaction(connId, startNewTransaction, flags, token)
        self.recv_commitTransaction()

    def send_commitTransaction(self, connId, startNewTransaction, flags, token):
        self._oprot.writeMessageBegin('commitTransaction', TMessageType.CALL, self._seqid)
        args = commitTransaction_args()
        args.connId = connId
        args.startNewTransaction = startNewTransaction
        args.flags = flags
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_commitTransaction(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = commitTransaction_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def rollbackTransaction(self, connId, startNewTransaction, flags, token):
        """
        Parameters:
         - connId
         - startNewTransaction
         - flags
         - token
        """
        self.send_rollbackTransaction(connId, startNewTransaction, flags, token)
        self.recv_rollbackTransaction()

    def send_rollbackTransaction(self, connId, startNewTransaction, flags, token):
        self._oprot.writeMessageBegin('rollbackTransaction', TMessageType.CALL, self._seqid)
        args = rollbackTransaction_args()
        args.connId = connId
        args.startNewTransaction = startNewTransaction
        args.flags = flags
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rollbackTransaction(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rollbackTransaction_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def getNextResultSet(self, cursorId, otherResultSetBehaviour, token):
        """
        Parameters:
         - cursorId
         - otherResultSetBehaviour
         - token
        """
        self.send_getNextResultSet(cursorId, otherResultSetBehaviour, token)
        return self.recv_getNextResultSet()

    def send_getNextResultSet(self, cursorId, otherResultSetBehaviour, token):
        self._oprot.writeMessageBegin('getNextResultSet', TMessageType.CALL, self._seqid)
        args = getNextResultSet_args()
        args.cursorId = cursorId
        args.otherResultSetBehaviour = otherResultSetBehaviour
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNextResultSet(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNextResultSet_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNextResultSet failed: unknown result")

    def getBlobChunk(self, connId, lobId, offset, size, freeLobAtEnd, token):
        """
        Parameters:
         - connId
         - lobId
         - offset
         - size
         - freeLobAtEnd
         - token
        """
        self.send_getBlobChunk(connId, lobId, offset, size, freeLobAtEnd, token)
        return self.recv_getBlobChunk()

    def send_getBlobChunk(self, connId, lobId, offset, size, freeLobAtEnd, token):
        self._oprot.writeMessageBegin('getBlobChunk', TMessageType.CALL, self._seqid)
        args = getBlobChunk_args()
        args.connId = connId
        args.lobId = lobId
        args.offset = offset
        args.size = size
        args.freeLobAtEnd = freeLobAtEnd
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getBlobChunk(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getBlobChunk_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getBlobChunk failed: unknown result")

    def getClobChunk(self, connId, lobId, offset, size, freeLobAtEnd, token):
        """
        Parameters:
         - connId
         - lobId
         - offset
         - size
         - freeLobAtEnd
         - token
        """
        self.send_getClobChunk(connId, lobId, offset, size, freeLobAtEnd, token)
        return self.recv_getClobChunk()

    def send_getClobChunk(self, connId, lobId, offset, size, freeLobAtEnd, token):
        self._oprot.writeMessageBegin('getClobChunk', TMessageType.CALL, self._seqid)
        args = getClobChunk_args()
        args.connId = connId
        args.lobId = lobId
        args.offset = offset
        args.size = size
        args.freeLobAtEnd = freeLobAtEnd
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getClobChunk(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getClobChunk_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getClobChunk failed: unknown result")

    def sendBlobChunk(self, chunk, connId, token):
        """
        Parameters:
         - chunk
         - connId
         - token
        """
        self.send_sendBlobChunk(chunk, connId, token)
        return self.recv_sendBlobChunk()

    def send_sendBlobChunk(self, chunk, connId, token):
        self._oprot.writeMessageBegin('sendBlobChunk', TMessageType.CALL, self._seqid)
        args = sendBlobChunk_args()
        args.chunk = chunk
        args.connId = connId
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sendBlobChunk(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sendBlobChunk_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sendBlobChunk failed: unknown result")

    def sendClobChunk(self, chunk, connId, token):
        """
        Parameters:
         - chunk
         - connId
         - token
        """
        self.send_sendClobChunk(chunk, connId, token)
        return self.recv_sendClobChunk()

    def send_sendClobChunk(self, chunk, connId, token):
        self._oprot.writeMessageBegin('sendClobChunk', TMessageType.CALL, self._seqid)
        args = sendClobChunk_args()
        args.chunk = chunk
        args.connId = connId
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sendClobChunk(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sendClobChunk_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sendClobChunk failed: unknown result")

    def freeLob(self, connId, lobId, token):
        """
        Parameters:
         - connId
         - lobId
         - token
        """
        self.send_freeLob(connId, lobId, token)
        self.recv_freeLob()

    def send_freeLob(self, connId, lobId, token):
        self._oprot.writeMessageBegin('freeLob', TMessageType.CALL, self._seqid)
        args = freeLob_args()
        args.connId = connId
        args.lobId = lobId
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_freeLob(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = freeLob_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def scrollCursor(self, cursorId, offset, offsetIsAbsolute, fetchReverse, fetchSize, token):
        """
        Parameters:
         - cursorId
         - offset
         - offsetIsAbsolute
         - fetchReverse
         - fetchSize
         - token
        """
        self.send_scrollCursor(cursorId, offset, offsetIsAbsolute, fetchReverse, fetchSize, token)
        return self.recv_scrollCursor()

    def send_scrollCursor(self, cursorId, offset, offsetIsAbsolute, fetchReverse, fetchSize, token):
        self._oprot.writeMessageBegin('scrollCursor', TMessageType.CALL, self._seqid)
        args = scrollCursor_args()
        args.cursorId = cursorId
        args.offset = offset
        args.offsetIsAbsolute = offsetIsAbsolute
        args.fetchReverse = fetchReverse
        args.fetchSize = fetchSize
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_scrollCursor(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = scrollCursor_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "scrollCursor failed: unknown result")

    def executeCursorUpdate(self, cursorId, operations, changedRows, changedColumnsList, changedRowIndexes, token):
        """
        Parameters:
         - cursorId
         - operations
         - changedRows
         - changedColumnsList
         - changedRowIndexes
         - token
        """
        self.send_executeCursorUpdate(cursorId, operations, changedRows, changedColumnsList, changedRowIndexes, token)
        self.recv_executeCursorUpdate()

    def send_executeCursorUpdate(self, cursorId, operations, changedRows, changedColumnsList, changedRowIndexes, token):
        self._oprot.writeMessageBegin('executeCursorUpdate', TMessageType.CALL, self._seqid)
        args = executeCursorUpdate_args()
        args.cursorId = cursorId
        args.operations = operations
        args.changedRows = changedRows
        args.changedColumnsList = changedColumnsList
        args.changedRowIndexes = changedRowIndexes
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executeCursorUpdate(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executeCursorUpdate_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def startXATransaction(self, connId, xid, timeoutInSeconds, flags, token):
        """
        Parameters:
         - connId
         - xid
         - timeoutInSeconds
         - flags
         - token
        """
        self.send_startXATransaction(connId, xid, timeoutInSeconds, flags, token)
        self.recv_startXATransaction()

    def send_startXATransaction(self, connId, xid, timeoutInSeconds, flags, token):
        self._oprot.writeMessageBegin('startXATransaction', TMessageType.CALL, self._seqid)
        args = startXATransaction_args()
        args.connId = connId
        args.xid = xid
        args.timeoutInSeconds = timeoutInSeconds
        args.flags = flags
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_startXATransaction(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = startXATransaction_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def prepareXATransaction(self, connId, xid, token):
        """
        Parameters:
         - connId
         - xid
         - token
        """
        self.send_prepareXATransaction(connId, xid, token)
        return self.recv_prepareXATransaction()

    def send_prepareXATransaction(self, connId, xid, token):
        self._oprot.writeMessageBegin('prepareXATransaction', TMessageType.CALL, self._seqid)
        args = prepareXATransaction_args()
        args.connId = connId
        args.xid = xid
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_prepareXATransaction(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = prepareXATransaction_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "prepareXATransaction failed: unknown result")

    def commitXATransaction(self, connId, xid, onePhase, token):
        """
        Parameters:
         - connId
         - xid
         - onePhase
         - token
        """
        self.send_commitXATransaction(connId, xid, onePhase, token)
        self.recv_commitXATransaction()

    def send_commitXATransaction(self, connId, xid, onePhase, token):
        self._oprot.writeMessageBegin('commitXATransaction', TMessageType.CALL, self._seqid)
        args = commitXATransaction_args()
        args.connId = connId
        args.xid = xid
        args.onePhase = onePhase
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_commitXATransaction(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = commitXATransaction_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def rollbackXATransaction(self, connId, xid, token):
        """
        Parameters:
         - connId
         - xid
         - token
        """
        self.send_rollbackXATransaction(connId, xid, token)
        self.recv_rollbackXATransaction()

    def send_rollbackXATransaction(self, connId, xid, token):
        self._oprot.writeMessageBegin('rollbackXATransaction', TMessageType.CALL, self._seqid)
        args = rollbackXATransaction_args()
        args.connId = connId
        args.xid = xid
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rollbackXATransaction(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rollbackXATransaction_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def forgetXATransaction(self, connId, xid, token):
        """
        Parameters:
         - connId
         - xid
         - token
        """
        self.send_forgetXATransaction(connId, xid, token)
        self.recv_forgetXATransaction()

    def send_forgetXATransaction(self, connId, xid, token):
        self._oprot.writeMessageBegin('forgetXATransaction', TMessageType.CALL, self._seqid)
        args = forgetXATransaction_args()
        args.connId = connId
        args.xid = xid
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forgetXATransaction(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forgetXATransaction_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def endXATransaction(self, connId, xid, flags, token):
        """
        Parameters:
         - connId
         - xid
         - flags
         - token
        """
        self.send_endXATransaction(connId, xid, flags, token)
        self.recv_endXATransaction()

    def send_endXATransaction(self, connId, xid, flags, token):
        self._oprot.writeMessageBegin('endXATransaction', TMessageType.CALL, self._seqid)
        args = endXATransaction_args()
        args.connId = connId
        args.xid = xid
        args.flags = flags
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_endXATransaction(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = endXATransaction_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def recoverXATransaction(self, connId, flag, token):
        """
        Parameters:
         - connId
         - flag
         - token
        """
        self.send_recoverXATransaction(connId, flag, token)
        return self.recv_recoverXATransaction()

    def send_recoverXATransaction(self, connId, flag, token):
        self._oprot.writeMessageBegin('recoverXATransaction', TMessageType.CALL, self._seqid)
        args = recoverXATransaction_args()
        args.connId = connId
        args.flag = flag
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_recoverXATransaction(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = recoverXATransaction_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "recoverXATransaction failed: unknown result")

    def getServiceMetaData(self, connId, token):
        """
        Parameters:
         - connId
         - token
        """
        self.send_getServiceMetaData(connId, token)
        return self.recv_getServiceMetaData()

    def send_getServiceMetaData(self, connId, token):
        self._oprot.writeMessageBegin('getServiceMetaData', TMessageType.CALL, self._seqid)
        args = getServiceMetaData_args()
        args.connId = connId
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getServiceMetaData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getServiceMetaData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getServiceMetaData failed: unknown result")

    def getSchemaMetaData(self, schemaCall, metadataArgs):
        """
        Parameters:
         - schemaCall
         - metadataArgs
        """
        self.send_getSchemaMetaData(schemaCall, metadataArgs)
        return self.recv_getSchemaMetaData()

    def send_getSchemaMetaData(self, schemaCall, metadataArgs):
        self._oprot.writeMessageBegin('getSchemaMetaData', TMessageType.CALL, self._seqid)
        args = getSchemaMetaData_args()
        args.schemaCall = schemaCall
        args.metadataArgs = metadataArgs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSchemaMetaData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSchemaMetaData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSchemaMetaData failed: unknown result")

    def getIndexInfo(self, metadataArgs, unique, approximate):
        """
        Parameters:
         - metadataArgs
         - unique
         - approximate
        """
        self.send_getIndexInfo(metadataArgs, unique, approximate)
        return self.recv_getIndexInfo()

    def send_getIndexInfo(self, metadataArgs, unique, approximate):
        self._oprot.writeMessageBegin('getIndexInfo', TMessageType.CALL, self._seqid)
        args = getIndexInfo_args()
        args.metadataArgs = metadataArgs
        args.unique = unique
        args.approximate = approximate
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getIndexInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getIndexInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getIndexInfo failed: unknown result")

    def getUDTs(self, metadataArgs, types):
        """
        Parameters:
         - metadataArgs
         - types
        """
        self.send_getUDTs(metadataArgs, types)
        return self.recv_getUDTs()

    def send_getUDTs(self, metadataArgs, types):
        self._oprot.writeMessageBegin('getUDTs', TMessageType.CALL, self._seqid)
        args = getUDTs_args()
        args.metadataArgs = metadataArgs
        args.types = types
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getUDTs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getUDTs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getUDTs failed: unknown result")

    def getBestRowIdentifier(self, metadataArgs, scope, nullable):
        """
        Parameters:
         - metadataArgs
         - scope
         - nullable
        """
        self.send_getBestRowIdentifier(metadataArgs, scope, nullable)
        return self.recv_getBestRowIdentifier()

    def send_getBestRowIdentifier(self, metadataArgs, scope, nullable):
        self._oprot.writeMessageBegin('getBestRowIdentifier', TMessageType.CALL, self._seqid)
        args = getBestRowIdentifier_args()
        args.metadataArgs = metadataArgs
        args.scope = scope
        args.nullable = nullable
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getBestRowIdentifier(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getBestRowIdentifier_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getBestRowIdentifier failed: unknown result")

    def fetchActiveConnections(self, connId, token):
        """
        Parameters:
         - connId
         - token
        """
        self.send_fetchActiveConnections(connId, token)
        return self.recv_fetchActiveConnections()

    def send_fetchActiveConnections(self, connId, token):
        self._oprot.writeMessageBegin('fetchActiveConnections', TMessageType.CALL, self._seqid)
        args = fetchActiveConnections_args()
        args.connId = connId
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fetchActiveConnections(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fetchActiveConnections_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fetchActiveConnections failed: unknown result")

    def fetchActiveStatements(self, connId, token):
        """
        Parameters:
         - connId
         - token
        """
        self.send_fetchActiveStatements(connId, token)
        return self.recv_fetchActiveStatements()

    def send_fetchActiveStatements(self, connId, token):
        self._oprot.writeMessageBegin('fetchActiveStatements', TMessageType.CALL, self._seqid)
        args = fetchActiveStatements_args()
        args.connId = connId
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fetchActiveStatements(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fetchActiveStatements_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fetchActiveStatements failed: unknown result")

    def cancelStatement(self, stmtId, token):
        """
        Parameters:
         - stmtId
         - token
        """
        self.send_cancelStatement(stmtId, token)
        self.recv_cancelStatement()

    def send_cancelStatement(self, stmtId, token):
        self._oprot.writeMessageBegin('cancelStatement', TMessageType.CALL, self._seqid)
        args = cancelStatement_args()
        args.stmtId = stmtId
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cancelStatement(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cancelStatement_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def cancelCurrentStatement(self, connId, token):
        """
        Parameters:
         - connId
         - token
        """
        self.send_cancelCurrentStatement(connId, token)
        self.recv_cancelCurrentStatement()

    def send_cancelCurrentStatement(self, connId, token):
        self._oprot.writeMessageBegin('cancelCurrentStatement', TMessageType.CALL, self._seqid)
        args = cancelCurrentStatement_args()
        args.connId = connId
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cancelCurrentStatement(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cancelCurrentStatement_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def closeResultSet(self, cursorId, token):
        """
        Parameters:
         - cursorId
         - token
        """
        self.send_closeResultSet(cursorId, token)
        self.recv_closeResultSet()

    def send_closeResultSet(self, cursorId, token):
        self._oprot.writeMessageBegin('closeResultSet', TMessageType.CALL, self._seqid)
        args = closeResultSet_args()
        args.cursorId = cursorId
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_closeResultSet(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = closeResultSet_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def closeStatement(self, stmtId, token):
        """
        Parameters:
         - stmtId
         - token
        """
        self.send_closeStatement(stmtId, token)
        self.recv_closeStatement()

    def send_closeStatement(self, stmtId, token):
        self._oprot.writeMessageBegin('closeStatement', TMessageType.CALL, self._seqid)
        args = closeStatement_args()
        args.stmtId = stmtId
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_closeStatement(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = closeStatement_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def closeConnection(self, connId, closeSocket, token):
        """
        Parameters:
         - connId
         - closeSocket
         - token
        """
        self.send_closeConnection(connId, closeSocket, token)

    def send_closeConnection(self, connId, closeSocket, token):
        self._oprot.writeMessageBegin('closeConnection', TMessageType.ONEWAY, self._seqid)
        args = closeConnection_args()
        args.connId = connId
        args.closeSocket = closeSocket
        args.token = token
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def bulkClose(self, entities):
        """
        Parameters:
         - entities
        """
        self.send_bulkClose(entities)

    def send_bulkClose(self, entities):
        self._oprot.writeMessageBegin('bulkClose', TMessageType.ONEWAY, self._seqid)
        args = bulkClose_args()
        args.entities = entities
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["getPreferredServer"] = Processor.process_getPreferredServer
        self._processMap["getAllServersWithPreferredServer"] = Processor.process_getAllServersWithPreferredServer
        self._processMap["openConnection"] = Processor.process_openConnection
        self._processMap["execute"] = Processor.process_execute
        self._processMap["executeUpdate"] = Processor.process_executeUpdate
        self._processMap["executeQuery"] = Processor.process_executeQuery
        self._processMap["prepareStatement"] = Processor.process_prepareStatement
        self._processMap["executePrepared"] = Processor.process_executePrepared
        self._processMap["executePreparedUpdate"] = Processor.process_executePreparedUpdate
        self._processMap["executePreparedQuery"] = Processor.process_executePreparedQuery
        self._processMap["executePreparedBatch"] = Processor.process_executePreparedBatch
        self._processMap["prepareAndExecute"] = Processor.process_prepareAndExecute
        self._processMap["beginTransaction"] = Processor.process_beginTransaction
        self._processMap["setTransactionAttributes"] = Processor.process_setTransactionAttributes
        self._processMap["getTransactionAttributes"] = Processor.process_getTransactionAttributes
        self._processMap["commitTransaction"] = Processor.process_commitTransaction
        self._processMap["rollbackTransaction"] = Processor.process_rollbackTransaction
        self._processMap["getNextResultSet"] = Processor.process_getNextResultSet
        self._processMap["getBlobChunk"] = Processor.process_getBlobChunk
        self._processMap["getClobChunk"] = Processor.process_getClobChunk
        self._processMap["sendBlobChunk"] = Processor.process_sendBlobChunk
        self._processMap["sendClobChunk"] = Processor.process_sendClobChunk
        self._processMap["freeLob"] = Processor.process_freeLob
        self._processMap["scrollCursor"] = Processor.process_scrollCursor
        self._processMap["executeCursorUpdate"] = Processor.process_executeCursorUpdate
        self._processMap["startXATransaction"] = Processor.process_startXATransaction
        self._processMap["prepareXATransaction"] = Processor.process_prepareXATransaction
        self._processMap["commitXATransaction"] = Processor.process_commitXATransaction
        self._processMap["rollbackXATransaction"] = Processor.process_rollbackXATransaction
        self._processMap["forgetXATransaction"] = Processor.process_forgetXATransaction
        self._processMap["endXATransaction"] = Processor.process_endXATransaction
        self._processMap["recoverXATransaction"] = Processor.process_recoverXATransaction
        self._processMap["getServiceMetaData"] = Processor.process_getServiceMetaData
        self._processMap["getSchemaMetaData"] = Processor.process_getSchemaMetaData
        self._processMap["getIndexInfo"] = Processor.process_getIndexInfo
        self._processMap["getUDTs"] = Processor.process_getUDTs
        self._processMap["getBestRowIdentifier"] = Processor.process_getBestRowIdentifier
        self._processMap["fetchActiveConnections"] = Processor.process_fetchActiveConnections
        self._processMap["fetchActiveStatements"] = Processor.process_fetchActiveStatements
        self._processMap["cancelStatement"] = Processor.process_cancelStatement
        self._processMap["cancelCurrentStatement"] = Processor.process_cancelCurrentStatement
        self._processMap["closeResultSet"] = Processor.process_closeResultSet
        self._processMap["closeStatement"] = Processor.process_closeStatement
        self._processMap["closeConnection"] = Processor.process_closeConnection
        self._processMap["bulkClose"] = Processor.process_bulkClose

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_getPreferredServer(self, seqid, iprot, oprot):
        args = getPreferredServer_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPreferredServer_result()
        try:
            result.success = self._handler.getPreferredServer(args.serverTypes, args.serverGroups, args.failedServers)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getPreferredServer", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAllServersWithPreferredServer(self, seqid, iprot, oprot):
        args = getAllServersWithPreferredServer_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllServersWithPreferredServer_result()
        try:
            result.success = self._handler.getAllServersWithPreferredServer(args.serverTypes, args.serverGroups, args.failedServers)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAllServersWithPreferredServer", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_openConnection(self, seqid, iprot, oprot):
        args = openConnection_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = openConnection_result()
        try:
            result.success = self._handler.openConnection(args.arguments)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("openConnection", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_execute(self, seqid, iprot, oprot):
        args = execute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = execute_result()
        try:
            result.success = self._handler.execute(args.connId, args.sql, args.outputParams, args.attrs, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("execute", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executeUpdate(self, seqid, iprot, oprot):
        args = executeUpdate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executeUpdate_result()
        try:
            result.success = self._handler.executeUpdate(args.connId, args.sqls, args.attrs, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executeUpdate", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executeQuery(self, seqid, iprot, oprot):
        args = executeQuery_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executeQuery_result()
        try:
            result.success = self._handler.executeQuery(args.connId, args.sql, args.attrs, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executeQuery", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_prepareStatement(self, seqid, iprot, oprot):
        args = prepareStatement_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = prepareStatement_result()
        try:
            result.success = self._handler.prepareStatement(args.connId, args.sql, args.outputParams, args.attrs, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("prepareStatement", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executePrepared(self, seqid, iprot, oprot):
        args = executePrepared_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executePrepared_result()
        try:
            result.success = self._handler.executePrepared(args.stmtId, args.params, args.outputParams, args.attrs, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executePrepared", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executePreparedUpdate(self, seqid, iprot, oprot):
        args = executePreparedUpdate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executePreparedUpdate_result()
        try:
            result.success = self._handler.executePreparedUpdate(args.stmtId, args.params, args.attrs, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executePreparedUpdate", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executePreparedQuery(self, seqid, iprot, oprot):
        args = executePreparedQuery_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executePreparedQuery_result()
        try:
            result.success = self._handler.executePreparedQuery(args.stmtId, args.params, args.attrs, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executePreparedQuery", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executePreparedBatch(self, seqid, iprot, oprot):
        args = executePreparedBatch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executePreparedBatch_result()
        try:
            result.success = self._handler.executePreparedBatch(args.stmtId, args.paramsBatch, args.attrs, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executePreparedBatch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_prepareAndExecute(self, seqid, iprot, oprot):
        args = prepareAndExecute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = prepareAndExecute_result()
        try:
            result.success = self._handler.prepareAndExecute(args.connId, args.sql, args.paramsBatch, args.outputParams, args.attrs, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("prepareAndExecute", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_beginTransaction(self, seqid, iprot, oprot):
        args = beginTransaction_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = beginTransaction_result()
        try:
            result.success = self._handler.beginTransaction(args.connId, args.isolationLevel, args.flags, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("beginTransaction", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setTransactionAttributes(self, seqid, iprot, oprot):
        args = setTransactionAttributes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setTransactionAttributes_result()
        try:
            self._handler.setTransactionAttributes(args.connId, args.flags, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setTransactionAttributes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTransactionAttributes(self, seqid, iprot, oprot):
        args = getTransactionAttributes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTransactionAttributes_result()
        try:
            result.success = self._handler.getTransactionAttributes(args.connId, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getTransactionAttributes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_commitTransaction(self, seqid, iprot, oprot):
        args = commitTransaction_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = commitTransaction_result()
        try:
            self._handler.commitTransaction(args.connId, args.startNewTransaction, args.flags, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("commitTransaction", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rollbackTransaction(self, seqid, iprot, oprot):
        args = rollbackTransaction_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rollbackTransaction_result()
        try:
            self._handler.rollbackTransaction(args.connId, args.startNewTransaction, args.flags, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rollbackTransaction", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNextResultSet(self, seqid, iprot, oprot):
        args = getNextResultSet_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNextResultSet_result()
        try:
            result.success = self._handler.getNextResultSet(args.cursorId, args.otherResultSetBehaviour, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNextResultSet", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getBlobChunk(self, seqid, iprot, oprot):
        args = getBlobChunk_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getBlobChunk_result()
        try:
            result.success = self._handler.getBlobChunk(args.connId, args.lobId, args.offset, args.size, args.freeLobAtEnd, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getBlobChunk", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getClobChunk(self, seqid, iprot, oprot):
        args = getClobChunk_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getClobChunk_result()
        try:
            result.success = self._handler.getClobChunk(args.connId, args.lobId, args.offset, args.size, args.freeLobAtEnd, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getClobChunk", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sendBlobChunk(self, seqid, iprot, oprot):
        args = sendBlobChunk_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sendBlobChunk_result()
        try:
            result.success = self._handler.sendBlobChunk(args.chunk, args.connId, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sendBlobChunk", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sendClobChunk(self, seqid, iprot, oprot):
        args = sendClobChunk_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sendClobChunk_result()
        try:
            result.success = self._handler.sendClobChunk(args.chunk, args.connId, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sendClobChunk", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_freeLob(self, seqid, iprot, oprot):
        args = freeLob_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = freeLob_result()
        try:
            self._handler.freeLob(args.connId, args.lobId, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("freeLob", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_scrollCursor(self, seqid, iprot, oprot):
        args = scrollCursor_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = scrollCursor_result()
        try:
            result.success = self._handler.scrollCursor(args.cursorId, args.offset, args.offsetIsAbsolute, args.fetchReverse, args.fetchSize, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("scrollCursor", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executeCursorUpdate(self, seqid, iprot, oprot):
        args = executeCursorUpdate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executeCursorUpdate_result()
        try:
            self._handler.executeCursorUpdate(args.cursorId, args.operations, args.changedRows, args.changedColumnsList, args.changedRowIndexes, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executeCursorUpdate", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_startXATransaction(self, seqid, iprot, oprot):
        args = startXATransaction_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = startXATransaction_result()
        try:
            self._handler.startXATransaction(args.connId, args.xid, args.timeoutInSeconds, args.flags, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("startXATransaction", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_prepareXATransaction(self, seqid, iprot, oprot):
        args = prepareXATransaction_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = prepareXATransaction_result()
        try:
            result.success = self._handler.prepareXATransaction(args.connId, args.xid, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("prepareXATransaction", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_commitXATransaction(self, seqid, iprot, oprot):
        args = commitXATransaction_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = commitXATransaction_result()
        try:
            self._handler.commitXATransaction(args.connId, args.xid, args.onePhase, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("commitXATransaction", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rollbackXATransaction(self, seqid, iprot, oprot):
        args = rollbackXATransaction_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rollbackXATransaction_result()
        try:
            self._handler.rollbackXATransaction(args.connId, args.xid, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rollbackXATransaction", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forgetXATransaction(self, seqid, iprot, oprot):
        args = forgetXATransaction_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forgetXATransaction_result()
        try:
            self._handler.forgetXATransaction(args.connId, args.xid, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forgetXATransaction", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_endXATransaction(self, seqid, iprot, oprot):
        args = endXATransaction_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = endXATransaction_result()
        try:
            self._handler.endXATransaction(args.connId, args.xid, args.flags, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("endXATransaction", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_recoverXATransaction(self, seqid, iprot, oprot):
        args = recoverXATransaction_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = recoverXATransaction_result()
        try:
            result.success = self._handler.recoverXATransaction(args.connId, args.flag, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("recoverXATransaction", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getServiceMetaData(self, seqid, iprot, oprot):
        args = getServiceMetaData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getServiceMetaData_result()
        try:
            result.success = self._handler.getServiceMetaData(args.connId, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getServiceMetaData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSchemaMetaData(self, seqid, iprot, oprot):
        args = getSchemaMetaData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSchemaMetaData_result()
        try:
            result.success = self._handler.getSchemaMetaData(args.schemaCall, args.metadataArgs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSchemaMetaData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getIndexInfo(self, seqid, iprot, oprot):
        args = getIndexInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getIndexInfo_result()
        try:
            result.success = self._handler.getIndexInfo(args.metadataArgs, args.unique, args.approximate)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getIndexInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getUDTs(self, seqid, iprot, oprot):
        args = getUDTs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getUDTs_result()
        try:
            result.success = self._handler.getUDTs(args.metadataArgs, args.types)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getUDTs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getBestRowIdentifier(self, seqid, iprot, oprot):
        args = getBestRowIdentifier_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getBestRowIdentifier_result()
        try:
            result.success = self._handler.getBestRowIdentifier(args.metadataArgs, args.scope, args.nullable)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getBestRowIdentifier", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fetchActiveConnections(self, seqid, iprot, oprot):
        args = fetchActiveConnections_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fetchActiveConnections_result()
        try:
            result.success = self._handler.fetchActiveConnections(args.connId, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fetchActiveConnections", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fetchActiveStatements(self, seqid, iprot, oprot):
        args = fetchActiveStatements_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fetchActiveStatements_result()
        try:
            result.success = self._handler.fetchActiveStatements(args.connId, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fetchActiveStatements", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cancelStatement(self, seqid, iprot, oprot):
        args = cancelStatement_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cancelStatement_result()
        try:
            self._handler.cancelStatement(args.stmtId, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cancelStatement", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cancelCurrentStatement(self, seqid, iprot, oprot):
        args = cancelCurrentStatement_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cancelCurrentStatement_result()
        try:
            self._handler.cancelCurrentStatement(args.connId, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cancelCurrentStatement", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_closeResultSet(self, seqid, iprot, oprot):
        args = closeResultSet_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = closeResultSet_result()
        try:
            self._handler.closeResultSet(args.cursorId, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("closeResultSet", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_closeStatement(self, seqid, iprot, oprot):
        args = closeStatement_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = closeStatement_result()
        try:
            self._handler.closeStatement(args.stmtId, args.token)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SnappyException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("closeStatement", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_closeConnection(self, seqid, iprot, oprot):
        args = closeConnection_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.closeConnection(args.connId, args.closeSocket, args.token)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_bulkClose(self, seqid, iprot, oprot):
        args = bulkClose_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.bulkClose(args.entities)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

# HELPER FUNCTIONS AND STRUCTURES


class getPreferredServer_args(object):
    """
    Attributes:
     - serverTypes
     - serverGroups
     - failedServers
    """


    def __init__(self, serverTypes=None, serverGroups=None, failedServers=None,):
        self.serverTypes = serverTypes
        self.serverGroups = serverGroups
        self.failedServers = failedServers

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.SET:
                    self.serverTypes = set()
                    (_etype290, _size287) = iprot.readSetBegin()
                    for _i291 in range(_size287):
                        _elem292 = iprot.readI32()
                        self.serverTypes.add(_elem292)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.serverGroups = set()
                    (_etype296, _size293) = iprot.readSetBegin()
                    for _i297 in range(_size293):
                        _elem298 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.serverGroups.add(_elem298)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.failedServers = set()
                    (_etype302, _size299) = iprot.readSetBegin()
                    for _i303 in range(_size299):
                        _elem304 = HostAddress()
                        _elem304.read(iprot)
                        self.failedServers.add(_elem304)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPreferredServer_args')
        if self.serverTypes is not None:
            oprot.writeFieldBegin('serverTypes', TType.SET, 1)
            oprot.writeSetBegin(TType.I32, len(self.serverTypes))
            for iter305 in self.serverTypes:
                oprot.writeI32(iter305)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.serverGroups is not None:
            oprot.writeFieldBegin('serverGroups', TType.SET, 2)
            oprot.writeSetBegin(TType.STRING, len(self.serverGroups))
            for iter306 in self.serverGroups:
                oprot.writeString(iter306.encode('utf-8') if sys.version_info[0] == 2 else iter306)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.failedServers is not None:
            oprot.writeFieldBegin('failedServers', TType.SET, 3)
            oprot.writeSetBegin(TType.STRUCT, len(self.failedServers))
            for iter307 in self.failedServers:
                iter307.write(oprot)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPreferredServer_args)
getPreferredServer_args.thrift_spec = (
    None,  # 0
    (1, TType.SET, 'serverTypes', (TType.I32, None, False), None, ),  # 1
    (2, TType.SET, 'serverGroups', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.SET, 'failedServers', (TType.STRUCT, [HostAddress, None], False), None, ),  # 3
)


class getPreferredServer_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = HostAddress()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPreferredServer_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPreferredServer_result)
getPreferredServer_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [HostAddress, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class getAllServersWithPreferredServer_args(object):
    """
    Attributes:
     - serverTypes
     - serverGroups
     - failedServers
    """


    def __init__(self, serverTypes=None, serverGroups=None, failedServers=None,):
        self.serverTypes = serverTypes
        self.serverGroups = serverGroups
        self.failedServers = failedServers

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.SET:
                    self.serverTypes = set()
                    (_etype311, _size308) = iprot.readSetBegin()
                    for _i312 in range(_size308):
                        _elem313 = iprot.readI32()
                        self.serverTypes.add(_elem313)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.serverGroups = set()
                    (_etype317, _size314) = iprot.readSetBegin()
                    for _i318 in range(_size314):
                        _elem319 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.serverGroups.add(_elem319)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.failedServers = set()
                    (_etype323, _size320) = iprot.readSetBegin()
                    for _i324 in range(_size320):
                        _elem325 = HostAddress()
                        _elem325.read(iprot)
                        self.failedServers.add(_elem325)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllServersWithPreferredServer_args')
        if self.serverTypes is not None:
            oprot.writeFieldBegin('serverTypes', TType.SET, 1)
            oprot.writeSetBegin(TType.I32, len(self.serverTypes))
            for iter326 in self.serverTypes:
                oprot.writeI32(iter326)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.serverGroups is not None:
            oprot.writeFieldBegin('serverGroups', TType.SET, 2)
            oprot.writeSetBegin(TType.STRING, len(self.serverGroups))
            for iter327 in self.serverGroups:
                oprot.writeString(iter327.encode('utf-8') if sys.version_info[0] == 2 else iter327)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.failedServers is not None:
            oprot.writeFieldBegin('failedServers', TType.SET, 3)
            oprot.writeSetBegin(TType.STRUCT, len(self.failedServers))
            for iter328 in self.failedServers:
                iter328.write(oprot)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllServersWithPreferredServer_args)
getAllServersWithPreferredServer_args.thrift_spec = (
    None,  # 0
    (1, TType.SET, 'serverTypes', (TType.I32, None, False), None, ),  # 1
    (2, TType.SET, 'serverGroups', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.SET, 'failedServers', (TType.STRUCT, [HostAddress, None], False), None, ),  # 3
)


class getAllServersWithPreferredServer_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype332, _size329) = iprot.readListBegin()
                    for _i333 in range(_size329):
                        _elem334 = HostAddress()
                        _elem334.read(iprot)
                        self.success.append(_elem334)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllServersWithPreferredServer_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter335 in self.success:
                iter335.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllServersWithPreferredServer_result)
getAllServersWithPreferredServer_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [HostAddress, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class openConnection_args(object):
    """
    Attributes:
     - arguments
    """


    def __init__(self, arguments=None,):
        self.arguments = arguments

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.arguments = OpenConnectionArgs()
                    self.arguments.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('openConnection_args')
        if self.arguments is not None:
            oprot.writeFieldBegin('arguments', TType.STRUCT, 1)
            self.arguments.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(openConnection_args)
openConnection_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'arguments', [OpenConnectionArgs, None], None, ),  # 1
)


class openConnection_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ConnectionProperties()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('openConnection_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(openConnection_result)
openConnection_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ConnectionProperties, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class execute_args(object):
    """
    Attributes:
     - connId
     - sql
     - outputParams
     - attrs
     - token
    """


    def __init__(self, connId=None, sql=None, outputParams=None, attrs=None, token=None,):
        self.connId = connId
        self.sql = sql
        self.outputParams = outputParams
        self.attrs = attrs
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sql = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.outputParams = {}
                    (_ktype337, _vtype338, _size336) = iprot.readMapBegin()
                    for _i340 in range(_size336):
                        _key341 = iprot.readI32()
                        _val342 = OutputParameter()
                        _val342.read(iprot)
                        self.outputParams[_key341] = _val342
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.attrs = StatementAttrs()
                    self.attrs.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('execute_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.sql is not None:
            oprot.writeFieldBegin('sql', TType.STRING, 2)
            oprot.writeString(self.sql.encode('utf-8') if sys.version_info[0] == 2 else self.sql)
            oprot.writeFieldEnd()
        if self.outputParams is not None:
            oprot.writeFieldBegin('outputParams', TType.MAP, 3)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.outputParams))
            for kiter343, viter344 in self.outputParams.items():
                oprot.writeI32(kiter343)
                viter344.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.attrs is not None:
            oprot.writeFieldBegin('attrs', TType.STRUCT, 4)
            self.attrs.write(oprot)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 5)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(execute_args)
execute_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.STRING, 'sql', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'outputParams', (TType.I32, None, TType.STRUCT, [OutputParameter, None], False), None, ),  # 3
    (4, TType.STRUCT, 'attrs', [StatementAttrs, None], None, ),  # 4
    (5, TType.STRING, 'token', 'BINARY', None, ),  # 5
)


class execute_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = StatementResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('execute_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(execute_result)
execute_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [StatementResult, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class executeUpdate_args(object):
    """
    Attributes:
     - connId
     - sqls
     - attrs
     - token
    """


    def __init__(self, connId=None, sqls=None, attrs=None, token=None,):
        self.connId = connId
        self.sqls = sqls
        self.attrs = attrs
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.sqls = []
                    (_etype348, _size345) = iprot.readListBegin()
                    for _i349 in range(_size345):
                        _elem350 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.sqls.append(_elem350)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.attrs = StatementAttrs()
                    self.attrs.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executeUpdate_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.sqls is not None:
            oprot.writeFieldBegin('sqls', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.sqls))
            for iter351 in self.sqls:
                oprot.writeString(iter351.encode('utf-8') if sys.version_info[0] == 2 else iter351)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.attrs is not None:
            oprot.writeFieldBegin('attrs', TType.STRUCT, 3)
            self.attrs.write(oprot)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 4)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executeUpdate_args)
executeUpdate_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.LIST, 'sqls', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRUCT, 'attrs', [StatementAttrs, None], None, ),  # 3
    (4, TType.STRING, 'token', 'BINARY', None, ),  # 4
)


class executeUpdate_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = UpdateResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executeUpdate_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executeUpdate_result)
executeUpdate_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [UpdateResult, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class executeQuery_args(object):
    """
    Attributes:
     - connId
     - sql
     - attrs
     - token
    """


    def __init__(self, connId=None, sql=None, attrs=None, token=None,):
        self.connId = connId
        self.sql = sql
        self.attrs = attrs
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sql = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.attrs = StatementAttrs()
                    self.attrs.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executeQuery_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.sql is not None:
            oprot.writeFieldBegin('sql', TType.STRING, 2)
            oprot.writeString(self.sql.encode('utf-8') if sys.version_info[0] == 2 else self.sql)
            oprot.writeFieldEnd()
        if self.attrs is not None:
            oprot.writeFieldBegin('attrs', TType.STRUCT, 3)
            self.attrs.write(oprot)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 4)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executeQuery_args)
executeQuery_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.STRING, 'sql', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'attrs', [StatementAttrs, None], None, ),  # 3
    (4, TType.STRING, 'token', 'BINARY', None, ),  # 4
)


class executeQuery_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RowSet()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executeQuery_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executeQuery_result)
executeQuery_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [RowSet, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class prepareStatement_args(object):
    """
    Attributes:
     - connId
     - sql
     - outputParams
     - attrs
     - token
    """


    def __init__(self, connId=None, sql=None, outputParams=None, attrs=None, token=None,):
        self.connId = connId
        self.sql = sql
        self.outputParams = outputParams
        self.attrs = attrs
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sql = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.outputParams = {}
                    (_ktype353, _vtype354, _size352) = iprot.readMapBegin()
                    for _i356 in range(_size352):
                        _key357 = iprot.readI32()
                        _val358 = OutputParameter()
                        _val358.read(iprot)
                        self.outputParams[_key357] = _val358
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.attrs = StatementAttrs()
                    self.attrs.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('prepareStatement_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.sql is not None:
            oprot.writeFieldBegin('sql', TType.STRING, 2)
            oprot.writeString(self.sql.encode('utf-8') if sys.version_info[0] == 2 else self.sql)
            oprot.writeFieldEnd()
        if self.outputParams is not None:
            oprot.writeFieldBegin('outputParams', TType.MAP, 3)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.outputParams))
            for kiter359, viter360 in self.outputParams.items():
                oprot.writeI32(kiter359)
                viter360.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.attrs is not None:
            oprot.writeFieldBegin('attrs', TType.STRUCT, 4)
            self.attrs.write(oprot)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 5)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(prepareStatement_args)
prepareStatement_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.STRING, 'sql', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'outputParams', (TType.I32, None, TType.STRUCT, [OutputParameter, None], False), None, ),  # 3
    (4, TType.STRUCT, 'attrs', [StatementAttrs, None], None, ),  # 4
    (5, TType.STRING, 'token', 'BINARY', None, ),  # 5
)


class prepareStatement_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PrepareResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('prepareStatement_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(prepareStatement_result)
prepareStatement_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [PrepareResult, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class executePrepared_args(object):
    """
    Attributes:
     - stmtId
     - params
     - outputParams
     - attrs
     - token
    """


    def __init__(self, stmtId=None, params=None, outputParams=None, attrs=None, token=None,):
        self.stmtId = stmtId
        self.params = params
        self.outputParams = outputParams
        self.attrs = attrs
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.stmtId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.params = Row()
                    self.params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.outputParams = {}
                    (_ktype362, _vtype363, _size361) = iprot.readMapBegin()
                    for _i365 in range(_size361):
                        _key366 = iprot.readI32()
                        _val367 = OutputParameter()
                        _val367.read(iprot)
                        self.outputParams[_key366] = _val367
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.attrs = StatementAttrs()
                    self.attrs.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executePrepared_args')
        if self.stmtId is not None:
            oprot.writeFieldBegin('stmtId', TType.I64, 1)
            oprot.writeI64(self.stmtId)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.STRUCT, 2)
            self.params.write(oprot)
            oprot.writeFieldEnd()
        if self.outputParams is not None:
            oprot.writeFieldBegin('outputParams', TType.MAP, 3)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.outputParams))
            for kiter368, viter369 in self.outputParams.items():
                oprot.writeI32(kiter368)
                viter369.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.attrs is not None:
            oprot.writeFieldBegin('attrs', TType.STRUCT, 4)
            self.attrs.write(oprot)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 5)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executePrepared_args)
executePrepared_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'stmtId', None, None, ),  # 1
    (2, TType.STRUCT, 'params', [Row, None], None, ),  # 2
    (3, TType.MAP, 'outputParams', (TType.I32, None, TType.STRUCT, [OutputParameter, None], False), None, ),  # 3
    (4, TType.STRUCT, 'attrs', [StatementAttrs, None], None, ),  # 4
    (5, TType.STRING, 'token', 'BINARY', None, ),  # 5
)


class executePrepared_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = StatementResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executePrepared_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executePrepared_result)
executePrepared_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [StatementResult, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class executePreparedUpdate_args(object):
    """
    Attributes:
     - stmtId
     - params
     - attrs
     - token
    """


    def __init__(self, stmtId=None, params=None, attrs=None, token=None,):
        self.stmtId = stmtId
        self.params = params
        self.attrs = attrs
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.stmtId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.params = Row()
                    self.params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.attrs = StatementAttrs()
                    self.attrs.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executePreparedUpdate_args')
        if self.stmtId is not None:
            oprot.writeFieldBegin('stmtId', TType.I64, 1)
            oprot.writeI64(self.stmtId)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.STRUCT, 2)
            self.params.write(oprot)
            oprot.writeFieldEnd()
        if self.attrs is not None:
            oprot.writeFieldBegin('attrs', TType.STRUCT, 3)
            self.attrs.write(oprot)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 4)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executePreparedUpdate_args)
executePreparedUpdate_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'stmtId', None, None, ),  # 1
    (2, TType.STRUCT, 'params', [Row, None], None, ),  # 2
    (3, TType.STRUCT, 'attrs', [StatementAttrs, None], None, ),  # 3
    (4, TType.STRING, 'token', 'BINARY', None, ),  # 4
)


class executePreparedUpdate_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = UpdateResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executePreparedUpdate_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executePreparedUpdate_result)
executePreparedUpdate_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [UpdateResult, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class executePreparedQuery_args(object):
    """
    Attributes:
     - stmtId
     - params
     - attrs
     - token
    """


    def __init__(self, stmtId=None, params=None, attrs=None, token=None,):
        self.stmtId = stmtId
        self.params = params
        self.attrs = attrs
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.stmtId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.params = Row()
                    self.params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.attrs = StatementAttrs()
                    self.attrs.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executePreparedQuery_args')
        if self.stmtId is not None:
            oprot.writeFieldBegin('stmtId', TType.I64, 1)
            oprot.writeI64(self.stmtId)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.STRUCT, 2)
            self.params.write(oprot)
            oprot.writeFieldEnd()
        if self.attrs is not None:
            oprot.writeFieldBegin('attrs', TType.STRUCT, 3)
            self.attrs.write(oprot)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 4)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executePreparedQuery_args)
executePreparedQuery_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'stmtId', None, None, ),  # 1
    (2, TType.STRUCT, 'params', [Row, None], None, ),  # 2
    (3, TType.STRUCT, 'attrs', [StatementAttrs, None], None, ),  # 3
    (4, TType.STRING, 'token', 'BINARY', None, ),  # 4
)


class executePreparedQuery_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RowSet()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executePreparedQuery_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executePreparedQuery_result)
executePreparedQuery_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [RowSet, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class executePreparedBatch_args(object):
    """
    Attributes:
     - stmtId
     - paramsBatch
     - attrs
     - token
    """


    def __init__(self, stmtId=None, paramsBatch=None, attrs=None, token=None,):
        self.stmtId = stmtId
        self.paramsBatch = paramsBatch
        self.attrs = attrs
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.stmtId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paramsBatch = []
                    (_etype373, _size370) = iprot.readListBegin()
                    for _i374 in range(_size370):
                        _elem375 = Row()
                        _elem375.read(iprot)
                        self.paramsBatch.append(_elem375)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.attrs = StatementAttrs()
                    self.attrs.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executePreparedBatch_args')
        if self.stmtId is not None:
            oprot.writeFieldBegin('stmtId', TType.I64, 1)
            oprot.writeI64(self.stmtId)
            oprot.writeFieldEnd()
        if self.paramsBatch is not None:
            oprot.writeFieldBegin('paramsBatch', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.paramsBatch))
            for iter376 in self.paramsBatch:
                iter376.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.attrs is not None:
            oprot.writeFieldBegin('attrs', TType.STRUCT, 3)
            self.attrs.write(oprot)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 4)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executePreparedBatch_args)
executePreparedBatch_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'stmtId', None, None, ),  # 1
    (2, TType.LIST, 'paramsBatch', (TType.STRUCT, [Row, None], False), None, ),  # 2
    (3, TType.STRUCT, 'attrs', [StatementAttrs, None], None, ),  # 3
    (4, TType.STRING, 'token', 'BINARY', None, ),  # 4
)


class executePreparedBatch_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = UpdateResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executePreparedBatch_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executePreparedBatch_result)
executePreparedBatch_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [UpdateResult, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class prepareAndExecute_args(object):
    """
    Attributes:
     - connId
     - sql
     - paramsBatch
     - outputParams
     - attrs
     - token
    """


    def __init__(self, connId=None, sql=None, paramsBatch=None, outputParams=None, attrs=None, token=None,):
        self.connId = connId
        self.sql = sql
        self.paramsBatch = paramsBatch
        self.outputParams = outputParams
        self.attrs = attrs
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sql = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.paramsBatch = []
                    (_etype380, _size377) = iprot.readListBegin()
                    for _i381 in range(_size377):
                        _elem382 = Row()
                        _elem382.read(iprot)
                        self.paramsBatch.append(_elem382)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.outputParams = {}
                    (_ktype384, _vtype385, _size383) = iprot.readMapBegin()
                    for _i387 in range(_size383):
                        _key388 = iprot.readI32()
                        _val389 = OutputParameter()
                        _val389.read(iprot)
                        self.outputParams[_key388] = _val389
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.attrs = StatementAttrs()
                    self.attrs.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('prepareAndExecute_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.sql is not None:
            oprot.writeFieldBegin('sql', TType.STRING, 2)
            oprot.writeString(self.sql.encode('utf-8') if sys.version_info[0] == 2 else self.sql)
            oprot.writeFieldEnd()
        if self.paramsBatch is not None:
            oprot.writeFieldBegin('paramsBatch', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.paramsBatch))
            for iter390 in self.paramsBatch:
                iter390.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.outputParams is not None:
            oprot.writeFieldBegin('outputParams', TType.MAP, 4)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.outputParams))
            for kiter391, viter392 in self.outputParams.items():
                oprot.writeI32(kiter391)
                viter392.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.attrs is not None:
            oprot.writeFieldBegin('attrs', TType.STRUCT, 5)
            self.attrs.write(oprot)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 6)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(prepareAndExecute_args)
prepareAndExecute_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.STRING, 'sql', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'paramsBatch', (TType.STRUCT, [Row, None], False), None, ),  # 3
    (4, TType.MAP, 'outputParams', (TType.I32, None, TType.STRUCT, [OutputParameter, None], False), None, ),  # 4
    (5, TType.STRUCT, 'attrs', [StatementAttrs, None], None, ),  # 5
    (6, TType.STRING, 'token', 'BINARY', None, ),  # 6
)


class prepareAndExecute_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = StatementResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('prepareAndExecute_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(prepareAndExecute_result)
prepareAndExecute_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [StatementResult, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class beginTransaction_args(object):
    """
    Attributes:
     - connId
     - isolationLevel
     - flags
     - token
    """


    def __init__(self, connId=None, isolationLevel=None, flags=None, token=None,):
        self.connId = connId
        self.isolationLevel = isolationLevel
        self.flags = flags
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.isolationLevel = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.flags = {}
                    (_ktype394, _vtype395, _size393) = iprot.readMapBegin()
                    for _i397 in range(_size393):
                        _key398 = iprot.readI32()
                        _val399 = iprot.readBool()
                        self.flags[_key398] = _val399
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('beginTransaction_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.isolationLevel is not None:
            oprot.writeFieldBegin('isolationLevel', TType.BYTE, 2)
            oprot.writeByte(self.isolationLevel)
            oprot.writeFieldEnd()
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.MAP, 3)
            oprot.writeMapBegin(TType.I32, TType.BOOL, len(self.flags))
            for kiter400, viter401 in self.flags.items():
                oprot.writeI32(kiter400)
                oprot.writeBool(viter401)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 4)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(beginTransaction_args)
beginTransaction_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.BYTE, 'isolationLevel', None, None, ),  # 2
    (3, TType.MAP, 'flags', (TType.I32, None, TType.BOOL, None, False), None, ),  # 3
    (4, TType.STRING, 'token', 'BINARY', None, ),  # 4
)


class beginTransaction_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BYTE:
                    self.success = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('beginTransaction_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BYTE, 0)
            oprot.writeByte(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(beginTransaction_result)
beginTransaction_result.thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class setTransactionAttributes_args(object):
    """
    Attributes:
     - connId
     - flags
     - token
    """


    def __init__(self, connId=None, flags=None, token=None,):
        self.connId = connId
        self.flags = flags
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.flags = {}
                    (_ktype403, _vtype404, _size402) = iprot.readMapBegin()
                    for _i406 in range(_size402):
                        _key407 = iprot.readI32()
                        _val408 = iprot.readBool()
                        self.flags[_key407] = _val408
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setTransactionAttributes_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.MAP, 2)
            oprot.writeMapBegin(TType.I32, TType.BOOL, len(self.flags))
            for kiter409, viter410 in self.flags.items():
                oprot.writeI32(kiter409)
                oprot.writeBool(viter410)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 3)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setTransactionAttributes_args)
setTransactionAttributes_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.MAP, 'flags', (TType.I32, None, TType.BOOL, None, False), None, ),  # 2
    (3, TType.STRING, 'token', 'BINARY', None, ),  # 3
)


class setTransactionAttributes_result(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setTransactionAttributes_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setTransactionAttributes_result)
setTransactionAttributes_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class getTransactionAttributes_args(object):
    """
    Attributes:
     - connId
     - token
    """


    def __init__(self, connId=None, token=None,):
        self.connId = connId
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTransactionAttributes_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 2)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTransactionAttributes_args)
getTransactionAttributes_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.STRING, 'token', 'BINARY', None, ),  # 2
)


class getTransactionAttributes_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype412, _vtype413, _size411) = iprot.readMapBegin()
                    for _i415 in range(_size411):
                        _key416 = iprot.readI32()
                        _val417 = iprot.readBool()
                        self.success[_key416] = _val417
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTransactionAttributes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.BOOL, len(self.success))
            for kiter418, viter419 in self.success.items():
                oprot.writeI32(kiter418)
                oprot.writeBool(viter419)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTransactionAttributes_result)
getTransactionAttributes_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32, None, TType.BOOL, None, False), None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class commitTransaction_args(object):
    """
    Attributes:
     - connId
     - startNewTransaction
     - flags
     - token
    """


    def __init__(self, connId=None, startNewTransaction=None, flags=None, token=None,):
        self.connId = connId
        self.startNewTransaction = startNewTransaction
        self.flags = flags
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.startNewTransaction = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.flags = {}
                    (_ktype421, _vtype422, _size420) = iprot.readMapBegin()
                    for _i424 in range(_size420):
                        _key425 = iprot.readI32()
                        _val426 = iprot.readBool()
                        self.flags[_key425] = _val426
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commitTransaction_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.startNewTransaction is not None:
            oprot.writeFieldBegin('startNewTransaction', TType.BOOL, 2)
            oprot.writeBool(self.startNewTransaction)
            oprot.writeFieldEnd()
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.MAP, 3)
            oprot.writeMapBegin(TType.I32, TType.BOOL, len(self.flags))
            for kiter427, viter428 in self.flags.items():
                oprot.writeI32(kiter427)
                oprot.writeBool(viter428)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 4)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commitTransaction_args)
commitTransaction_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.BOOL, 'startNewTransaction', None, None, ),  # 2
    (3, TType.MAP, 'flags', (TType.I32, None, TType.BOOL, None, False), None, ),  # 3
    (4, TType.STRING, 'token', 'BINARY', None, ),  # 4
)


class commitTransaction_result(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commitTransaction_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commitTransaction_result)
commitTransaction_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class rollbackTransaction_args(object):
    """
    Attributes:
     - connId
     - startNewTransaction
     - flags
     - token
    """


    def __init__(self, connId=None, startNewTransaction=None, flags=None, token=None,):
        self.connId = connId
        self.startNewTransaction = startNewTransaction
        self.flags = flags
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.startNewTransaction = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.flags = {}
                    (_ktype430, _vtype431, _size429) = iprot.readMapBegin()
                    for _i433 in range(_size429):
                        _key434 = iprot.readI32()
                        _val435 = iprot.readBool()
                        self.flags[_key434] = _val435
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rollbackTransaction_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.startNewTransaction is not None:
            oprot.writeFieldBegin('startNewTransaction', TType.BOOL, 2)
            oprot.writeBool(self.startNewTransaction)
            oprot.writeFieldEnd()
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.MAP, 3)
            oprot.writeMapBegin(TType.I32, TType.BOOL, len(self.flags))
            for kiter436, viter437 in self.flags.items():
                oprot.writeI32(kiter436)
                oprot.writeBool(viter437)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 4)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rollbackTransaction_args)
rollbackTransaction_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.BOOL, 'startNewTransaction', None, None, ),  # 2
    (3, TType.MAP, 'flags', (TType.I32, None, TType.BOOL, None, False), None, ),  # 3
    (4, TType.STRING, 'token', 'BINARY', None, ),  # 4
)


class rollbackTransaction_result(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rollbackTransaction_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rollbackTransaction_result)
rollbackTransaction_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class getNextResultSet_args(object):
    """
    Attributes:
     - cursorId
     - otherResultSetBehaviour
     - token
    """


    def __init__(self, cursorId=None, otherResultSetBehaviour=None, token=None,):
        self.cursorId = cursorId
        self.otherResultSetBehaviour = otherResultSetBehaviour
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cursorId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.otherResultSetBehaviour = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNextResultSet_args')
        if self.cursorId is not None:
            oprot.writeFieldBegin('cursorId', TType.I64, 1)
            oprot.writeI64(self.cursorId)
            oprot.writeFieldEnd()
        if self.otherResultSetBehaviour is not None:
            oprot.writeFieldBegin('otherResultSetBehaviour', TType.BYTE, 2)
            oprot.writeByte(self.otherResultSetBehaviour)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 3)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNextResultSet_args)
getNextResultSet_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cursorId', None, None, ),  # 1
    (2, TType.BYTE, 'otherResultSetBehaviour', None, None, ),  # 2
    (3, TType.STRING, 'token', 'BINARY', None, ),  # 3
)


class getNextResultSet_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RowSet()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNextResultSet_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNextResultSet_result)
getNextResultSet_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [RowSet, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class getBlobChunk_args(object):
    """
    Attributes:
     - connId
     - lobId
     - offset
     - size
     - freeLobAtEnd
     - token
    """


    def __init__(self, connId=None, lobId=None, offset=None, size=None, freeLobAtEnd=None, token=None,):
        self.connId = connId
        self.lobId = lobId
        self.offset = offset
        self.size = size
        self.freeLobAtEnd = freeLobAtEnd
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.lobId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.freeLobAtEnd = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getBlobChunk_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.lobId is not None:
            oprot.writeFieldBegin('lobId', TType.I64, 2)
            oprot.writeI64(self.lobId)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 3)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 4)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.freeLobAtEnd is not None:
            oprot.writeFieldBegin('freeLobAtEnd', TType.BOOL, 5)
            oprot.writeBool(self.freeLobAtEnd)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 6)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getBlobChunk_args)
getBlobChunk_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.I64, 'lobId', None, None, ),  # 2
    (3, TType.I64, 'offset', None, None, ),  # 3
    (4, TType.I32, 'size', None, None, ),  # 4
    (5, TType.BOOL, 'freeLobAtEnd', None, None, ),  # 5
    (6, TType.STRING, 'token', 'BINARY', None, ),  # 6
)


class getBlobChunk_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = BlobChunk()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getBlobChunk_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getBlobChunk_result)
getBlobChunk_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [BlobChunk, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class getClobChunk_args(object):
    """
    Attributes:
     - connId
     - lobId
     - offset
     - size
     - freeLobAtEnd
     - token
    """


    def __init__(self, connId=None, lobId=None, offset=None, size=None, freeLobAtEnd=None, token=None,):
        self.connId = connId
        self.lobId = lobId
        self.offset = offset
        self.size = size
        self.freeLobAtEnd = freeLobAtEnd
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.lobId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.freeLobAtEnd = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getClobChunk_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.lobId is not None:
            oprot.writeFieldBegin('lobId', TType.I64, 2)
            oprot.writeI64(self.lobId)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 3)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 4)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.freeLobAtEnd is not None:
            oprot.writeFieldBegin('freeLobAtEnd', TType.BOOL, 5)
            oprot.writeBool(self.freeLobAtEnd)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 6)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getClobChunk_args)
getClobChunk_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.I64, 'lobId', None, None, ),  # 2
    (3, TType.I64, 'offset', None, None, ),  # 3
    (4, TType.I32, 'size', None, None, ),  # 4
    (5, TType.BOOL, 'freeLobAtEnd', None, None, ),  # 5
    (6, TType.STRING, 'token', 'BINARY', None, ),  # 6
)


class getClobChunk_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ClobChunk()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getClobChunk_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getClobChunk_result)
getClobChunk_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ClobChunk, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class sendBlobChunk_args(object):
    """
    Attributes:
     - chunk
     - connId
     - token
    """


    def __init__(self, chunk=None, connId=None, token=None,):
        self.chunk = chunk
        self.connId = connId
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.chunk = BlobChunk()
                    self.chunk.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sendBlobChunk_args')
        if self.chunk is not None:
            oprot.writeFieldBegin('chunk', TType.STRUCT, 1)
            self.chunk.write(oprot)
            oprot.writeFieldEnd()
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 2)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 3)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sendBlobChunk_args)
sendBlobChunk_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'chunk', [BlobChunk, None], None, ),  # 1
    (2, TType.I64, 'connId', None, None, ),  # 2
    (3, TType.STRING, 'token', 'BINARY', None, ),  # 3
)


class sendBlobChunk_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sendBlobChunk_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sendBlobChunk_result)
sendBlobChunk_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class sendClobChunk_args(object):
    """
    Attributes:
     - chunk
     - connId
     - token
    """


    def __init__(self, chunk=None, connId=None, token=None,):
        self.chunk = chunk
        self.connId = connId
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.chunk = ClobChunk()
                    self.chunk.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sendClobChunk_args')
        if self.chunk is not None:
            oprot.writeFieldBegin('chunk', TType.STRUCT, 1)
            self.chunk.write(oprot)
            oprot.writeFieldEnd()
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 2)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 3)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sendClobChunk_args)
sendClobChunk_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'chunk', [ClobChunk, None], None, ),  # 1
    (2, TType.I64, 'connId', None, None, ),  # 2
    (3, TType.STRING, 'token', 'BINARY', None, ),  # 3
)


class sendClobChunk_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sendClobChunk_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sendClobChunk_result)
sendClobChunk_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class freeLob_args(object):
    """
    Attributes:
     - connId
     - lobId
     - token
    """


    def __init__(self, connId=None, lobId=None, token=None,):
        self.connId = connId
        self.lobId = lobId
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.lobId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('freeLob_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.lobId is not None:
            oprot.writeFieldBegin('lobId', TType.I64, 2)
            oprot.writeI64(self.lobId)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 3)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(freeLob_args)
freeLob_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.I64, 'lobId', None, None, ),  # 2
    (3, TType.STRING, 'token', 'BINARY', None, ),  # 3
)


class freeLob_result(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('freeLob_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(freeLob_result)
freeLob_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class scrollCursor_args(object):
    """
    Attributes:
     - cursorId
     - offset
     - offsetIsAbsolute
     - fetchReverse
     - fetchSize
     - token
    """


    def __init__(self, cursorId=None, offset=None, offsetIsAbsolute=None, fetchReverse=None, fetchSize=None, token=None,):
        self.cursorId = cursorId
        self.offset = offset
        self.offsetIsAbsolute = offsetIsAbsolute
        self.fetchReverse = fetchReverse
        self.fetchSize = fetchSize
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cursorId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.offsetIsAbsolute = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.fetchReverse = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scrollCursor_args')
        if self.cursorId is not None:
            oprot.writeFieldBegin('cursorId', TType.I64, 1)
            oprot.writeI64(self.cursorId)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I32, 2)
            oprot.writeI32(self.offset)
            oprot.writeFieldEnd()
        if self.offsetIsAbsolute is not None:
            oprot.writeFieldBegin('offsetIsAbsolute', TType.BOOL, 3)
            oprot.writeBool(self.offsetIsAbsolute)
            oprot.writeFieldEnd()
        if self.fetchReverse is not None:
            oprot.writeFieldBegin('fetchReverse', TType.BOOL, 4)
            oprot.writeBool(self.fetchReverse)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 5)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 6)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scrollCursor_args)
scrollCursor_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cursorId', None, None, ),  # 1
    (2, TType.I32, 'offset', None, None, ),  # 2
    (3, TType.BOOL, 'offsetIsAbsolute', None, None, ),  # 3
    (4, TType.BOOL, 'fetchReverse', None, None, ),  # 4
    (5, TType.I32, 'fetchSize', None, None, ),  # 5
    (6, TType.STRING, 'token', 'BINARY', None, ),  # 6
)


class scrollCursor_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RowSet()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('scrollCursor_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(scrollCursor_result)
scrollCursor_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [RowSet, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class executeCursorUpdate_args(object):
    """
    Attributes:
     - cursorId
     - operations
     - changedRows
     - changedColumnsList
     - changedRowIndexes
     - token
    """


    def __init__(self, cursorId=None, operations=None, changedRows=None, changedColumnsList=None, changedRowIndexes=None, token=None,):
        self.cursorId = cursorId
        self.operations = operations
        self.changedRows = changedRows
        self.changedColumnsList = changedColumnsList
        self.changedRowIndexes = changedRowIndexes
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cursorId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.operations = []
                    (_etype441, _size438) = iprot.readListBegin()
                    for _i442 in range(_size438):
                        _elem443 = iprot.readI32()
                        self.operations.append(_elem443)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.changedRows = []
                    (_etype447, _size444) = iprot.readListBegin()
                    for _i448 in range(_size444):
                        _elem449 = Row()
                        _elem449.read(iprot)
                        self.changedRows.append(_elem449)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.changedColumnsList = []
                    (_etype453, _size450) = iprot.readListBegin()
                    for _i454 in range(_size450):
                        _elem455 = []
                        (_etype459, _size456) = iprot.readListBegin()
                        for _i460 in range(_size456):
                            _elem461 = iprot.readI32()
                            _elem455.append(_elem461)
                        iprot.readListEnd()
                        self.changedColumnsList.append(_elem455)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.changedRowIndexes = []
                    (_etype465, _size462) = iprot.readListBegin()
                    for _i466 in range(_size462):
                        _elem467 = iprot.readI32()
                        self.changedRowIndexes.append(_elem467)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executeCursorUpdate_args')
        if self.cursorId is not None:
            oprot.writeFieldBegin('cursorId', TType.I64, 1)
            oprot.writeI64(self.cursorId)
            oprot.writeFieldEnd()
        if self.operations is not None:
            oprot.writeFieldBegin('operations', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.operations))
            for iter468 in self.operations:
                oprot.writeI32(iter468)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.changedRows is not None:
            oprot.writeFieldBegin('changedRows', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.changedRows))
            for iter469 in self.changedRows:
                iter469.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.changedColumnsList is not None:
            oprot.writeFieldBegin('changedColumnsList', TType.LIST, 4)
            oprot.writeListBegin(TType.LIST, len(self.changedColumnsList))
            for iter470 in self.changedColumnsList:
                oprot.writeListBegin(TType.I32, len(iter470))
                for iter471 in iter470:
                    oprot.writeI32(iter471)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.changedRowIndexes is not None:
            oprot.writeFieldBegin('changedRowIndexes', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.changedRowIndexes))
            for iter472 in self.changedRowIndexes:
                oprot.writeI32(iter472)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 6)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executeCursorUpdate_args)
executeCursorUpdate_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cursorId', None, None, ),  # 1
    (2, TType.LIST, 'operations', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'changedRows', (TType.STRUCT, [Row, None], False), None, ),  # 3
    (4, TType.LIST, 'changedColumnsList', (TType.LIST, (TType.I32, None, False), False), None, ),  # 4
    (5, TType.LIST, 'changedRowIndexes', (TType.I32, None, False), None, ),  # 5
    (6, TType.STRING, 'token', 'BINARY', None, ),  # 6
)


class executeCursorUpdate_result(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executeCursorUpdate_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executeCursorUpdate_result)
executeCursorUpdate_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class startXATransaction_args(object):
    """
    Attributes:
     - connId
     - xid
     - timeoutInSeconds
     - flags
     - token
    """


    def __init__(self, connId=None, xid=None, timeoutInSeconds=None, flags=None, token=None,):
        self.connId = connId
        self.xid = xid
        self.timeoutInSeconds = timeoutInSeconds
        self.flags = flags
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.xid = TransactionXid()
                    self.xid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.timeoutInSeconds = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.flags = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('startXATransaction_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.xid is not None:
            oprot.writeFieldBegin('xid', TType.STRUCT, 2)
            self.xid.write(oprot)
            oprot.writeFieldEnd()
        if self.timeoutInSeconds is not None:
            oprot.writeFieldBegin('timeoutInSeconds', TType.I32, 3)
            oprot.writeI32(self.timeoutInSeconds)
            oprot.writeFieldEnd()
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.I32, 4)
            oprot.writeI32(self.flags)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 5)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(startXATransaction_args)
startXATransaction_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.STRUCT, 'xid', [TransactionXid, None], None, ),  # 2
    (3, TType.I32, 'timeoutInSeconds', None, None, ),  # 3
    (4, TType.I32, 'flags', None, None, ),  # 4
    (5, TType.STRING, 'token', 'BINARY', None, ),  # 5
)


class startXATransaction_result(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('startXATransaction_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(startXATransaction_result)
startXATransaction_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class prepareXATransaction_args(object):
    """
    Attributes:
     - connId
     - xid
     - token
    """


    def __init__(self, connId=None, xid=None, token=None,):
        self.connId = connId
        self.xid = xid
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.xid = TransactionXid()
                    self.xid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('prepareXATransaction_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.xid is not None:
            oprot.writeFieldBegin('xid', TType.STRUCT, 2)
            self.xid.write(oprot)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 3)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(prepareXATransaction_args)
prepareXATransaction_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.STRUCT, 'xid', [TransactionXid, None], None, ),  # 2
    (3, TType.STRING, 'token', 'BINARY', None, ),  # 3
)


class prepareXATransaction_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('prepareXATransaction_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(prepareXATransaction_result)
prepareXATransaction_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class commitXATransaction_args(object):
    """
    Attributes:
     - connId
     - xid
     - onePhase
     - token
    """


    def __init__(self, connId=None, xid=None, onePhase=None, token=None,):
        self.connId = connId
        self.xid = xid
        self.onePhase = onePhase
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.xid = TransactionXid()
                    self.xid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.onePhase = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commitXATransaction_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.xid is not None:
            oprot.writeFieldBegin('xid', TType.STRUCT, 2)
            self.xid.write(oprot)
            oprot.writeFieldEnd()
        if self.onePhase is not None:
            oprot.writeFieldBegin('onePhase', TType.BOOL, 3)
            oprot.writeBool(self.onePhase)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 4)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commitXATransaction_args)
commitXATransaction_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.STRUCT, 'xid', [TransactionXid, None], None, ),  # 2
    (3, TType.BOOL, 'onePhase', None, None, ),  # 3
    (4, TType.STRING, 'token', 'BINARY', None, ),  # 4
)


class commitXATransaction_result(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commitXATransaction_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commitXATransaction_result)
commitXATransaction_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class rollbackXATransaction_args(object):
    """
    Attributes:
     - connId
     - xid
     - token
    """


    def __init__(self, connId=None, xid=None, token=None,):
        self.connId = connId
        self.xid = xid
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.xid = TransactionXid()
                    self.xid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rollbackXATransaction_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.xid is not None:
            oprot.writeFieldBegin('xid', TType.STRUCT, 2)
            self.xid.write(oprot)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 3)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rollbackXATransaction_args)
rollbackXATransaction_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.STRUCT, 'xid', [TransactionXid, None], None, ),  # 2
    (3, TType.STRING, 'token', 'BINARY', None, ),  # 3
)


class rollbackXATransaction_result(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rollbackXATransaction_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rollbackXATransaction_result)
rollbackXATransaction_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class forgetXATransaction_args(object):
    """
    Attributes:
     - connId
     - xid
     - token
    """


    def __init__(self, connId=None, xid=None, token=None,):
        self.connId = connId
        self.xid = xid
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.xid = TransactionXid()
                    self.xid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forgetXATransaction_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.xid is not None:
            oprot.writeFieldBegin('xid', TType.STRUCT, 2)
            self.xid.write(oprot)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 3)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forgetXATransaction_args)
forgetXATransaction_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.STRUCT, 'xid', [TransactionXid, None], None, ),  # 2
    (3, TType.STRING, 'token', 'BINARY', None, ),  # 3
)


class forgetXATransaction_result(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forgetXATransaction_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forgetXATransaction_result)
forgetXATransaction_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class endXATransaction_args(object):
    """
    Attributes:
     - connId
     - xid
     - flags
     - token
    """


    def __init__(self, connId=None, xid=None, flags=None, token=None,):
        self.connId = connId
        self.xid = xid
        self.flags = flags
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.xid = TransactionXid()
                    self.xid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.flags = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('endXATransaction_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.xid is not None:
            oprot.writeFieldBegin('xid', TType.STRUCT, 2)
            self.xid.write(oprot)
            oprot.writeFieldEnd()
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.I32, 3)
            oprot.writeI32(self.flags)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 4)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(endXATransaction_args)
endXATransaction_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.STRUCT, 'xid', [TransactionXid, None], None, ),  # 2
    (3, TType.I32, 'flags', None, None, ),  # 3
    (4, TType.STRING, 'token', 'BINARY', None, ),  # 4
)


class endXATransaction_result(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('endXATransaction_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(endXATransaction_result)
endXATransaction_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class recoverXATransaction_args(object):
    """
    Attributes:
     - connId
     - flag
     - token
    """


    def __init__(self, connId=None, flag=None, token=None,):
        self.connId = connId
        self.flag = flag
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.flag = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('recoverXATransaction_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.flag is not None:
            oprot.writeFieldBegin('flag', TType.I32, 2)
            oprot.writeI32(self.flag)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 3)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(recoverXATransaction_args)
recoverXATransaction_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.I32, 'flag', None, None, ),  # 2
    (3, TType.STRING, 'token', 'BINARY', None, ),  # 3
)


class recoverXATransaction_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype476, _size473) = iprot.readListBegin()
                    for _i477 in range(_size473):
                        _elem478 = TransactionXid()
                        _elem478.read(iprot)
                        self.success.append(_elem478)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('recoverXATransaction_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter479 in self.success:
                iter479.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(recoverXATransaction_result)
recoverXATransaction_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TransactionXid, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class getServiceMetaData_args(object):
    """
    Attributes:
     - connId
     - token
    """


    def __init__(self, connId=None, token=None,):
        self.connId = connId
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getServiceMetaData_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 2)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getServiceMetaData_args)
getServiceMetaData_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.STRING, 'token', 'BINARY', None, ),  # 2
)


class getServiceMetaData_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ServiceMetaData()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getServiceMetaData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getServiceMetaData_result)
getServiceMetaData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ServiceMetaData, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class getSchemaMetaData_args(object):
    """
    Attributes:
     - schemaCall
     - metadataArgs
    """


    def __init__(self, schemaCall=None, metadataArgs=None,):
        self.schemaCall = schemaCall
        self.metadataArgs = metadataArgs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.schemaCall = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.metadataArgs = ServiceMetaDataArgs()
                    self.metadataArgs.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSchemaMetaData_args')
        if self.schemaCall is not None:
            oprot.writeFieldBegin('schemaCall', TType.I32, 1)
            oprot.writeI32(self.schemaCall)
            oprot.writeFieldEnd()
        if self.metadataArgs is not None:
            oprot.writeFieldBegin('metadataArgs', TType.STRUCT, 2)
            self.metadataArgs.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSchemaMetaData_args)
getSchemaMetaData_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'schemaCall', None, None, ),  # 1
    (2, TType.STRUCT, 'metadataArgs', [ServiceMetaDataArgs, None], None, ),  # 2
)


class getSchemaMetaData_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RowSet()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSchemaMetaData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSchemaMetaData_result)
getSchemaMetaData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [RowSet, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class getIndexInfo_args(object):
    """
    Attributes:
     - metadataArgs
     - unique
     - approximate
    """


    def __init__(self, metadataArgs=None, unique=None, approximate=None,):
        self.metadataArgs = metadataArgs
        self.unique = unique
        self.approximate = approximate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metadataArgs = ServiceMetaDataArgs()
                    self.metadataArgs.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.unique = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.approximate = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getIndexInfo_args')
        if self.metadataArgs is not None:
            oprot.writeFieldBegin('metadataArgs', TType.STRUCT, 1)
            self.metadataArgs.write(oprot)
            oprot.writeFieldEnd()
        if self.unique is not None:
            oprot.writeFieldBegin('unique', TType.BOOL, 2)
            oprot.writeBool(self.unique)
            oprot.writeFieldEnd()
        if self.approximate is not None:
            oprot.writeFieldBegin('approximate', TType.BOOL, 3)
            oprot.writeBool(self.approximate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getIndexInfo_args)
getIndexInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metadataArgs', [ServiceMetaDataArgs, None], None, ),  # 1
    (2, TType.BOOL, 'unique', None, None, ),  # 2
    (3, TType.BOOL, 'approximate', None, None, ),  # 3
)


class getIndexInfo_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RowSet()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getIndexInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getIndexInfo_result)
getIndexInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [RowSet, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class getUDTs_args(object):
    """
    Attributes:
     - metadataArgs
     - types
    """


    def __init__(self, metadataArgs=None, types=None,):
        self.metadataArgs = metadataArgs
        self.types = types

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metadataArgs = ServiceMetaDataArgs()
                    self.metadataArgs.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.types = []
                    (_etype483, _size480) = iprot.readListBegin()
                    for _i484 in range(_size480):
                        _elem485 = iprot.readI32()
                        self.types.append(_elem485)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getUDTs_args')
        if self.metadataArgs is not None:
            oprot.writeFieldBegin('metadataArgs', TType.STRUCT, 1)
            self.metadataArgs.write(oprot)
            oprot.writeFieldEnd()
        if self.types is not None:
            oprot.writeFieldBegin('types', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.types))
            for iter486 in self.types:
                oprot.writeI32(iter486)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getUDTs_args)
getUDTs_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metadataArgs', [ServiceMetaDataArgs, None], None, ),  # 1
    (2, TType.LIST, 'types', (TType.I32, None, False), None, ),  # 2
)


class getUDTs_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RowSet()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getUDTs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getUDTs_result)
getUDTs_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [RowSet, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class getBestRowIdentifier_args(object):
    """
    Attributes:
     - metadataArgs
     - scope
     - nullable
    """


    def __init__(self, metadataArgs=None, scope=None, nullable=None,):
        self.metadataArgs = metadataArgs
        self.scope = scope
        self.nullable = nullable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metadataArgs = ServiceMetaDataArgs()
                    self.metadataArgs.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.scope = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.nullable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getBestRowIdentifier_args')
        if self.metadataArgs is not None:
            oprot.writeFieldBegin('metadataArgs', TType.STRUCT, 1)
            self.metadataArgs.write(oprot)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.I32, 2)
            oprot.writeI32(self.scope)
            oprot.writeFieldEnd()
        if self.nullable is not None:
            oprot.writeFieldBegin('nullable', TType.BOOL, 3)
            oprot.writeBool(self.nullable)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getBestRowIdentifier_args)
getBestRowIdentifier_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metadataArgs', [ServiceMetaDataArgs, None], None, ),  # 1
    (2, TType.I32, 'scope', None, None, ),  # 2
    (3, TType.BOOL, 'nullable', None, None, ),  # 3
)


class getBestRowIdentifier_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RowSet()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getBestRowIdentifier_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getBestRowIdentifier_result)
getBestRowIdentifier_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [RowSet, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class fetchActiveConnections_args(object):
    """
    Attributes:
     - connId
     - token
    """


    def __init__(self, connId=None, token=None,):
        self.connId = connId
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fetchActiveConnections_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 2)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fetchActiveConnections_args)
fetchActiveConnections_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.STRING, 'token', 'BINARY', None, ),  # 2
)


class fetchActiveConnections_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype490, _size487) = iprot.readListBegin()
                    for _i491 in range(_size487):
                        _elem492 = ConnectionProperties()
                        _elem492.read(iprot)
                        self.success.append(_elem492)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fetchActiveConnections_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter493 in self.success:
                iter493.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fetchActiveConnections_result)
fetchActiveConnections_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ConnectionProperties, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class fetchActiveStatements_args(object):
    """
    Attributes:
     - connId
     - token
    """


    def __init__(self, connId=None, token=None,):
        self.connId = connId
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fetchActiveStatements_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 2)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fetchActiveStatements_args)
fetchActiveStatements_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.STRING, 'token', 'BINARY', None, ),  # 2
)


class fetchActiveStatements_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype495, _vtype496, _size494) = iprot.readMapBegin()
                    for _i498 in range(_size494):
                        _key499 = iprot.readI64()
                        _val500 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key499] = _val500
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fetchActiveStatements_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
            for kiter501, viter502 in self.success.items():
                oprot.writeI64(kiter501)
                oprot.writeString(viter502.encode('utf-8') if sys.version_info[0] == 2 else viter502)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fetchActiveStatements_result)
fetchActiveStatements_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class cancelStatement_args(object):
    """
    Attributes:
     - stmtId
     - token
    """


    def __init__(self, stmtId=None, token=None,):
        self.stmtId = stmtId
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.stmtId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancelStatement_args')
        if self.stmtId is not None:
            oprot.writeFieldBegin('stmtId', TType.I64, 1)
            oprot.writeI64(self.stmtId)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 2)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancelStatement_args)
cancelStatement_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'stmtId', None, None, ),  # 1
    (2, TType.STRING, 'token', 'BINARY', None, ),  # 2
)


class cancelStatement_result(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancelStatement_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancelStatement_result)
cancelStatement_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class cancelCurrentStatement_args(object):
    """
    Attributes:
     - connId
     - token
    """


    def __init__(self, connId=None, token=None,):
        self.connId = connId
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancelCurrentStatement_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 2)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancelCurrentStatement_args)
cancelCurrentStatement_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.STRING, 'token', 'BINARY', None, ),  # 2
)


class cancelCurrentStatement_result(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancelCurrentStatement_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancelCurrentStatement_result)
cancelCurrentStatement_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class closeResultSet_args(object):
    """
    Attributes:
     - cursorId
     - token
    """


    def __init__(self, cursorId=None, token=None,):
        self.cursorId = cursorId
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cursorId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('closeResultSet_args')
        if self.cursorId is not None:
            oprot.writeFieldBegin('cursorId', TType.I64, 1)
            oprot.writeI64(self.cursorId)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 2)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(closeResultSet_args)
closeResultSet_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cursorId', None, None, ),  # 1
    (2, TType.STRING, 'token', 'BINARY', None, ),  # 2
)


class closeResultSet_result(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('closeResultSet_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(closeResultSet_result)
closeResultSet_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class closeStatement_args(object):
    """
    Attributes:
     - stmtId
     - token
    """


    def __init__(self, stmtId=None, token=None,):
        self.stmtId = stmtId
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.stmtId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('closeStatement_args')
        if self.stmtId is not None:
            oprot.writeFieldBegin('stmtId', TType.I64, 1)
            oprot.writeI64(self.stmtId)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 2)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(closeStatement_args)
closeStatement_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'stmtId', None, None, ),  # 1
    (2, TType.STRING, 'token', 'BINARY', None, ),  # 2
)


class closeStatement_result(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SnappyException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('closeStatement_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(closeStatement_result)
closeStatement_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SnappyException, None], None, ),  # 1
)


class closeConnection_args(object):
    """
    Attributes:
     - connId
     - closeSocket
     - token
    """


    def __init__(self, connId=None, closeSocket=None, token=None,):
        self.connId = connId
        self.closeSocket = closeSocket
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.closeSocket = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('closeConnection_args')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.closeSocket is not None:
            oprot.writeFieldBegin('closeSocket', TType.BOOL, 2)
            oprot.writeBool(self.closeSocket)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 3)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(closeConnection_args)
closeConnection_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.BOOL, 'closeSocket', None, None, ),  # 2
    (3, TType.STRING, 'token', 'BINARY', None, ),  # 3
)


class bulkClose_args(object):
    """
    Attributes:
     - entities
    """


    def __init__(self, entities=None,):
        self.entities = entities

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.entities = []
                    (_etype506, _size503) = iprot.readListBegin()
                    for _i507 in range(_size503):
                        _elem508 = EntityId()
                        _elem508.read(iprot)
                        self.entities.append(_elem508)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('bulkClose_args')
        if self.entities is not None:
            oprot.writeFieldBegin('entities', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.entities))
            for iter509 in self.entities:
                iter509.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(bulkClose_args)
bulkClose_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'entities', (TType.STRUCT, [EntityId, None], False), None, ),  # 1
)
fix_spec(all_structs)
del all_structs

