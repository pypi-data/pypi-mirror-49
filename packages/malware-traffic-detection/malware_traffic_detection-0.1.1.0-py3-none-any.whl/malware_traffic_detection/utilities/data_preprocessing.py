import binascii
import copy
import json

from sklearn.preprocessing import MinMaxScaler, StandardScaler


def normalize_data(train_data, mode='std'):
    data = copy.deepcopy(train_data)
    if mode == 'std':
        scaler = StandardScaler()
    elif mode == 'minmax':
        scaler = MinMaxScaler()
    else:
        print('mode is not correct.')
        return -1
    scaler.fit(data)

    data = scaler.transform(data)

    return data, scaler


def save_data(data_dict, out_file):
    # # save to txt, however, it is not convenient to load
    # with open(out_file, 'w') as out_hdr:
    #     out_hdr.write(str(data_dict))

    # dict = {'Python': '.py', 'C++': '.cpp', 'Java': '.java'}
    with open(out_file, 'w') as out_hdr:
        out_hdr.write(json.dumps(data_dict))


def load_data(in_file):
    with open(in_file, 'r') as in_hdr:
        data_dict = json.load(in_hdr)

    return data_dict


def bytes2str():
    """
        Because we do not know the endcoding, so we cannot use raw_bytes_v.decode('utf-8') to decode.

        the following way is better when we do not know the encoding manner, we can transfor bytes to hex firstly,
        then parse the hex value without needing to guess encoding manner.
    :return:
    """
    raw_bytes_v = b'\x00\xc1\xb1\x14\xeb1\x00#\xae\x9b\x95g\x08\x00E\x00\x004\xd9<@\x00@\x06\xdfq\xc0\xa8\n\x11\xac\xd9\n\x83\xc0\xce\x01\xbb\x1f%B\xc0=G\xa3\xe3\x80\x10\x01\x96\xcde\x00\x00\x01\x01\x08\n\x00\x1b,` p\xd3&'
    print(len(raw_bytes_v), type(raw_bytes_v))
    # """
    # # binascii.hexlify()
    # #     Return the hexadecimal representation of the binary data. Every byte of data is converted into
    #       the corresponding 2-digit hex representation. The returned bytes object is therefore twice as long as the length of data.
    # #     Similar functionality (but returning a text string) is also conveniently accessible using the bytes.hex() method.
    #
    # # Python print weird characters, or Strange notation for Python 3 bytes
    # #
    # # The bytes representation will use ASCII characters for any bytes that are printable and escape codes for the rest.
    # #
    # # Thus, 0x40 is printed as @, because that's a printable byte. But 0x0a is represented as \n instead,
    # # because that is the standard Python escape sequence for a newline character. 0x00 is represented as \x00,
    # # a hex escape sequence denoting the NULL byte value. Etc.
    # #
    # # All this is just the Python representation when echoing the values, for your debugging benefit.
    # # The actual value itself still consists of actual byte values.
    # #
    # # >>> b'\x40' == b'@'
    # # True
    # # >>> b'\x0a' == b'\n'
    # # True
    # #
    # # It's just that any byte in the printable ASCII range will be shown as that ASCII character
    # # rather than a \xhh hex escape or dedicated \c one-character escape sequence.
    # #
    # # If you wanted to see only hexadecimal representations, use the binascii.hexlify() function:
    # #
    # # >>> import binascii
    # # >>> binascii.hexlify(b'@\x00\x00\x00')
    # # b'40000000'
    # # >>> binascii.hexlify(b'\n\x00\x00\x00')
    # # b'0a000000'
    # #
    # # which returns bytes as hex characters (with no prefixes), instead. The return value is of course no longer the same value,
    # # you now have a bytestring of twice the original length consisting of characters representing hexadecimal values,
    # # literal a through to f and 0 through to 9 characters.
    # :return:
    # """

    bytes_v = binascii.hexlify(raw_bytes_v)  #
    print(len(bytes_v), type(bytes_v), bytes_v)

    bytes_v_raw = binascii.unhexlify(bytes_v)  #
    print(len(bytes_v_raw), type(bytes_v_raw), bytes_v_raw)

    str_v = bytes.hex(raw_bytes_v)
    print(len(str_v), type(str_v), str_v)

    return str_v

if __name__ == '__main__':
    bytes2str()
