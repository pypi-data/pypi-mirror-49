# -*- coding: utf-8 -*-
from __future__ import absolute_import
"""
Small setup package to dynamically interface with ROS
"""
from ._version import __version__

import os
import types
import sys

# forcing minimal version for pyros_config (very important since we play with multiple python environments...)
# This should allow pkg_resources to go through multiple version fo the same package... Ref : http://bugs.python.org/setuptools/issue139
# but it seems not to work. more testing needed.
# __requires__ = [
#     "pyros_config>=0.2"
# ]
import pkg_resources
# This produces a version conflict if the imported version is not the correct one. Fix your distro.
pkg_resources.require("pyros_config>=0.2")

# Configuring logging default handler
import logging
_logger = logging.getLogger(__name__)

from .utils import deprecated
from pyros_config import ConfigHandler

#: Smart Default distro detection (as early as possible)

if os.path.exists('/opt/ros/melodic'):
    DETECTED_DISTRO = 'melodic'
elif os.path.exists('/opt/ros/lunar'):
    DETECTED_DISTRO = 'lunar'
elif os.path.exists('/opt/ros/kinetic'):
    DETECTED_DISTRO = 'kinetic'
elif os.path.exists('/opt/ros/jade'):
    DETECTED_DISTRO = 'jade'
elif os.path.exists('/opt/ros/indigo'):
    DETECTED_DISTRO = 'indigo'
else:
    DETECTED_DISTRO = 'unknown'


# TODO : add "is ROS setup.bash sourced?" check method
# to allow client to raise ImportError directly instead of attempting emulation.

def configurable_import(instance_path=None, instance_relative_config=True, root_path=None):
    """
    Configure an import relay, using a configuration file (found in the instance or root path).
    This is designed after Flask instance configuration mechanism http://flask.pocoo.org/docs/0.10/config/#instance-folders
    :param instance_path: path to the instance folder. defaults to a sensible 'instance' location (refer to Flask doc)
    :param instance_relative_config: whether the configuration file is in the instance folder (or the root_path)
    :param root_path: path to the application's folder
    :return:
    """

    class PyrosSetup(object):
        def __init__(self, instance_path=None, instance_relative_config=True, root_path=None):

            # TODO : use calculated instance path (inside venv)

            # we delegate config related behavior (including defaults)
            self.config_handler = ConfigHandler(
                __name__,
                instance_path=instance_path,
                instance_relative_config=instance_relative_config,
                root_path=root_path,
                default_config={
                    'DISTRO': DETECTED_DISTRO,
                    'WORKSPACES': [],
                },
            )

        def configure(self, config=None):
            """
            load configuration
            :param config:
                if string, it is assumed to be a path to a python configuration file
                else if dict, it is assumed to directly contain the configuration settings
                otherwise the object passed will be introspected to attempt to set the configuration settings.
            :return: self
            """

            self.config_handler.configure_file(config=config, create_if_missing="""
# default configuration generated by pyros-setup
# Usage from python :
# import pyros_setup
# pyros_setup.configurable_import().configure().activate()
#
# Fill in your workspaces here, if you want to dynamically import ROS packages from it.
WORKSPACES=[]

# ROS distribution. Change this value to the ROS distribution you want to use with this environment.
""" + "DISTRO='{0}'".format(DETECTED_DISTRO) + """
""")

            return self

        def activate(self):
            """
            Activate import relay (via setting sys.modules[])
            :return: self
            """

            # TODO : put that in context to allow deactivation... ( but HOWTO mix deactivation with module import ?)

            # The actual trick
            _logger.warning("Dynamic PyROS setup starting...")
            from .ros_setup import ROS_emulate_setup
            # we want this to except in case of bad config, because default_config has to have these fields.
            ROS_emulate_setup(self.config_handler.config['DISTRO'], *self.config_handler.config['WORKSPACES'])

            # Main relay
            # CAREFUL this doesn't work sometimes (had problem when using from celery bootstep...)
            # sys.modules[self.config_handler.import_name] = self

            _logger.warning("Dynamic PyROS setup done.")

            return self

    # we return a relay of imported names, accessible the same way a direct import would be.
    setup = PyrosSetup(
        instance_path=instance_path,
        instance_relative_config=instance_relative_config,
        root_path=root_path,
    )

    return setup


__all__ = [
    '__version__',
    'deprecated',
    'configurable_import',
    'DETECTED_DISTRO',
]
