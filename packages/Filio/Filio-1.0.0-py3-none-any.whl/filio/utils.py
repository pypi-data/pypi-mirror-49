import asyncio
import json
import sys
import shutil
import functools
from datetime import datetime

import os

file_path = os.getenv("HOME") + '/.filio'


async def produce(queue, path: str):
    empty_files = []
    broken_files = []
    producer_dic = {}

    for root, folders, files in os.walk(path):
        for file in files:
            try:
                if os.path.isfile(os.path.join(root, file)) and os.path.getsize(
                        os.path.join(root, file)) == 0 and not file == '__init__.py':
                    # contains all empty files
                    empty_files.append(os.path.join(root, file))
                elif not os.path.isfile(os.path.join(root, file)):
                    # contains all bad files eg broken links etc
                    broken_files.append(os.path.join(root, file))

            except Exception as e:
                print(e)
                sys.exit()
    print(f'you have : {len(empty_files)} empty files in your pc')
    print(' ')
    print(f'you have : {len(broken_files)} broken files in your pc')
    print(' ')
    producer_dic['header'] = 'filio statistics'
    producer_dic['timestamp'] = datetime.strftime(datetime.now(), "%d %b %Y %H:%M:%S")
    producer_dic['total_no_of_broken_files'] = len(broken_files)
    producer_dic['total_no_of_empty_files'] = len(empty_files)
    total, used, free = shutil.disk_usage('/')
    healthy = True if free // 2 ** 30 > 10 else False
    total = "Total: %d GB " % (total // 2 ** 30)
    used = "Used: %d GB " % (used // 2 ** 30)
    free = "Free: %d GB " % (free // 2 ** 30)
    producer_dic['total_harddisk_storage'] = total
    producer_dic['used_storage'] = used
    producer_dic['free_storage'] = free
    producer_dic['disk_healthy'] = healthy
    await queue.put(producer_dic)
    return empty_files, broken_files


def json_writer(path, list_):
    # write out the json file to the home dir
    try:
        with open(path, 'w') as json_file:
            json.dump(list_, json_file, indent=2)
        print('successful')
        return
    except IOError as e:
        print(e)


async def consume(queue):
    while True:
        item = await queue.get()
        try:
            if not os.path.exists(file_path):
                os.mkdir(file_path)
                if item != {}:
                    print(f'filio statistics: {item}')
                    json_writer(file_path + '/data.json', item)
                else:
                    print(f'No broken files or empty files:\n {item}')
                    json_writer(file_path + '/data.json', "No broken files or empty files")
            else:
                if item != {}:
                    print(f'filio statistics: {item}')
                    json_writer(file_path + '/data.json', item)
                else:
                    print(f'No broken files or empty files:\n{item}')
                    json_writer(file_path + '/data.json', "No broken files or empty files")
        except Exception as e:
            print(e)
        # print(item.get('empty_files',[]))
        # print(item.get('broken_files', []))
        queue.task_done()


async def run(path: str):
    queue = asyncio.Queue()
    consumer = asyncio.ensure_future(consume(queue))
    await  produce(queue, path)
    await  queue.join()
    consumer.cancel()


def frame(name, style_character='*'):
    frame_line = style_character * (len(name) + 15)
    print(frame_line)
    print(f'{name}'.center(len(name) + 10))
    print(frame_line)


@functools.lru_cache(maxsize=None)
def detailed_info(path: str):
    empty_files = []
    broken_files = []
    categories_ = []
    with os.scandir(path) as entries:
        for entry in entries:
            if entry.is_dir():
                categories_.append(entry.name)
    for folder in categories_:
        frame(f'{folder} ' + ' folder ')
        print(' ')
        for root, folders, files in os.walk(os.path.join(path, folder)):
            for file in files:
                try:
                    if os.path.isfile(os.path.join(root, file)) and os.path.getsize(
                            os.path.join(root, file)) == 0 and not file == '__init__.py':  # conventionally __init_.py
                        # are always blank since they're autogenerated by the ides
                        # contains all empty files
                        last_accessed = datetime.fromtimestamp(os.path.getatime(os.path.join(root, file))).strftime(
                            "%d %b %Y")
                        empty_files.append(files)
                        print(f'Empty file ------> {file}  Last accessed: {last_accessed}')
                    elif not os.path.isfile(os.path.join(root, file)):
                        # contains all bad files eg broken links etc
                        broken_files.append(file)
                        print(f'Broken file ------> {file}  ')
                except Exception as e:
                    print(e)
                    sys.exit()
    print(f'you have : {len(empty_files)} empty files in your pc')
    print(' ')
    print(f'you have : {len(broken_files)} broken files in your pc')
    print(' ')
