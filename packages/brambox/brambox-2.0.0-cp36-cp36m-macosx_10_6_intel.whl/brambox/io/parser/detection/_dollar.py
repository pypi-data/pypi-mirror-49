#
#   Copyright EAVISE
#   Author: Maarten Vandersteegen
#   Author: Tanguy Ophoff
#
"""
dollar
------
"""
import logging
import numpy as np
from ._base import *

__all__ = ["DollarParser"]
log = logging.getLogger(__name__)


class DollarParser(DetectionParser):
    """ This parser is designed to parse the text based dollar detections generated by Piotr Dollar's toolbox_
    and the EAVISE PeopleDetect framework.

    Keyword Args:
        class_label (string, optional): class label name of the detections (this format only supports single object class detections); Default **'?'**
        precision (int, optional): precision to use for the confidence when saving detections with this format; Default **0**

    A text file contains multiple detections over multiple images where each line in the file represents one
    detection bounding box.
    Each line is a comma separated list of values structured as follows:

        <image_id>,<x>,<y>,<w>,<h>,<score>

    =========  ===========
    Name       Description
    =========  ===========
    image_id   image identifier that this annotation belong to (integer)
    x          top left x coordinate of the bounding box in pixels (integer)
    y          top left y coordinate of the bounding box in pixels (integer)
    w          width of the bounding box in pixels (integer)
    h          height of the bounding box in pixels (integer)
    score      relative detection score not limited between boundaries (float)
    =========  ===========

    Example:
        >>> video_000.txt
            20,503,213,20,50,74.8391
            20,540,166,37,91,56.4761
            30,519,186,31,77,51.2428

    Note:
        In most cases, the detection confidence values from this format are unbounded.
        While this is not a big problem and can still be used to generate statistics like PR- or MRFPPI-curves, you might want to normalize these values.
        You could normalize the results between 0-1 by using the following code, but make sure to check the detector that was used to use the correct normalization if necessary.

        >>> df = bb.io.load('anno_dollar', 'filename')
        >>> df.confidence = (df.confidence - df.confidence.min()) / (df.confidence.max() - df.confidence.min())

    .. _toolbox: https://github.com/pdollar/toolbox/blob/master/detector/bbGt.m
    """
    parser_type = ParserType.SINGLE_FILE
    extension = '.txt'

    def __init__(self, class_label=None, precision=0):
        super().__init__()
        self.precision = precision
        self.class_label = class_label

    def serialize(self, df):
        try:
            df.image = df.image.astype(int)
        except ValueError:
            log.warning('Could not convert image column to integers, using categorical codes')
            df.image = df.image.cat.codes

        if self.class_label is None:
            log.warning('No class_label kwarg passed, saving all boxes independent of class labels')
        else:
            df = df[df.class_label == self.class_label]

        result = ''
        for row in df.itertuples():
            result += f'{row.image},{round(row.x_top_left)},{round(row.y_top_left)},{round(row.width)},{round(row.height)},{round(row.confidence, self.precision)}\n'

        return result

    def deserialize(self, rawdata, file_id=None):
        if self.class_label is None:
            log.warning('No class_label kwarg passed, defaulting to "?"')
            class_label = '?'
        else:
            class_label = self.class_label

        for line in rawdata.splitlines():
            elements = line.split(',')
            self.append(
                str(int(elements[0])),
                class_label,
                float(elements[1]),
                float(elements[2]),
                float(elements[3]),
                float(elements[4]),
                confidence=float(elements[5]),
            )
