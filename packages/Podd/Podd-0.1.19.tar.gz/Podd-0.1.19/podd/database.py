"""Define the database API."""

import base64
import getpass
import html
import pathlib
import smtplib
import sqlite3
import typing as tp
from os import chmod
from types import TracebackType

import feedparser as fp
import keyring
import requests
from keyring.errors import KeyringError

from podd.logger import logger
from podd.settings import Config
from podd.utilities import date_handler, get_directory, get_credentials

fp.registerDateHandler(date_handler)


class Database:
    """
    Define database operations - Adding, removing, getting podcasts and episodes
    from the database, etc
    """

    def __init__(self, db_file: str = Config.database):
        self._db_file = db_file
        self._conn = sqlite3.connect(self._db_file)
        self._conn.execute("PRAGMA foreign_keys=ON")
        self.cursor = self._conn.cursor()
        self._logger = logger(f"{self.__class__.__name__}")

    def __enter__(self):
        """Context method."""
        return self

    def __exit__(self, exc_type, exc_val, exc_tb: TracebackType):
        """Context method.

        If there are exceptions, rolls back and calls logger
        :param exc_type: exception type
        :param exc_val:  exception value
        :param exc_tb: exception traceback
        :return: None
        """
        if exc_type is not None:
            self._conn.rollback()
            self._logger.error(exc_type, exc_val, exc_tb)

        else:
            self._conn.commit()
        self._conn.close()

    def __repr__(self):
        """`repr` method."""
        return f"{self.__class__.__name__}({self._db_file})"

    def add_podcast(self, name: str, url: str, directory: str, protected: bool) -> None:
        """Save podcast to database.

        :param name: podcast name
        :param url: rss feed url
        :param directory: directory to store this podcast's downloaded episodes
        :param protected: boolean, True if feed is protected, False otherwise.
        :return: None
        """
        self._logger.info(f"Adding {name} {url} at {directory}")
        self.cursor.executemany(
            "INSERT INTO podcasts (name, url, directory, protected) VALUES (?,?,?,?)",
            ((name, url, directory, protected),),
        )
        self._conn.commit()

    def remove_podcast(self, url: str) -> None:
        """Delete podcast and associated episodes from database.

        Deletes all episodes associated with rss feed URL, as well as podcast entry
        :param url: rss feed url
        :return: None
        """
        self.cursor.execute(
            "DELETE FROM episodes WHERE podcast_id IN"
            " (SELECT id FROM podcasts p WHERE p.url = ?)",
            (url,),
        )
        self.cursor.execute("DELETE FROM  podcasts WHERE url = ?", (url,))
        self._conn.commit()

    def get_podcasts(self) -> list:
        """Return list of podcasts.

        :return: list of tuples of podcast name, url and download directory
        """
        self.cursor.execute("SELECT name, url, directory, protected FROM main.podcasts")
        return self.cursor.fetchall()

    def add_episode(self, podcast_url: str, feed_id: str) -> None:
        """Save episode to database.

        :param podcast_url: RSS feed URL
        :param feed_id: id generated by rss feed for each episode
        :return: None
        """
        self.cursor.execute(
            "INSERT INTO episodes (feed_id, podcast_id) "
            "SELECT ?, id FROM main.podcasts WHERE url = ?",
            (feed_id, podcast_url),
        )
        self._conn.commit()

    def get_episodes(self, url: str) -> set:
        """Return episodes from a single podcast.

        :param url: rss feed url
        :return: dict of episode ids associated with url
        """
        self.cursor.execute(
            "SELECT feed_id FROM episodes "
            "JOIN podcasts p ON episodes.podcast_id = p.id AND p.url = ?",
            (url,),
        )
        return {item[0] for item in self.cursor.fetchall()}

    def get_options(self) -> tuple:
        """Return options.

        :return: tuple of currently set options
        """
        self.cursor.execute(
            "SELECT "
            "download_directory, "
            "notification_status, "
            "recipient_address FROM settings"
        )
        return self.cursor.fetchone()

    def get_credentials(self) -> tuple:
        """Return credentials.

        :return: tuple of sender_address, and recipient_address
        """
        self.cursor.execute(
            "SELECT sender_address, " "recipient_address from settings where id = 1"
        )
        sender, recipient = self.cursor.fetchone()
        try:
            password = keyring.get_password("podd", sender)
        except KeyringError:
            password = None
        return sender, password, recipient

    def change_option(self, option: str, value: str or int) -> None:
        """Save option changes to database.

        I know, I know, using a database query with an fstring is problematic,
        Ã  la bobby tables, but the user doesn't interact directly with the
        database with this or any other queries that use f-strings in queries.
        All values input by the user are parameterized, which mitigates the threat.
        Given what this application is and does, I'm not sure why any user would
        try to sql injection on a local db of which they have sole access.
        :param option: string, option to change
        :param value: string, option's new value
        :return: None
        """
        self.cursor.execute(f"UPDATE settings SET {option} = ? WHERE id = 1", (value,))
        self._conn.commit()
        self._logger.info(f"Changed {option} to {value}")


class Feed(Database):
    """Combine database and rss feed functionality.

    Contains methods for managing rss feeds, including adding and removing podcasts
    to database, viewing current subscription feeds, etc
    """

    def add(self, url, newest_only: bool = False) -> None:
        """Add podcast to database.

        Parses and validates rss feed urls, adds to database, creates
        download directory for each new feed added.
        :param newest_only: bool if set, only download newest episode, which is
          accomplished by adding all episodes, except for the newest, to the episode
          table in the database.
        :param url: rss feed url
        :return: None
        """
        try:
            feed, protected = self._parse_feed(url)
        except KeyringError as err:
            msg = "Unable to open keyring."
            self._logger.error(f"{msg} {err}")
            return print(msg)
        if not feed.entries:
            msg = f"No episodes at {url}"
            self._logger.warning(msg)
            return print(msg)

        dl_dir, *_ = self.get_options()
        podcast_name = html.unescape(feed.feed.title)
        podcast_dir = pathlib.Path(dl_dir).joinpath(podcast_name)
        try:
            self.add_podcast(
                name=podcast_name,
                url=feed.href,
                directory=str(podcast_dir),
                protected=protected,
            )
            if newest_only:
                self._new_podcast_only(feed=feed)
            podcast_dir.mkdir(parents=True, exist_ok=True)
            return print(f"{podcast_name} added")
        except sqlite3.IntegrityError:
            msg = f"{podcast_name} already in database."
            self._logger.warning(msg)
            return print(msg)

    def remove(self) -> None:
        """Define podcast deletion menu.

        Creates a simple podcast deletion menu.  Is interactive in order to be
        slightly more user-friendly.
        :return: None
        """
        podcasts = {i[0]: i[1] for i in enumerate(self.get_podcasts())}
        if not podcasts:
            return print("You have no subscriptions!")
        for num, podcast in podcasts.items():
            print(f"{num}: {podcast[0]}")
        try:
            choices = [int(i) for i in input("Podcast number(s) to remove: ").split()]
            for choice in choices:
                if choice not in podcasts:
                    print(f"Invalid option {choice}")
                else:
                    self.remove_podcast(podcasts[choice][1])
                    msg = f"Removed {podcasts[choice][0]}"
                    print(msg)
                    self._logger.info(msg)
        except ValueError:
            print("Invalid option, enter numbers only.")
        except KeyboardInterrupt:
            print("\nCanceled")

    def _parse_feed(self, url: str) -> tp.Tuple[fp.FeedParserDict, bool]:
        """Parse feed, return FeedParserDict of feed with boolean of protected status.

        In the case of protected feeds, get username and password for feed, store b64
        encoded username:password string using keyring.

        :raises KeyringError if unable to access keyring.
        """
        protected = False
        self._logger.info(f"Parsing {url}")
        resp = requests.get(url)
        auth_header = resp.headers.get("WWW-Authenticate")

        if resp.status_code == 401 and auth_header and "Basic" in auth_header:
            protected = True
            self._logger.debug(f"Basic auth detected for {url}")
            user, pw = get_credentials(
                "This feed is password protected.  Please enter your username "
                "and password."
            )
            encoded = base64.b64encode(f"{user}:{pw}".encode())
            headers = {"Authorization": b"Basic " + encoded}
            resp = requests.get(url, headers=headers)
            feed = fp.parse(resp.text)
            if resp.status_code == 200:  # Meaning credentials worked
                self._logger.debug(
                    f"Credentials successfully used to fetch url, saving encoded "
                    f"to keyring"
                )
                try:
                    keyring.set_password("podd", url, encoded)
                except KeyringError:
                    self._logger.error("Unable to open keyring to save credentials.")
                    raise
        else:
            feed = fp.parse(resp.content)
        feed.href = resp.url  # Requests follows redirects, have to store correct url
        return feed, protected

    def _new_podcast_only(self, feed: fp.FeedParserDict) -> None:
        """Add all episodes (Except for latest) to database.

        Used when adding a new podcast to the database.
        :param feed: FeedParserDict of a single feed
        :return: None
        """
        episodes = feed.entries
        first = episodes[0].published_parsed
        last = episodes[-1].published_parsed
        if first < last:  # Last is the latest episode, i.e., feed is reversed
            episodes = episodes[:-1]
            self._logger.debug(f"Reversed feed at {feed.href}")
        else:
            episodes = episodes[1:]
        for epi in episodes:
            self.add_episode(podcast_url=feed.href, feed_id=epi.id)

    def print_subscriptions(self) -> None:
        """
        Prints current subscriptions
        :return: None
        """
        subs = self.get_podcasts()
        if subs:
            print("----------Current subscriptions----------")
            for name, *_ in subs:
                print(name)
            print("-----------------------------------------")
        else:
            print("No active subscriptions.")


class Options(Database):
    """
    Contains methods to manage and view options stored in the database.
    """

    def toggle_notifications(self, value) -> None:
        """
        Turns email notifications on or off, depending upon supplied value
        :param value:
        :return:
        """
        valid = {"on": True, "off": False}
        if value not in valid:
            return print("Invalid option")
        sender, *_ = self.get_credentials()
        if sender == "" and value == "on":
            return print(
                "You need to enter a valid email address.  " "Run `podd email` first."
            )

        self.change_option("notification_status", valid[value])
        msg = f"Notifications turned {value}."
        print(msg)
        self._logger.info(msg)

    def email_notification_setup(self, initial_setup: bool = False) -> None:
        """Get and store email credentials.

        Get sender email address and password and recipient address

       :param initial_setup: bool if True, prints additional info
       :return: namedtuple of sender address and password and recipient address
       """

        def credential_validation() -> bool:
            """
            creates a simple smtp server and attempts to log in to server using the
            provided credentials
            :return: bool, True if login attempt was successful, False otherwise
            """
            try:
                server = smtplib.SMTP(host=Config.host, port=Config.port)
                server.starttls()
                status_code = server.login(user=sender_address, password=password)[0]
                server.quit()
                if status_code == 235:
                    return True
            except smtplib.SMTPAuthenticationError:
                pass
            except TimeoutError as err:
                print(err)
            return False

        if initial_setup:
            print("Looks like this is your first time running the program.")
            choice = input(
                "Would you like to enable email notifications? (y/n) "
            ).lower()
            if choice != "y":
                msg = "Email notifications disabled."
                print(msg)
                self._logger.info(msg)
                return
        print(
            "\nNote: if you are using a Gmail account for this purpose, you need \n"
            "to enable app-specific passwords and enter one you've generated, \n"
            "rather than your normal password.  This is somewhat risky, so it is\n"
            "advised that you do NOT use your main Gmail account for this purpose. \n"
            "See https://support.google.com/accounts/answer/185833?hl=en\n"
            "The default values in config.py use the ones provided by Gmail, \n"
            "if you choose to use a different email provider, replace them with the\n"
            "correct values.\n"
        )
        print("First, enter in the address you want to use to send notifications")
        try:
            sender_address = input("Email address: ")
            password = getpass.getpass("Password: ")
            print("Validating password...")
            if not credential_validation():
                msg = "Login attempt failed!  Bad credentials, or connection timeout."
                self._logger.warning(msg)
                print(msg)
                return
            msg = "Email authentication successful."
            self._logger.info(msg)
            print(msg)
            print("\nNow enter the recipient email address.")
            recipient_address = input("Email address: ")
            keyring.set_password("podd", sender_address, password)
            self.change_option("sender_address", sender_address)
            self.change_option("recipient_address", recipient_address)
            self.change_option("notification_status", True)
            msg = "Email notification enabled!"
            print(msg)
            self._logger.info(msg)
        except KeyboardInterrupt:
            print("\nCanceling")
            quit()

    def print_options(self) -> tuple:
        """
        Prints currently selected options
        :return: None
        """
        email_notification_status = {0: "Off", 1: "On"}
        download_directory, notification_status, recipient_address = self.get_options()
        print("-- Options --")
        print(f"Download Directory: {download_directory}")
        print(f"Email notifications: {email_notification_status[notification_status]}")
        if notification_status:
            print(f"Email notifications sent to: {recipient_address}")
        print(f"Database file: {self._db_file}")
        print("-------------")
        return download_directory, notification_status, recipient_address

    def set_directory_option(self, directory) -> bool:
        """
        Sets the base download directory, where each individual podcast
        download directory will be created
        :param directory: string, abs path to base download directory
        :return: None
        """
        try:
            pathlib.Path(directory).mkdir(exist_ok=True, parents=True)
            self.change_option("download_directory", directory)
            msg = f"Changed download directory to {directory}"
            print(msg)
            self._logger.info(msg)
            return True
        except PermissionError:
            pass
        msg = f"Unable to create download directory `{directory}`"
        print(msg)
        self._logger.warning(msg)
        return False


def bootstrap_app(database: str = Config.database) -> None:
    """Create database file, ask user for download and log directories, create said
     directories.
    :type database: str
    :param database: location of database file.  By default, it's in the same
    directory as `podd.settings`
    """

    # Look for database file
    for file in pathlib.Path(database).parent.iterdir():
        # If database file is found, return early
        if database == str(file):
            return
    # Otherwise, bootstrap application:

    # Define database structure
    with Options(database) as _db:
        cur = _db.cursor
        cur.execute(
            "CREATE TABLE IF NOT EXISTS podcasts "
            "(id INTEGER PRIMARY KEY, "
            "name TEXT, "
            "url TEXT UNIQUE, "
            "directory TEXT,"
            "protected BOOLEAN)"
        )
        cur.execute(
            "CREATE TABLE IF NOT EXISTS episodes "
            "(id INTEGER PRIMARY KEY, "
            "feed_id TEXT, "
            "podcast_id INTEGER NOT NULL,"
            "FOREIGN KEY (podcast_id) REFERENCES podcasts(id))"
        )
        cur.execute(
            "CREATE TABLE IF NOT EXISTS settings "
            "(id INTEGER PRIMARY KEY, "
            "download_directory TEXT,"
            "notification_status BOOLEAN,"
            "sender_address TEXT,"
            "recipient_address TEXT)"
        )
        # Ensure that log_dir exists
        Config.log_directory.mkdir(exist_ok=True, parents=True)
        # Get user input for where to put download directory, add to db
        dl_dir = get_directory(
            name="Download directory", default=pathlib.Path.home() / "Podcasts"
        )
        cur.execute(
            "INSERT INTO settings "
            "(download_directory, notification_status) "
            "VALUES (?,?)",
            (str(dl_dir), False),
        )
        # Do email notification setup.
        _db.email_notification_setup(initial_setup=True)
    chmod(database, 0o600)


def migrate_db(database=Config.database) -> None:
    """Add `protected` column to existing databases."""
    try:
        with Database(database) as _db:
            columns = []
            for column in _db.cursor.execute('PRAGMA TABLE_INFO("%s")' % 'podcasts').fetchall():
                _, name, *_ = column
                columns.append(name)
            if 'protected' not in columns:
                _db.cursor.execute("ALTER TABLE podcasts ADD COLUMN protected BOOLEAN")
                _db._logger.debug('Migrated database: added `protected` column.')
    except sqlite3.OperationalError:
        pass
