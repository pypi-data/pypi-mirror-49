Metadata-Version: 2.1
Name: py-aiger-dfa
Version: 0.1.1
Summary: Library for moving between sequential circuits AIGs and DFAs.
Home-page: https://github.com/mvcisback/py-aiger-dfa
License: MIT
Author: Marcell Vazquez-Chanlatte
Author-email: mvc@linux.com
Requires-Python: >=3.7,<4.0
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.7
Requires-Dist: attrs (>=19.1,<20.0)
Requires-Dist: bidict (>=0.18.0,<0.19.0)
Requires-Dist: dfa (>=0.3.2,<0.4.0)
Requires-Dist: funcy (>=1.12,<2.0)
Requires-Dist: py-aiger (>=3.3,<4.0)
Requires-Dist: py-aiger-bv (>=0.5.4,<0.6.0)
Project-URL: Repository, https://github.com/mvcisback/py-aiger-dfa
Description-Content-Type: text/markdown

# py-aiger-dfa
Python library for converting between AIG circuits and DFAs.

[![Build Status](https://cloud.drone.io/api/badges/mvcisback/py-aiger-dfa/status.svg)](https://cloud.drone.io/mvcisback/py-aiger-dfa)
[![codecov](https://codecov.io/gh/mvcisback/py-aiger-dfa/branch/master/graph/badge.svg)](https://codecov.io/gh/mvcisback/py-aiger-dfa)
[![PyPI version](https://badge.fury.io/py/py-aiger-dfa.svg)](https://badge.fury.io/py/lstar)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

# Installation

If you just need to use `aiger_dfa`, you can just run:

`$ pip install py-aiger-dfa`

For developers, note that this project uses the
[poetry](https://poetry.eustace.io/) python package/dependency
management tool. Please familarize yourself with it and then
run:

`$ poetry install`

# Usage

The main entry points for using this library are the `dfa2aig` and
`aig2dfa` functions. DFAs are represented using the
[dfa](https://github.com/mvcisback/dfa) package. Familiarity with the
`dfa`, `py-aiger`, and `py-aiger-bv` packages is assumed.


## DFA to AIG

An example of going from a `DFA` to an `AIG` object
is shown below.

```python
from dfa import DFA
from aiger_dfa import aig2dfa, dfa2aig

my_dfa = DFA(
    start=0,
    inputs={0, 1},
    label=lambda s: (s % 4) == 3,
    transition=lambda s, c: (s + c) % 4,
)
my_aig, relabels = dfa2aig(my_dfa)
```

Now `circ` is an `AIG` and `relabels` is a mapping from the inputs,
states, and outputs of `my_dfa` to their **1-hot** encoded
counterparts in `my_aig`.

## AIG to DFA

TODO

