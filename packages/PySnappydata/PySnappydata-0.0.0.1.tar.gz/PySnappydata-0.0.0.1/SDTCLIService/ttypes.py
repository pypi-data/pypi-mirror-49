#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class SnappyType(object):
    BOOLEAN = 1
    TINYINT = 2
    SMALLINT = 3
    INTEGER = 4
    BIGINT = 5
    FLOAT = 6
    DOUBLE = 7
    DECIMAL = 8
    CHAR = 9
    VARCHAR = 10
    LONGVARCHAR = 11
    DATE = 12
    TIME = 13
    TIMESTAMP = 14
    BINARY = 15
    VARBINARY = 16
    LONGVARBINARY = 17
    BLOB = 18
    CLOB = 19
    SQLXML = 20
    ARRAY = 21
    MAP = 22
    STRUCT = 23
    NULLTYPE = 24
    JSON = 25
    JAVA_OBJECT = 26
    OTHER = 27

    _VALUES_TO_NAMES = {
        1: "BOOLEAN",
        2: "TINYINT",
        3: "SMALLINT",
        4: "INTEGER",
        5: "BIGINT",
        6: "FLOAT",
        7: "DOUBLE",
        8: "DECIMAL",
        9: "CHAR",
        10: "VARCHAR",
        11: "LONGVARCHAR",
        12: "DATE",
        13: "TIME",
        14: "TIMESTAMP",
        15: "BINARY",
        16: "VARBINARY",
        17: "LONGVARBINARY",
        18: "BLOB",
        19: "CLOB",
        20: "SQLXML",
        21: "ARRAY",
        22: "MAP",
        23: "STRUCT",
        24: "NULLTYPE",
        25: "JSON",
        26: "JAVA_OBJECT",
        27: "OTHER",
    }

    _NAMES_TO_VALUES = {
        "BOOLEAN": 1,
        "TINYINT": 2,
        "SMALLINT": 3,
        "INTEGER": 4,
        "BIGINT": 5,
        "FLOAT": 6,
        "DOUBLE": 7,
        "DECIMAL": 8,
        "CHAR": 9,
        "VARCHAR": 10,
        "LONGVARCHAR": 11,
        "DATE": 12,
        "TIME": 13,
        "TIMESTAMP": 14,
        "BINARY": 15,
        "VARBINARY": 16,
        "LONGVARBINARY": 17,
        "BLOB": 18,
        "CLOB": 19,
        "SQLXML": 20,
        "ARRAY": 21,
        "MAP": 22,
        "STRUCT": 23,
        "NULLTYPE": 24,
        "JSON": 25,
        "JAVA_OBJECT": 26,
        "OTHER": 27,
    }


class TransactionAttribute(object):
    AUTOCOMMIT = 1
    READ_ONLY_CONNECTION = 2
    WAITING_MODE = 3
    DISABLE_BATCHING = 4
    SYNC_COMMITS = 5

    _VALUES_TO_NAMES = {
        1: "AUTOCOMMIT",
        2: "READ_ONLY_CONNECTION",
        3: "WAITING_MODE",
        4: "DISABLE_BATCHING",
        5: "SYNC_COMMITS",
    }

    _NAMES_TO_VALUES = {
        "AUTOCOMMIT": 1,
        "READ_ONLY_CONNECTION": 2,
        "WAITING_MODE": 3,
        "DISABLE_BATCHING": 4,
        "SYNC_COMMITS": 5,
    }


class RowIdLifetime(object):
    ROWID_UNSUPPORTED = 1
    ROWID_VALID_OTHER = 2
    ROWID_VALID_SESSION = 3
    ROWID_VALID_TRANSACTION = 4
    ROWID_VALID_FOREVER = 5

    _VALUES_TO_NAMES = {
        1: "ROWID_UNSUPPORTED",
        2: "ROWID_VALID_OTHER",
        3: "ROWID_VALID_SESSION",
        4: "ROWID_VALID_TRANSACTION",
        5: "ROWID_VALID_FOREVER",
    }

    _NAMES_TO_VALUES = {
        "ROWID_UNSUPPORTED": 1,
        "ROWID_VALID_OTHER": 2,
        "ROWID_VALID_SESSION": 3,
        "ROWID_VALID_TRANSACTION": 4,
        "ROWID_VALID_FOREVER": 5,
    }


class ServiceFeature(object):
    ALL_PROCEDURES_CALLABLE = 1
    ALL_TABLES_SELECTABLE = 2
    INTEGRITY_ENHANCEMENT = 3
    NULLS_SORTED_HIGH = 4
    NULLS_SORTED_LOW = 5
    NULLS_SORTED_START = 6
    NULLS_SORTED_END = 7
    USES_LOCAL_FILES = 8
    USES_LOCAL_FILE_PER_TABLE = 9
    MIXEDCASE_IDENTIFIERS = 10
    MIXEDCASE_QUOTED_IDENTIFIERS = 11
    STORES_UPPERCASE_IDENTIFIERS = 12
    STORES_LOWERCASE_IDENTIFIERS = 13
    STORES_MIXEDCASE_IDENTIFIERS = 14
    STORES_UPPERCASE_QUOTED_IDENTIFIERS = 15
    STORES_LOWERCASE_QUOTED_IDENTIFIERS = 16
    STORES_MIXEDCASE_QUOTED_IDENTIFIERS = 17
    ALTER_TABLE_ADD_COLUMN = 18
    ALTER_TABLE_DROP_COLUMN = 19
    COLUMN_ALIASING = 20
    NULL_CONCAT_NON_NULL_IS_NULL = 21
    CONVERT = 22
    TABLE_CORRELATION_NAMES = 23
    TABLE_CORRELATION_NAMES_DIFFERENT = 24
    ORDER_BY_EXPRESSIONS = 25
    ORDER_BY_UNRELATED = 26
    GROUP_BY = 27
    GROUP_BY_UNRELATED = 28
    GROUP_BY_BEYOND_SELECT = 29
    LIKE_ESCAPE = 30
    MULTIPLE_RESULTSETS = 31
    MULTIPLE_TRANSACTIONS = 32
    NON_NULLABLE_COLUMNS = 33
    SQL_GRAMMAR_MINIMUM = 34
    SQL_GRAMMAR_CORE = 35
    SQL_GRAMMAR_EXTENDED = 36
    SQL_GRAMMAR_ANSI92_ENTRY = 37
    SQL_GRAMMAR_ANSI92_INTERMEDIATE = 38
    SQL_GRAMMAR_ANSI92_FULL = 39
    OUTER_JOINS = 40
    OUTER_JOINS_FULL = 41
    OUTER_JOINS_LIMITED = 42
    SCHEMAS_IN_DMLS = 43
    SCHEMAS_IN_PROCEDURE_CALLS = 44
    SCHEMAS_IN_TABLE_DEFS = 45
    SCHEMAS_IN_INDEX_DEFS = 46
    SCHEMAS_IN_PRIVILEGE_DEFS = 47
    AUTOCOMMIT_FAILURE_CLOSES_ALL_RESULTSETS = 48
    CATALOGS_IN_DMLS = 49
    CATALOGS_IN_PROCEDURE_CALLS = 50
    CATALOGS_IN_TABLE_DEFS = 51
    CATALOGS_IN_INDEX_DEFS = 52
    CATALOGS_IN_PRIVILEGE_DEFS = 53
    POSITIONED_DELETE = 54
    POSITIONED_UPDATE = 55
    SELECT_FOR_UPDATE = 56
    STORED_PROCEDURES = 57
    SUBQUERIES_IN_COMPARISONS = 58
    SUBQUERIES_IN_EXISTS = 59
    SUBQUERIES_IN_INS = 60
    SUBQUERIES_IN_QUANTIFIEDS = 61
    SUBQUERIES_CORRELATED = 62
    UNION = 63
    UNION_ALL = 64
    OPEN_CURSORS_ACROSS_COMMIT = 65
    OPEN_CURSORS_ACROSS_ROLLBACK = 66
    OPEN_STATEMENTS_ACROSS_COMMIT = 67
    OPEN_STATEMENTS_ACROSS_ROLLBACK = 68
    MAX_ROWSIZE_INCLUDES_BLOBSIZE = 69
    TRANSACTIONS = 70
    TRANSACTIONS_BOTH_DMLS_AND_DDLS = 71
    TRANSACTIONS_DMLS_ONLY = 72
    TRANSACTIONS_DDLS_IMPLICIT_COMMIT = 73
    TRANSACTIONS_DDLS_IGNORED = 74
    TRANSACTIONS_SAVEPOINTS = 75
    CALLABLE_NAMED_PARAMETERS = 76
    CALLABLE_MULTIPLE_OPEN_RESULTSETS = 77
    GENERATED_KEYS_RETRIEVAL = 78
    GENERATED_KEYS_ALWAYS_RETURNED = 79
    BATCH_UPDATES = 80
    RESULTSET_FORWARD_ONLY = 81
    RESULTSET_SCROLL_INSENSITIVE = 82
    RESULTSET_SCROLL_SENSITIVE = 83
    RESULTSET_HOLDABILITY_CLOSE_CURSORS_AT_COMMIT = 84
    RESULTSET_HOLDABILITY_HOLD_CURSORS_OVER_COMMIT = 85
    LOB_UPDATES_COPY = 86
    STATEMENT_POOLING = 87
    STORED_FUNCTIONS_USING_CALL = 88

    _VALUES_TO_NAMES = {
        1: "ALL_PROCEDURES_CALLABLE",
        2: "ALL_TABLES_SELECTABLE",
        3: "INTEGRITY_ENHANCEMENT",
        4: "NULLS_SORTED_HIGH",
        5: "NULLS_SORTED_LOW",
        6: "NULLS_SORTED_START",
        7: "NULLS_SORTED_END",
        8: "USES_LOCAL_FILES",
        9: "USES_LOCAL_FILE_PER_TABLE",
        10: "MIXEDCASE_IDENTIFIERS",
        11: "MIXEDCASE_QUOTED_IDENTIFIERS",
        12: "STORES_UPPERCASE_IDENTIFIERS",
        13: "STORES_LOWERCASE_IDENTIFIERS",
        14: "STORES_MIXEDCASE_IDENTIFIERS",
        15: "STORES_UPPERCASE_QUOTED_IDENTIFIERS",
        16: "STORES_LOWERCASE_QUOTED_IDENTIFIERS",
        17: "STORES_MIXEDCASE_QUOTED_IDENTIFIERS",
        18: "ALTER_TABLE_ADD_COLUMN",
        19: "ALTER_TABLE_DROP_COLUMN",
        20: "COLUMN_ALIASING",
        21: "NULL_CONCAT_NON_NULL_IS_NULL",
        22: "CONVERT",
        23: "TABLE_CORRELATION_NAMES",
        24: "TABLE_CORRELATION_NAMES_DIFFERENT",
        25: "ORDER_BY_EXPRESSIONS",
        26: "ORDER_BY_UNRELATED",
        27: "GROUP_BY",
        28: "GROUP_BY_UNRELATED",
        29: "GROUP_BY_BEYOND_SELECT",
        30: "LIKE_ESCAPE",
        31: "MULTIPLE_RESULTSETS",
        32: "MULTIPLE_TRANSACTIONS",
        33: "NON_NULLABLE_COLUMNS",
        34: "SQL_GRAMMAR_MINIMUM",
        35: "SQL_GRAMMAR_CORE",
        36: "SQL_GRAMMAR_EXTENDED",
        37: "SQL_GRAMMAR_ANSI92_ENTRY",
        38: "SQL_GRAMMAR_ANSI92_INTERMEDIATE",
        39: "SQL_GRAMMAR_ANSI92_FULL",
        40: "OUTER_JOINS",
        41: "OUTER_JOINS_FULL",
        42: "OUTER_JOINS_LIMITED",
        43: "SCHEMAS_IN_DMLS",
        44: "SCHEMAS_IN_PROCEDURE_CALLS",
        45: "SCHEMAS_IN_TABLE_DEFS",
        46: "SCHEMAS_IN_INDEX_DEFS",
        47: "SCHEMAS_IN_PRIVILEGE_DEFS",
        48: "AUTOCOMMIT_FAILURE_CLOSES_ALL_RESULTSETS",
        49: "CATALOGS_IN_DMLS",
        50: "CATALOGS_IN_PROCEDURE_CALLS",
        51: "CATALOGS_IN_TABLE_DEFS",
        52: "CATALOGS_IN_INDEX_DEFS",
        53: "CATALOGS_IN_PRIVILEGE_DEFS",
        54: "POSITIONED_DELETE",
        55: "POSITIONED_UPDATE",
        56: "SELECT_FOR_UPDATE",
        57: "STORED_PROCEDURES",
        58: "SUBQUERIES_IN_COMPARISONS",
        59: "SUBQUERIES_IN_EXISTS",
        60: "SUBQUERIES_IN_INS",
        61: "SUBQUERIES_IN_QUANTIFIEDS",
        62: "SUBQUERIES_CORRELATED",
        63: "UNION",
        64: "UNION_ALL",
        65: "OPEN_CURSORS_ACROSS_COMMIT",
        66: "OPEN_CURSORS_ACROSS_ROLLBACK",
        67: "OPEN_STATEMENTS_ACROSS_COMMIT",
        68: "OPEN_STATEMENTS_ACROSS_ROLLBACK",
        69: "MAX_ROWSIZE_INCLUDES_BLOBSIZE",
        70: "TRANSACTIONS",
        71: "TRANSACTIONS_BOTH_DMLS_AND_DDLS",
        72: "TRANSACTIONS_DMLS_ONLY",
        73: "TRANSACTIONS_DDLS_IMPLICIT_COMMIT",
        74: "TRANSACTIONS_DDLS_IGNORED",
        75: "TRANSACTIONS_SAVEPOINTS",
        76: "CALLABLE_NAMED_PARAMETERS",
        77: "CALLABLE_MULTIPLE_OPEN_RESULTSETS",
        78: "GENERATED_KEYS_RETRIEVAL",
        79: "GENERATED_KEYS_ALWAYS_RETURNED",
        80: "BATCH_UPDATES",
        81: "RESULTSET_FORWARD_ONLY",
        82: "RESULTSET_SCROLL_INSENSITIVE",
        83: "RESULTSET_SCROLL_SENSITIVE",
        84: "RESULTSET_HOLDABILITY_CLOSE_CURSORS_AT_COMMIT",
        85: "RESULTSET_HOLDABILITY_HOLD_CURSORS_OVER_COMMIT",
        86: "LOB_UPDATES_COPY",
        87: "STATEMENT_POOLING",
        88: "STORED_FUNCTIONS_USING_CALL",
    }

    _NAMES_TO_VALUES = {
        "ALL_PROCEDURES_CALLABLE": 1,
        "ALL_TABLES_SELECTABLE": 2,
        "INTEGRITY_ENHANCEMENT": 3,
        "NULLS_SORTED_HIGH": 4,
        "NULLS_SORTED_LOW": 5,
        "NULLS_SORTED_START": 6,
        "NULLS_SORTED_END": 7,
        "USES_LOCAL_FILES": 8,
        "USES_LOCAL_FILE_PER_TABLE": 9,
        "MIXEDCASE_IDENTIFIERS": 10,
        "MIXEDCASE_QUOTED_IDENTIFIERS": 11,
        "STORES_UPPERCASE_IDENTIFIERS": 12,
        "STORES_LOWERCASE_IDENTIFIERS": 13,
        "STORES_MIXEDCASE_IDENTIFIERS": 14,
        "STORES_UPPERCASE_QUOTED_IDENTIFIERS": 15,
        "STORES_LOWERCASE_QUOTED_IDENTIFIERS": 16,
        "STORES_MIXEDCASE_QUOTED_IDENTIFIERS": 17,
        "ALTER_TABLE_ADD_COLUMN": 18,
        "ALTER_TABLE_DROP_COLUMN": 19,
        "COLUMN_ALIASING": 20,
        "NULL_CONCAT_NON_NULL_IS_NULL": 21,
        "CONVERT": 22,
        "TABLE_CORRELATION_NAMES": 23,
        "TABLE_CORRELATION_NAMES_DIFFERENT": 24,
        "ORDER_BY_EXPRESSIONS": 25,
        "ORDER_BY_UNRELATED": 26,
        "GROUP_BY": 27,
        "GROUP_BY_UNRELATED": 28,
        "GROUP_BY_BEYOND_SELECT": 29,
        "LIKE_ESCAPE": 30,
        "MULTIPLE_RESULTSETS": 31,
        "MULTIPLE_TRANSACTIONS": 32,
        "NON_NULLABLE_COLUMNS": 33,
        "SQL_GRAMMAR_MINIMUM": 34,
        "SQL_GRAMMAR_CORE": 35,
        "SQL_GRAMMAR_EXTENDED": 36,
        "SQL_GRAMMAR_ANSI92_ENTRY": 37,
        "SQL_GRAMMAR_ANSI92_INTERMEDIATE": 38,
        "SQL_GRAMMAR_ANSI92_FULL": 39,
        "OUTER_JOINS": 40,
        "OUTER_JOINS_FULL": 41,
        "OUTER_JOINS_LIMITED": 42,
        "SCHEMAS_IN_DMLS": 43,
        "SCHEMAS_IN_PROCEDURE_CALLS": 44,
        "SCHEMAS_IN_TABLE_DEFS": 45,
        "SCHEMAS_IN_INDEX_DEFS": 46,
        "SCHEMAS_IN_PRIVILEGE_DEFS": 47,
        "AUTOCOMMIT_FAILURE_CLOSES_ALL_RESULTSETS": 48,
        "CATALOGS_IN_DMLS": 49,
        "CATALOGS_IN_PROCEDURE_CALLS": 50,
        "CATALOGS_IN_TABLE_DEFS": 51,
        "CATALOGS_IN_INDEX_DEFS": 52,
        "CATALOGS_IN_PRIVILEGE_DEFS": 53,
        "POSITIONED_DELETE": 54,
        "POSITIONED_UPDATE": 55,
        "SELECT_FOR_UPDATE": 56,
        "STORED_PROCEDURES": 57,
        "SUBQUERIES_IN_COMPARISONS": 58,
        "SUBQUERIES_IN_EXISTS": 59,
        "SUBQUERIES_IN_INS": 60,
        "SUBQUERIES_IN_QUANTIFIEDS": 61,
        "SUBQUERIES_CORRELATED": 62,
        "UNION": 63,
        "UNION_ALL": 64,
        "OPEN_CURSORS_ACROSS_COMMIT": 65,
        "OPEN_CURSORS_ACROSS_ROLLBACK": 66,
        "OPEN_STATEMENTS_ACROSS_COMMIT": 67,
        "OPEN_STATEMENTS_ACROSS_ROLLBACK": 68,
        "MAX_ROWSIZE_INCLUDES_BLOBSIZE": 69,
        "TRANSACTIONS": 70,
        "TRANSACTIONS_BOTH_DMLS_AND_DDLS": 71,
        "TRANSACTIONS_DMLS_ONLY": 72,
        "TRANSACTIONS_DDLS_IMPLICIT_COMMIT": 73,
        "TRANSACTIONS_DDLS_IGNORED": 74,
        "TRANSACTIONS_SAVEPOINTS": 75,
        "CALLABLE_NAMED_PARAMETERS": 76,
        "CALLABLE_MULTIPLE_OPEN_RESULTSETS": 77,
        "GENERATED_KEYS_RETRIEVAL": 78,
        "GENERATED_KEYS_ALWAYS_RETURNED": 79,
        "BATCH_UPDATES": 80,
        "RESULTSET_FORWARD_ONLY": 81,
        "RESULTSET_SCROLL_INSENSITIVE": 82,
        "RESULTSET_SCROLL_SENSITIVE": 83,
        "RESULTSET_HOLDABILITY_CLOSE_CURSORS_AT_COMMIT": 84,
        "RESULTSET_HOLDABILITY_HOLD_CURSORS_OVER_COMMIT": 85,
        "LOB_UPDATES_COPY": 86,
        "STATEMENT_POOLING": 87,
        "STORED_FUNCTIONS_USING_CALL": 88,
    }


class ServiceFeatureParameterized(object):
    TRANSACTIONS_SUPPORT_ISOLATION = 1
    RESULTSET_TYPE = 2
    RESULTSET_CONCURRENCY_READ_ONLY = 3
    RESULTSET_CONCURRENCY_UPDATABLE = 4
    RESULTSET_OWN_UPDATES_VISIBLE = 5
    RESULTSET_OWN_DELETES_VISIBLE = 6
    RESULTSET_OWN_INSERTS_VISIBLE = 7
    RESULTSET_OTHERS_UPDATES_VISIBLE = 8
    RESULTSET_OTHERS_DELETES_VISIBLE = 9
    RESULTSET_OTHERS_INSERTS_VISIBLE = 10
    RESULTSET_UPDATES_DETECTED = 11
    RESULTSET_DELETES_DETECTED = 12
    RESULTSET_INSERTS_DETECTED = 13

    _VALUES_TO_NAMES = {
        1: "TRANSACTIONS_SUPPORT_ISOLATION",
        2: "RESULTSET_TYPE",
        3: "RESULTSET_CONCURRENCY_READ_ONLY",
        4: "RESULTSET_CONCURRENCY_UPDATABLE",
        5: "RESULTSET_OWN_UPDATES_VISIBLE",
        6: "RESULTSET_OWN_DELETES_VISIBLE",
        7: "RESULTSET_OWN_INSERTS_VISIBLE",
        8: "RESULTSET_OTHERS_UPDATES_VISIBLE",
        9: "RESULTSET_OTHERS_DELETES_VISIBLE",
        10: "RESULTSET_OTHERS_INSERTS_VISIBLE",
        11: "RESULTSET_UPDATES_DETECTED",
        12: "RESULTSET_DELETES_DETECTED",
        13: "RESULTSET_INSERTS_DETECTED",
    }

    _NAMES_TO_VALUES = {
        "TRANSACTIONS_SUPPORT_ISOLATION": 1,
        "RESULTSET_TYPE": 2,
        "RESULTSET_CONCURRENCY_READ_ONLY": 3,
        "RESULTSET_CONCURRENCY_UPDATABLE": 4,
        "RESULTSET_OWN_UPDATES_VISIBLE": 5,
        "RESULTSET_OWN_DELETES_VISIBLE": 6,
        "RESULTSET_OWN_INSERTS_VISIBLE": 7,
        "RESULTSET_OTHERS_UPDATES_VISIBLE": 8,
        "RESULTSET_OTHERS_DELETES_VISIBLE": 9,
        "RESULTSET_OTHERS_INSERTS_VISIBLE": 10,
        "RESULTSET_UPDATES_DETECTED": 11,
        "RESULTSET_DELETES_DETECTED": 12,
        "RESULTSET_INSERTS_DETECTED": 13,
    }


class ServiceMetaDataCall(object):
    CATALOGS = 1
    SCHEMAS = 2
    TABLES = 3
    TABLETYPES = 4
    COLUMNS = 5
    TABLEPRIVILEGES = 6
    COLUMNPRIVILEGES = 7
    PRIMARYKEYS = 8
    IMPORTEDKEYS = 9
    EXPORTEDKEYS = 10
    CROSSREFERENCE = 11
    PROCEDURES = 12
    FUNCTIONS = 13
    PROCEDURECOLUMNS = 14
    FUNCTIONCOLUMNS = 15
    ATTRIBUTES = 16
    TYPEINFO = 17
    SUPERTYPES = 18
    SUPERTABLES = 19
    VERSIONCOLUMNS = 20
    CLIENTINFOPROPS = 21
    PSEUDOCOLUMNS = 22

    _VALUES_TO_NAMES = {
        1: "CATALOGS",
        2: "SCHEMAS",
        3: "TABLES",
        4: "TABLETYPES",
        5: "COLUMNS",
        6: "TABLEPRIVILEGES",
        7: "COLUMNPRIVILEGES",
        8: "PRIMARYKEYS",
        9: "IMPORTEDKEYS",
        10: "EXPORTEDKEYS",
        11: "CROSSREFERENCE",
        12: "PROCEDURES",
        13: "FUNCTIONS",
        14: "PROCEDURECOLUMNS",
        15: "FUNCTIONCOLUMNS",
        16: "ATTRIBUTES",
        17: "TYPEINFO",
        18: "SUPERTYPES",
        19: "SUPERTABLES",
        20: "VERSIONCOLUMNS",
        21: "CLIENTINFOPROPS",
        22: "PSEUDOCOLUMNS",
    }

    _NAMES_TO_VALUES = {
        "CATALOGS": 1,
        "SCHEMAS": 2,
        "TABLES": 3,
        "TABLETYPES": 4,
        "COLUMNS": 5,
        "TABLEPRIVILEGES": 6,
        "COLUMNPRIVILEGES": 7,
        "PRIMARYKEYS": 8,
        "IMPORTEDKEYS": 9,
        "EXPORTEDKEYS": 10,
        "CROSSREFERENCE": 11,
        "PROCEDURES": 12,
        "FUNCTIONS": 13,
        "PROCEDURECOLUMNS": 14,
        "FUNCTIONCOLUMNS": 15,
        "ATTRIBUTES": 16,
        "TYPEINFO": 17,
        "SUPERTYPES": 18,
        "SUPERTABLES": 19,
        "VERSIONCOLUMNS": 20,
        "CLIENTINFOPROPS": 21,
        "PSEUDOCOLUMNS": 22,
    }


class SecurityMechanism(object):
    PLAIN = 1
    DIFFIE_HELLMAN = 2

    _VALUES_TO_NAMES = {
        1: "PLAIN",
        2: "DIFFIE_HELLMAN",
    }

    _NAMES_TO_VALUES = {
        "PLAIN": 1,
        "DIFFIE_HELLMAN": 2,
    }


class ServerType(object):
    DRDA = 1
    THRIFT_LOCATOR_CP = 2
    THRIFT_LOCATOR_BP = 3
    THRIFT_LOCATOR_CP_SSL = 4
    THRIFT_LOCATOR_BP_SSL = 5
    THRIFT_SNAPPY_CP = 6
    THRIFT_SNAPPY_BP = 7
    THRIFT_SNAPPY_CP_SSL = 8
    THRIFT_SNAPPY_BP_SSL = 9

    _VALUES_TO_NAMES = {
        1: "DRDA",
        2: "THRIFT_LOCATOR_CP",
        3: "THRIFT_LOCATOR_BP",
        4: "THRIFT_LOCATOR_CP_SSL",
        5: "THRIFT_LOCATOR_BP_SSL",
        6: "THRIFT_SNAPPY_CP",
        7: "THRIFT_SNAPPY_BP",
        8: "THRIFT_SNAPPY_CP_SSL",
        9: "THRIFT_SNAPPY_BP_SSL",
    }

    _NAMES_TO_VALUES = {
        "DRDA": 1,
        "THRIFT_LOCATOR_CP": 2,
        "THRIFT_LOCATOR_BP": 3,
        "THRIFT_LOCATOR_CP_SSL": 4,
        "THRIFT_LOCATOR_BP_SSL": 5,
        "THRIFT_SNAPPY_CP": 6,
        "THRIFT_SNAPPY_BP": 7,
        "THRIFT_SNAPPY_CP_SSL": 8,
        "THRIFT_SNAPPY_BP_SSL": 9,
    }


class CursorUpdateOperation(object):
    UPDATE_OP = 1
    INSERT_OP = 2
    DELETE_OP = 3

    _VALUES_TO_NAMES = {
        1: "UPDATE_OP",
        2: "INSERT_OP",
        3: "DELETE_OP",
    }

    _NAMES_TO_VALUES = {
        "UPDATE_OP": 1,
        "INSERT_OP": 2,
        "DELETE_OP": 3,
    }


class Decimal(object):
    """
    Attributes:
     - signum
     - scale
     - magnitude
    """


    def __init__(self, signum=None, scale=None, magnitude=None,):
        self.signum = signum
        self.scale = scale
        self.magnitude = magnitude

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.signum = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.scale = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.magnitude = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Decimal')
        if self.signum is not None:
            oprot.writeFieldBegin('signum', TType.BYTE, 1)
            oprot.writeByte(self.signum)
            oprot.writeFieldEnd()
        if self.scale is not None:
            oprot.writeFieldBegin('scale', TType.I32, 2)
            oprot.writeI32(self.scale)
            oprot.writeFieldEnd()
        if self.magnitude is not None:
            oprot.writeFieldBegin('magnitude', TType.STRING, 3)
            oprot.writeBinary(self.magnitude)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.signum is None:
            raise TProtocolException(message='Required field signum is unset!')
        if self.scale is None:
            raise TProtocolException(message='Required field scale is unset!')
        if self.magnitude is None:
            raise TProtocolException(message='Required field magnitude is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BlobChunk(object):
    """
    Attributes:
     - chunk
     - last
     - lobId
     - offset
     - totalLength
    """


    def __init__(self, chunk=None, last=None, lobId=None, offset=None, totalLength=None,):
        self.chunk = chunk
        self.last = last
        self.lobId = lobId
        self.offset = offset
        self.totalLength = totalLength

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.chunk = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.last = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.lobId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.totalLength = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BlobChunk')
        if self.chunk is not None:
            oprot.writeFieldBegin('chunk', TType.STRING, 1)
            oprot.writeBinary(self.chunk)
            oprot.writeFieldEnd()
        if self.last is not None:
            oprot.writeFieldBegin('last', TType.BOOL, 2)
            oprot.writeBool(self.last)
            oprot.writeFieldEnd()
        if self.lobId is not None:
            oprot.writeFieldBegin('lobId', TType.I64, 3)
            oprot.writeI64(self.lobId)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 4)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.totalLength is not None:
            oprot.writeFieldBegin('totalLength', TType.I64, 5)
            oprot.writeI64(self.totalLength)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.chunk is None:
            raise TProtocolException(message='Required field chunk is unset!')
        if self.last is None:
            raise TProtocolException(message='Required field last is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ClobChunk(object):
    """
    Attributes:
     - chunk
     - last
     - lobId
     - offset
     - totalLength
    """


    def __init__(self, chunk=None, last=None, lobId=None, offset=None, totalLength=None,):
        self.chunk = chunk
        self.last = last
        self.lobId = lobId
        self.offset = offset
        self.totalLength = totalLength

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.chunk = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.last = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.lobId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.totalLength = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ClobChunk')
        if self.chunk is not None:
            oprot.writeFieldBegin('chunk', TType.STRING, 1)
            oprot.writeString(self.chunk.encode('utf-8') if sys.version_info[0] == 2 else self.chunk)
            oprot.writeFieldEnd()
        if self.last is not None:
            oprot.writeFieldBegin('last', TType.BOOL, 2)
            oprot.writeBool(self.last)
            oprot.writeFieldEnd()
        if self.lobId is not None:
            oprot.writeFieldBegin('lobId', TType.I64, 3)
            oprot.writeI64(self.lobId)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 4)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.totalLength is not None:
            oprot.writeFieldBegin('totalLength', TType.I64, 5)
            oprot.writeI64(self.totalLength)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.chunk is None:
            raise TProtocolException(message='Required field chunk is unset!')
        if self.last is None:
            raise TProtocolException(message='Required field last is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TransactionXid(object):
    """
    Attributes:
     - formatId
     - globalId
     - branchQualifier
    """


    def __init__(self, formatId=None, globalId=None, branchQualifier=None,):
        self.formatId = formatId
        self.globalId = globalId
        self.branchQualifier = branchQualifier

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.formatId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.globalId = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.branchQualifier = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TransactionXid')
        if self.formatId is not None:
            oprot.writeFieldBegin('formatId', TType.I32, 1)
            oprot.writeI32(self.formatId)
            oprot.writeFieldEnd()
        if self.globalId is not None:
            oprot.writeFieldBegin('globalId', TType.STRING, 2)
            oprot.writeBinary(self.globalId)
            oprot.writeFieldEnd()
        if self.branchQualifier is not None:
            oprot.writeFieldBegin('branchQualifier', TType.STRING, 3)
            oprot.writeBinary(self.branchQualifier)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.formatId is None:
            raise TProtocolException(message='Required field formatId is unset!')
        if self.globalId is None:
            raise TProtocolException(message='Required field globalId is unset!')
        if self.branchQualifier is None:
            raise TProtocolException(message='Required field branchQualifier is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ServiceMetaData(object):
    """
    Attributes:
     - productName
     - productVersion
     - productMajorVersion
     - productMinorVersion
     - jdbcMajorVersion
     - jdbcMinorVersion
     - identifierQuote
     - sqlKeywords
     - numericFunctions
     - stringFunctions
     - systemFunctions
     - dateTimeFunctions
     - searchStringEscape
     - extraNameCharacters
     - supportedCONVERT
     - schemaTerm
     - procedureTerm
     - catalogTerm
     - catalogSeparator
     - maxBinaryLiteralLength
     - maxCharLiteralLength
     - maxColumnsInGroupBy
     - maxColumnsInIndex
     - maxColumnsInOrderBy
     - maxColumnsInSelect
     - maxColumnsInTable
     - maxConnections
     - maxIndexLength
     - maxRowSize
     - maxStatementLength
     - maxOpenStatements
     - maxTableNamesInSelect
     - maxColumnNameLength
     - maxCursorNameLength
     - maxSchemaNameLength
     - maxProcedureNameLength
     - maxCatalogNameLength
     - maxTableNameLength
     - maxUserNameLength
     - defaultTransactionIsolation
     - defaultResultSetType
     - defaultResultSetHoldabilityHoldCursorsOverCommit
     - sqlStateIsXOpen
     - catalogAtStart
     - transactionDefaults
     - rowIdLifeTime
     - supportedFeatures
     - featuresWithParams
    """


    def __init__(self, productName=None, productVersion=None, productMajorVersion=None, productMinorVersion=None, jdbcMajorVersion=None, jdbcMinorVersion=None, identifierQuote=None, sqlKeywords=None, numericFunctions=None, stringFunctions=None, systemFunctions=None, dateTimeFunctions=None, searchStringEscape=None, extraNameCharacters=None, supportedCONVERT=None, schemaTerm=None, procedureTerm=None, catalogTerm=None, catalogSeparator=None, maxBinaryLiteralLength=None, maxCharLiteralLength=None, maxColumnsInGroupBy=None, maxColumnsInIndex=None, maxColumnsInOrderBy=None, maxColumnsInSelect=None, maxColumnsInTable=None, maxConnections=None, maxIndexLength=None, maxRowSize=None, maxStatementLength=None, maxOpenStatements=None, maxTableNamesInSelect=None, maxColumnNameLength=None, maxCursorNameLength=None, maxSchemaNameLength=None, maxProcedureNameLength=None, maxCatalogNameLength=None, maxTableNameLength=None, maxUserNameLength=None, defaultTransactionIsolation=None, defaultResultSetType=None, defaultResultSetHoldabilityHoldCursorsOverCommit=None, sqlStateIsXOpen=None, catalogAtStart=None, transactionDefaults=None, rowIdLifeTime=None, supportedFeatures=None, featuresWithParams=None,):
        self.productName = productName
        self.productVersion = productVersion
        self.productMajorVersion = productMajorVersion
        self.productMinorVersion = productMinorVersion
        self.jdbcMajorVersion = jdbcMajorVersion
        self.jdbcMinorVersion = jdbcMinorVersion
        self.identifierQuote = identifierQuote
        self.sqlKeywords = sqlKeywords
        self.numericFunctions = numericFunctions
        self.stringFunctions = stringFunctions
        self.systemFunctions = systemFunctions
        self.dateTimeFunctions = dateTimeFunctions
        self.searchStringEscape = searchStringEscape
        self.extraNameCharacters = extraNameCharacters
        self.supportedCONVERT = supportedCONVERT
        self.schemaTerm = schemaTerm
        self.procedureTerm = procedureTerm
        self.catalogTerm = catalogTerm
        self.catalogSeparator = catalogSeparator
        self.maxBinaryLiteralLength = maxBinaryLiteralLength
        self.maxCharLiteralLength = maxCharLiteralLength
        self.maxColumnsInGroupBy = maxColumnsInGroupBy
        self.maxColumnsInIndex = maxColumnsInIndex
        self.maxColumnsInOrderBy = maxColumnsInOrderBy
        self.maxColumnsInSelect = maxColumnsInSelect
        self.maxColumnsInTable = maxColumnsInTable
        self.maxConnections = maxConnections
        self.maxIndexLength = maxIndexLength
        self.maxRowSize = maxRowSize
        self.maxStatementLength = maxStatementLength
        self.maxOpenStatements = maxOpenStatements
        self.maxTableNamesInSelect = maxTableNamesInSelect
        self.maxColumnNameLength = maxColumnNameLength
        self.maxCursorNameLength = maxCursorNameLength
        self.maxSchemaNameLength = maxSchemaNameLength
        self.maxProcedureNameLength = maxProcedureNameLength
        self.maxCatalogNameLength = maxCatalogNameLength
        self.maxTableNameLength = maxTableNameLength
        self.maxUserNameLength = maxUserNameLength
        self.defaultTransactionIsolation = defaultTransactionIsolation
        self.defaultResultSetType = defaultResultSetType
        self.defaultResultSetHoldabilityHoldCursorsOverCommit = defaultResultSetHoldabilityHoldCursorsOverCommit
        self.sqlStateIsXOpen = sqlStateIsXOpen
        self.catalogAtStart = catalogAtStart
        self.transactionDefaults = transactionDefaults
        self.rowIdLifeTime = rowIdLifeTime
        self.supportedFeatures = supportedFeatures
        self.featuresWithParams = featuresWithParams

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.productName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.productVersion = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.productMajorVersion = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.productMinorVersion = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.jdbcMajorVersion = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.jdbcMinorVersion = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.identifierQuote = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.sqlKeywords = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.sqlKeywords.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.numericFunctions = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.numericFunctions.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.stringFunctions = []
                    (_etype15, _size12) = iprot.readListBegin()
                    for _i16 in range(_size12):
                        _elem17 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.stringFunctions.append(_elem17)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.LIST:
                    self.systemFunctions = []
                    (_etype21, _size18) = iprot.readListBegin()
                    for _i22 in range(_size18):
                        _elem23 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.systemFunctions.append(_elem23)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.LIST:
                    self.dateTimeFunctions = []
                    (_etype27, _size24) = iprot.readListBegin()
                    for _i28 in range(_size24):
                        _elem29 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.dateTimeFunctions.append(_elem29)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRING:
                    self.searchStringEscape = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRING:
                    self.extraNameCharacters = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.MAP:
                    self.supportedCONVERT = {}
                    (_ktype31, _vtype32, _size30) = iprot.readMapBegin()
                    for _i34 in range(_size30):
                        _key35 = iprot.readI32()
                        _val36 = set()
                        (_etype40, _size37) = iprot.readSetBegin()
                        for _i41 in range(_size37):
                            _elem42 = iprot.readI32()
                            _val36.add(_elem42)
                        iprot.readSetEnd()
                        self.supportedCONVERT[_key35] = _val36
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRING:
                    self.schemaTerm = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRING:
                    self.procedureTerm = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRING:
                    self.catalogTerm = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.STRING:
                    self.catalogSeparator = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.I32:
                    self.maxBinaryLiteralLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.I32:
                    self.maxCharLiteralLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.I32:
                    self.maxColumnsInGroupBy = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.I32:
                    self.maxColumnsInIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.I32:
                    self.maxColumnsInOrderBy = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.I32:
                    self.maxColumnsInSelect = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 26:
                if ftype == TType.I32:
                    self.maxColumnsInTable = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 27:
                if ftype == TType.I32:
                    self.maxConnections = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 28:
                if ftype == TType.I32:
                    self.maxIndexLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 29:
                if ftype == TType.I32:
                    self.maxRowSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 30:
                if ftype == TType.I32:
                    self.maxStatementLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 31:
                if ftype == TType.I32:
                    self.maxOpenStatements = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 32:
                if ftype == TType.I32:
                    self.maxTableNamesInSelect = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 33:
                if ftype == TType.I32:
                    self.maxColumnNameLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 34:
                if ftype == TType.I32:
                    self.maxCursorNameLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 35:
                if ftype == TType.I32:
                    self.maxSchemaNameLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 36:
                if ftype == TType.I32:
                    self.maxProcedureNameLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 37:
                if ftype == TType.I32:
                    self.maxCatalogNameLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 38:
                if ftype == TType.I32:
                    self.maxTableNameLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 39:
                if ftype == TType.I32:
                    self.maxUserNameLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 40:
                if ftype == TType.I32:
                    self.defaultTransactionIsolation = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 41:
                if ftype == TType.BYTE:
                    self.defaultResultSetType = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 42:
                if ftype == TType.BOOL:
                    self.defaultResultSetHoldabilityHoldCursorsOverCommit = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 43:
                if ftype == TType.BOOL:
                    self.sqlStateIsXOpen = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 44:
                if ftype == TType.BOOL:
                    self.catalogAtStart = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 45:
                if ftype == TType.MAP:
                    self.transactionDefaults = {}
                    (_ktype44, _vtype45, _size43) = iprot.readMapBegin()
                    for _i47 in range(_size43):
                        _key48 = iprot.readI32()
                        _val49 = iprot.readBool()
                        self.transactionDefaults[_key48] = _val49
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 46:
                if ftype == TType.I32:
                    self.rowIdLifeTime = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 47:
                if ftype == TType.SET:
                    self.supportedFeatures = set()
                    (_etype53, _size50) = iprot.readSetBegin()
                    for _i54 in range(_size50):
                        _elem55 = iprot.readI32()
                        self.supportedFeatures.add(_elem55)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 48:
                if ftype == TType.MAP:
                    self.featuresWithParams = {}
                    (_ktype57, _vtype58, _size56) = iprot.readMapBegin()
                    for _i60 in range(_size56):
                        _key61 = iprot.readI32()
                        _val62 = []
                        (_etype66, _size63) = iprot.readListBegin()
                        for _i67 in range(_size63):
                            _elem68 = iprot.readI32()
                            _val62.append(_elem68)
                        iprot.readListEnd()
                        self.featuresWithParams[_key61] = _val62
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ServiceMetaData')
        if self.productName is not None:
            oprot.writeFieldBegin('productName', TType.STRING, 1)
            oprot.writeString(self.productName.encode('utf-8') if sys.version_info[0] == 2 else self.productName)
            oprot.writeFieldEnd()
        if self.productVersion is not None:
            oprot.writeFieldBegin('productVersion', TType.STRING, 2)
            oprot.writeString(self.productVersion.encode('utf-8') if sys.version_info[0] == 2 else self.productVersion)
            oprot.writeFieldEnd()
        if self.productMajorVersion is not None:
            oprot.writeFieldBegin('productMajorVersion', TType.I32, 3)
            oprot.writeI32(self.productMajorVersion)
            oprot.writeFieldEnd()
        if self.productMinorVersion is not None:
            oprot.writeFieldBegin('productMinorVersion', TType.I32, 4)
            oprot.writeI32(self.productMinorVersion)
            oprot.writeFieldEnd()
        if self.jdbcMajorVersion is not None:
            oprot.writeFieldBegin('jdbcMajorVersion', TType.I32, 5)
            oprot.writeI32(self.jdbcMajorVersion)
            oprot.writeFieldEnd()
        if self.jdbcMinorVersion is not None:
            oprot.writeFieldBegin('jdbcMinorVersion', TType.I32, 6)
            oprot.writeI32(self.jdbcMinorVersion)
            oprot.writeFieldEnd()
        if self.identifierQuote is not None:
            oprot.writeFieldBegin('identifierQuote', TType.STRING, 7)
            oprot.writeString(self.identifierQuote.encode('utf-8') if sys.version_info[0] == 2 else self.identifierQuote)
            oprot.writeFieldEnd()
        if self.sqlKeywords is not None:
            oprot.writeFieldBegin('sqlKeywords', TType.LIST, 8)
            oprot.writeListBegin(TType.STRING, len(self.sqlKeywords))
            for iter69 in self.sqlKeywords:
                oprot.writeString(iter69.encode('utf-8') if sys.version_info[0] == 2 else iter69)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.numericFunctions is not None:
            oprot.writeFieldBegin('numericFunctions', TType.LIST, 9)
            oprot.writeListBegin(TType.STRING, len(self.numericFunctions))
            for iter70 in self.numericFunctions:
                oprot.writeString(iter70.encode('utf-8') if sys.version_info[0] == 2 else iter70)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.stringFunctions is not None:
            oprot.writeFieldBegin('stringFunctions', TType.LIST, 10)
            oprot.writeListBegin(TType.STRING, len(self.stringFunctions))
            for iter71 in self.stringFunctions:
                oprot.writeString(iter71.encode('utf-8') if sys.version_info[0] == 2 else iter71)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.systemFunctions is not None:
            oprot.writeFieldBegin('systemFunctions', TType.LIST, 11)
            oprot.writeListBegin(TType.STRING, len(self.systemFunctions))
            for iter72 in self.systemFunctions:
                oprot.writeString(iter72.encode('utf-8') if sys.version_info[0] == 2 else iter72)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dateTimeFunctions is not None:
            oprot.writeFieldBegin('dateTimeFunctions', TType.LIST, 12)
            oprot.writeListBegin(TType.STRING, len(self.dateTimeFunctions))
            for iter73 in self.dateTimeFunctions:
                oprot.writeString(iter73.encode('utf-8') if sys.version_info[0] == 2 else iter73)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.searchStringEscape is not None:
            oprot.writeFieldBegin('searchStringEscape', TType.STRING, 13)
            oprot.writeString(self.searchStringEscape.encode('utf-8') if sys.version_info[0] == 2 else self.searchStringEscape)
            oprot.writeFieldEnd()
        if self.extraNameCharacters is not None:
            oprot.writeFieldBegin('extraNameCharacters', TType.STRING, 14)
            oprot.writeString(self.extraNameCharacters.encode('utf-8') if sys.version_info[0] == 2 else self.extraNameCharacters)
            oprot.writeFieldEnd()
        if self.supportedCONVERT is not None:
            oprot.writeFieldBegin('supportedCONVERT', TType.MAP, 15)
            oprot.writeMapBegin(TType.I32, TType.SET, len(self.supportedCONVERT))
            for kiter74, viter75 in self.supportedCONVERT.items():
                oprot.writeI32(kiter74)
                oprot.writeSetBegin(TType.I32, len(viter75))
                for iter76 in viter75:
                    oprot.writeI32(iter76)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.schemaTerm is not None:
            oprot.writeFieldBegin('schemaTerm', TType.STRING, 16)
            oprot.writeString(self.schemaTerm.encode('utf-8') if sys.version_info[0] == 2 else self.schemaTerm)
            oprot.writeFieldEnd()
        if self.procedureTerm is not None:
            oprot.writeFieldBegin('procedureTerm', TType.STRING, 17)
            oprot.writeString(self.procedureTerm.encode('utf-8') if sys.version_info[0] == 2 else self.procedureTerm)
            oprot.writeFieldEnd()
        if self.catalogTerm is not None:
            oprot.writeFieldBegin('catalogTerm', TType.STRING, 18)
            oprot.writeString(self.catalogTerm.encode('utf-8') if sys.version_info[0] == 2 else self.catalogTerm)
            oprot.writeFieldEnd()
        if self.catalogSeparator is not None:
            oprot.writeFieldBegin('catalogSeparator', TType.STRING, 19)
            oprot.writeString(self.catalogSeparator.encode('utf-8') if sys.version_info[0] == 2 else self.catalogSeparator)
            oprot.writeFieldEnd()
        if self.maxBinaryLiteralLength is not None:
            oprot.writeFieldBegin('maxBinaryLiteralLength', TType.I32, 20)
            oprot.writeI32(self.maxBinaryLiteralLength)
            oprot.writeFieldEnd()
        if self.maxCharLiteralLength is not None:
            oprot.writeFieldBegin('maxCharLiteralLength', TType.I32, 21)
            oprot.writeI32(self.maxCharLiteralLength)
            oprot.writeFieldEnd()
        if self.maxColumnsInGroupBy is not None:
            oprot.writeFieldBegin('maxColumnsInGroupBy', TType.I32, 22)
            oprot.writeI32(self.maxColumnsInGroupBy)
            oprot.writeFieldEnd()
        if self.maxColumnsInIndex is not None:
            oprot.writeFieldBegin('maxColumnsInIndex', TType.I32, 23)
            oprot.writeI32(self.maxColumnsInIndex)
            oprot.writeFieldEnd()
        if self.maxColumnsInOrderBy is not None:
            oprot.writeFieldBegin('maxColumnsInOrderBy', TType.I32, 24)
            oprot.writeI32(self.maxColumnsInOrderBy)
            oprot.writeFieldEnd()
        if self.maxColumnsInSelect is not None:
            oprot.writeFieldBegin('maxColumnsInSelect', TType.I32, 25)
            oprot.writeI32(self.maxColumnsInSelect)
            oprot.writeFieldEnd()
        if self.maxColumnsInTable is not None:
            oprot.writeFieldBegin('maxColumnsInTable', TType.I32, 26)
            oprot.writeI32(self.maxColumnsInTable)
            oprot.writeFieldEnd()
        if self.maxConnections is not None:
            oprot.writeFieldBegin('maxConnections', TType.I32, 27)
            oprot.writeI32(self.maxConnections)
            oprot.writeFieldEnd()
        if self.maxIndexLength is not None:
            oprot.writeFieldBegin('maxIndexLength', TType.I32, 28)
            oprot.writeI32(self.maxIndexLength)
            oprot.writeFieldEnd()
        if self.maxRowSize is not None:
            oprot.writeFieldBegin('maxRowSize', TType.I32, 29)
            oprot.writeI32(self.maxRowSize)
            oprot.writeFieldEnd()
        if self.maxStatementLength is not None:
            oprot.writeFieldBegin('maxStatementLength', TType.I32, 30)
            oprot.writeI32(self.maxStatementLength)
            oprot.writeFieldEnd()
        if self.maxOpenStatements is not None:
            oprot.writeFieldBegin('maxOpenStatements', TType.I32, 31)
            oprot.writeI32(self.maxOpenStatements)
            oprot.writeFieldEnd()
        if self.maxTableNamesInSelect is not None:
            oprot.writeFieldBegin('maxTableNamesInSelect', TType.I32, 32)
            oprot.writeI32(self.maxTableNamesInSelect)
            oprot.writeFieldEnd()
        if self.maxColumnNameLength is not None:
            oprot.writeFieldBegin('maxColumnNameLength', TType.I32, 33)
            oprot.writeI32(self.maxColumnNameLength)
            oprot.writeFieldEnd()
        if self.maxCursorNameLength is not None:
            oprot.writeFieldBegin('maxCursorNameLength', TType.I32, 34)
            oprot.writeI32(self.maxCursorNameLength)
            oprot.writeFieldEnd()
        if self.maxSchemaNameLength is not None:
            oprot.writeFieldBegin('maxSchemaNameLength', TType.I32, 35)
            oprot.writeI32(self.maxSchemaNameLength)
            oprot.writeFieldEnd()
        if self.maxProcedureNameLength is not None:
            oprot.writeFieldBegin('maxProcedureNameLength', TType.I32, 36)
            oprot.writeI32(self.maxProcedureNameLength)
            oprot.writeFieldEnd()
        if self.maxCatalogNameLength is not None:
            oprot.writeFieldBegin('maxCatalogNameLength', TType.I32, 37)
            oprot.writeI32(self.maxCatalogNameLength)
            oprot.writeFieldEnd()
        if self.maxTableNameLength is not None:
            oprot.writeFieldBegin('maxTableNameLength', TType.I32, 38)
            oprot.writeI32(self.maxTableNameLength)
            oprot.writeFieldEnd()
        if self.maxUserNameLength is not None:
            oprot.writeFieldBegin('maxUserNameLength', TType.I32, 39)
            oprot.writeI32(self.maxUserNameLength)
            oprot.writeFieldEnd()
        if self.defaultTransactionIsolation is not None:
            oprot.writeFieldBegin('defaultTransactionIsolation', TType.I32, 40)
            oprot.writeI32(self.defaultTransactionIsolation)
            oprot.writeFieldEnd()
        if self.defaultResultSetType is not None:
            oprot.writeFieldBegin('defaultResultSetType', TType.BYTE, 41)
            oprot.writeByte(self.defaultResultSetType)
            oprot.writeFieldEnd()
        if self.defaultResultSetHoldabilityHoldCursorsOverCommit is not None:
            oprot.writeFieldBegin('defaultResultSetHoldabilityHoldCursorsOverCommit', TType.BOOL, 42)
            oprot.writeBool(self.defaultResultSetHoldabilityHoldCursorsOverCommit)
            oprot.writeFieldEnd()
        if self.sqlStateIsXOpen is not None:
            oprot.writeFieldBegin('sqlStateIsXOpen', TType.BOOL, 43)
            oprot.writeBool(self.sqlStateIsXOpen)
            oprot.writeFieldEnd()
        if self.catalogAtStart is not None:
            oprot.writeFieldBegin('catalogAtStart', TType.BOOL, 44)
            oprot.writeBool(self.catalogAtStart)
            oprot.writeFieldEnd()
        if self.transactionDefaults is not None:
            oprot.writeFieldBegin('transactionDefaults', TType.MAP, 45)
            oprot.writeMapBegin(TType.I32, TType.BOOL, len(self.transactionDefaults))
            for kiter77, viter78 in self.transactionDefaults.items():
                oprot.writeI32(kiter77)
                oprot.writeBool(viter78)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.rowIdLifeTime is not None:
            oprot.writeFieldBegin('rowIdLifeTime', TType.I32, 46)
            oprot.writeI32(self.rowIdLifeTime)
            oprot.writeFieldEnd()
        if self.supportedFeatures is not None:
            oprot.writeFieldBegin('supportedFeatures', TType.SET, 47)
            oprot.writeSetBegin(TType.I32, len(self.supportedFeatures))
            for iter79 in self.supportedFeatures:
                oprot.writeI32(iter79)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.featuresWithParams is not None:
            oprot.writeFieldBegin('featuresWithParams', TType.MAP, 48)
            oprot.writeMapBegin(TType.I32, TType.LIST, len(self.featuresWithParams))
            for kiter80, viter81 in self.featuresWithParams.items():
                oprot.writeI32(kiter80)
                oprot.writeListBegin(TType.I32, len(viter81))
                for iter82 in viter81:
                    oprot.writeI32(iter82)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.productName is None:
            raise TProtocolException(message='Required field productName is unset!')
        if self.productVersion is None:
            raise TProtocolException(message='Required field productVersion is unset!')
        if self.productMajorVersion is None:
            raise TProtocolException(message='Required field productMajorVersion is unset!')
        if self.productMinorVersion is None:
            raise TProtocolException(message='Required field productMinorVersion is unset!')
        if self.jdbcMajorVersion is None:
            raise TProtocolException(message='Required field jdbcMajorVersion is unset!')
        if self.jdbcMinorVersion is None:
            raise TProtocolException(message='Required field jdbcMinorVersion is unset!')
        if self.identifierQuote is None:
            raise TProtocolException(message='Required field identifierQuote is unset!')
        if self.sqlKeywords is None:
            raise TProtocolException(message='Required field sqlKeywords is unset!')
        if self.numericFunctions is None:
            raise TProtocolException(message='Required field numericFunctions is unset!')
        if self.stringFunctions is None:
            raise TProtocolException(message='Required field stringFunctions is unset!')
        if self.systemFunctions is None:
            raise TProtocolException(message='Required field systemFunctions is unset!')
        if self.dateTimeFunctions is None:
            raise TProtocolException(message='Required field dateTimeFunctions is unset!')
        if self.searchStringEscape is None:
            raise TProtocolException(message='Required field searchStringEscape is unset!')
        if self.supportedCONVERT is None:
            raise TProtocolException(message='Required field supportedCONVERT is unset!')
        if self.schemaTerm is None:
            raise TProtocolException(message='Required field schemaTerm is unset!')
        if self.procedureTerm is None:
            raise TProtocolException(message='Required field procedureTerm is unset!')
        if self.catalogTerm is None:
            raise TProtocolException(message='Required field catalogTerm is unset!')
        if self.catalogSeparator is None:
            raise TProtocolException(message='Required field catalogSeparator is unset!')
        if self.maxBinaryLiteralLength is None:
            raise TProtocolException(message='Required field maxBinaryLiteralLength is unset!')
        if self.maxCharLiteralLength is None:
            raise TProtocolException(message='Required field maxCharLiteralLength is unset!')
        if self.maxColumnsInGroupBy is None:
            raise TProtocolException(message='Required field maxColumnsInGroupBy is unset!')
        if self.maxColumnsInIndex is None:
            raise TProtocolException(message='Required field maxColumnsInIndex is unset!')
        if self.maxColumnsInOrderBy is None:
            raise TProtocolException(message='Required field maxColumnsInOrderBy is unset!')
        if self.maxColumnsInSelect is None:
            raise TProtocolException(message='Required field maxColumnsInSelect is unset!')
        if self.maxColumnsInTable is None:
            raise TProtocolException(message='Required field maxColumnsInTable is unset!')
        if self.maxConnections is None:
            raise TProtocolException(message='Required field maxConnections is unset!')
        if self.maxIndexLength is None:
            raise TProtocolException(message='Required field maxIndexLength is unset!')
        if self.maxRowSize is None:
            raise TProtocolException(message='Required field maxRowSize is unset!')
        if self.maxStatementLength is None:
            raise TProtocolException(message='Required field maxStatementLength is unset!')
        if self.maxOpenStatements is None:
            raise TProtocolException(message='Required field maxOpenStatements is unset!')
        if self.maxTableNamesInSelect is None:
            raise TProtocolException(message='Required field maxTableNamesInSelect is unset!')
        if self.maxColumnNameLength is None:
            raise TProtocolException(message='Required field maxColumnNameLength is unset!')
        if self.maxCursorNameLength is None:
            raise TProtocolException(message='Required field maxCursorNameLength is unset!')
        if self.maxSchemaNameLength is None:
            raise TProtocolException(message='Required field maxSchemaNameLength is unset!')
        if self.maxProcedureNameLength is None:
            raise TProtocolException(message='Required field maxProcedureNameLength is unset!')
        if self.maxCatalogNameLength is None:
            raise TProtocolException(message='Required field maxCatalogNameLength is unset!')
        if self.maxTableNameLength is None:
            raise TProtocolException(message='Required field maxTableNameLength is unset!')
        if self.maxUserNameLength is None:
            raise TProtocolException(message='Required field maxUserNameLength is unset!')
        if self.defaultTransactionIsolation is None:
            raise TProtocolException(message='Required field defaultTransactionIsolation is unset!')
        if self.defaultResultSetType is None:
            raise TProtocolException(message='Required field defaultResultSetType is unset!')
        if self.defaultResultSetHoldabilityHoldCursorsOverCommit is None:
            raise TProtocolException(message='Required field defaultResultSetHoldabilityHoldCursorsOverCommit is unset!')
        if self.sqlStateIsXOpen is None:
            raise TProtocolException(message='Required field sqlStateIsXOpen is unset!')
        if self.catalogAtStart is None:
            raise TProtocolException(message='Required field catalogAtStart is unset!')
        if self.transactionDefaults is None:
            raise TProtocolException(message='Required field transactionDefaults is unset!')
        if self.rowIdLifeTime is None:
            raise TProtocolException(message='Required field rowIdLifeTime is unset!')
        if self.supportedFeatures is None:
            raise TProtocolException(message='Required field supportedFeatures is unset!')
        if self.featuresWithParams is None:
            raise TProtocolException(message='Required field featuresWithParams is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ServiceMetaDataArgs(object):
    """
    Attributes:
     - connId
     - driverType
     - token
     - schema
     - table
     - tableTypes
     - columnName
     - foreignSchema
     - foreignTable
     - procedureName
     - functionName
     - attributeName
     - typeName
     - typeId
    """


    def __init__(self, connId=None, driverType=None, token=None, schema=None, table=None, tableTypes=None, columnName=None, foreignSchema=None, foreignTable=None, procedureName=None, functionName=None, attributeName=None, typeName=None, typeId=None,):
        self.connId = connId
        self.driverType = driverType
        self.token = token
        self.schema = schema
        self.table = table
        self.tableTypes = tableTypes
        self.columnName = columnName
        self.foreignSchema = foreignSchema
        self.foreignTable = foreignTable
        self.procedureName = procedureName
        self.functionName = functionName
        self.attributeName = attributeName
        self.typeName = typeName
        self.typeId = typeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.driverType = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.schema = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.tableTypes = []
                    (_etype86, _size83) = iprot.readListBegin()
                    for _i87 in range(_size83):
                        _elem88 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.tableTypes.append(_elem88)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.columnName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.foreignSchema = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.foreignTable = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.procedureName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.functionName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRING:
                    self.attributeName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRING:
                    self.typeName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I32:
                    self.typeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ServiceMetaDataArgs')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.driverType is not None:
            oprot.writeFieldBegin('driverType', TType.BYTE, 2)
            oprot.writeByte(self.driverType)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 3)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        if self.schema is not None:
            oprot.writeFieldBegin('schema', TType.STRING, 4)
            oprot.writeString(self.schema.encode('utf-8') if sys.version_info[0] == 2 else self.schema)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 5)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.tableTypes is not None:
            oprot.writeFieldBegin('tableTypes', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.tableTypes))
            for iter89 in self.tableTypes:
                oprot.writeString(iter89.encode('utf-8') if sys.version_info[0] == 2 else iter89)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.columnName is not None:
            oprot.writeFieldBegin('columnName', TType.STRING, 7)
            oprot.writeString(self.columnName.encode('utf-8') if sys.version_info[0] == 2 else self.columnName)
            oprot.writeFieldEnd()
        if self.foreignSchema is not None:
            oprot.writeFieldBegin('foreignSchema', TType.STRING, 8)
            oprot.writeString(self.foreignSchema.encode('utf-8') if sys.version_info[0] == 2 else self.foreignSchema)
            oprot.writeFieldEnd()
        if self.foreignTable is not None:
            oprot.writeFieldBegin('foreignTable', TType.STRING, 9)
            oprot.writeString(self.foreignTable.encode('utf-8') if sys.version_info[0] == 2 else self.foreignTable)
            oprot.writeFieldEnd()
        if self.procedureName is not None:
            oprot.writeFieldBegin('procedureName', TType.STRING, 10)
            oprot.writeString(self.procedureName.encode('utf-8') if sys.version_info[0] == 2 else self.procedureName)
            oprot.writeFieldEnd()
        if self.functionName is not None:
            oprot.writeFieldBegin('functionName', TType.STRING, 11)
            oprot.writeString(self.functionName.encode('utf-8') if sys.version_info[0] == 2 else self.functionName)
            oprot.writeFieldEnd()
        if self.attributeName is not None:
            oprot.writeFieldBegin('attributeName', TType.STRING, 12)
            oprot.writeString(self.attributeName.encode('utf-8') if sys.version_info[0] == 2 else self.attributeName)
            oprot.writeFieldEnd()
        if self.typeName is not None:
            oprot.writeFieldBegin('typeName', TType.STRING, 13)
            oprot.writeString(self.typeName.encode('utf-8') if sys.version_info[0] == 2 else self.typeName)
            oprot.writeFieldEnd()
        if self.typeId is not None:
            oprot.writeFieldBegin('typeId', TType.I32, 14)
            oprot.writeI32(self.typeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.connId is None:
            raise TProtocolException(message='Required field connId is unset!')
        if self.driverType is None:
            raise TProtocolException(message='Required field driverType is unset!')
        if self.token is None:
            raise TProtocolException(message='Required field token is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class OpenConnectionArgs(object):
    """
    Attributes:
     - clientHostName
     - clientID
     - security
     - userName
     - password
     - forXA
     - tokenSize
     - useStringForDecimal
     - properties
    """


    def __init__(self, clientHostName=None, clientID=None, security=None, userName=None, password=None, forXA=None, tokenSize=None, useStringForDecimal=None, properties=None,):
        self.clientHostName = clientHostName
        self.clientID = clientID
        self.security = security
        self.userName = userName
        self.password = password
        self.forXA = forXA
        self.tokenSize = tokenSize
        self.useStringForDecimal = useStringForDecimal
        self.properties = properties

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clientHostName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.clientID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.security = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.forXA = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.tokenSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.useStringForDecimal = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.MAP:
                    self.properties = {}
                    (_ktype91, _vtype92, _size90) = iprot.readMapBegin()
                    for _i94 in range(_size90):
                        _key95 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val96 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.properties[_key95] = _val96
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('OpenConnectionArgs')
        if self.clientHostName is not None:
            oprot.writeFieldBegin('clientHostName', TType.STRING, 1)
            oprot.writeString(self.clientHostName.encode('utf-8') if sys.version_info[0] == 2 else self.clientHostName)
            oprot.writeFieldEnd()
        if self.clientID is not None:
            oprot.writeFieldBegin('clientID', TType.STRING, 2)
            oprot.writeString(self.clientID.encode('utf-8') if sys.version_info[0] == 2 else self.clientID)
            oprot.writeFieldEnd()
        if self.security is not None:
            oprot.writeFieldBegin('security', TType.I32, 3)
            oprot.writeI32(self.security)
            oprot.writeFieldEnd()
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 4)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 5)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        if self.forXA is not None:
            oprot.writeFieldBegin('forXA', TType.BOOL, 6)
            oprot.writeBool(self.forXA)
            oprot.writeFieldEnd()
        if self.tokenSize is not None:
            oprot.writeFieldBegin('tokenSize', TType.I32, 7)
            oprot.writeI32(self.tokenSize)
            oprot.writeFieldEnd()
        if self.useStringForDecimal is not None:
            oprot.writeFieldBegin('useStringForDecimal', TType.BOOL, 8)
            oprot.writeBool(self.useStringForDecimal)
            oprot.writeFieldEnd()
        if self.properties is not None:
            oprot.writeFieldBegin('properties', TType.MAP, 9)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
            for kiter97, viter98 in self.properties.items():
                oprot.writeString(kiter97.encode('utf-8') if sys.version_info[0] == 2 else kiter97)
                oprot.writeString(viter98.encode('utf-8') if sys.version_info[0] == 2 else viter98)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.clientHostName is None:
            raise TProtocolException(message='Required field clientHostName is unset!')
        if self.clientID is None:
            raise TProtocolException(message='Required field clientID is unset!')
        if self.security is None:
            raise TProtocolException(message='Required field security is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConnectionProperties(object):
    """
    Attributes:
     - connId
     - clientHostName
     - clientID
     - userName
     - token
     - defaultSchema
    """


    def __init__(self, connId=None, clientHostName=None, clientID=None, userName=None, token=None, defaultSchema=None,):
        self.connId = connId
        self.clientHostName = clientHostName
        self.clientID = clientID
        self.userName = userName
        self.token = token
        self.defaultSchema = defaultSchema

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.clientHostName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.clientID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.defaultSchema = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConnectionProperties')
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 1)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.clientHostName is not None:
            oprot.writeFieldBegin('clientHostName', TType.STRING, 2)
            oprot.writeString(self.clientHostName.encode('utf-8') if sys.version_info[0] == 2 else self.clientHostName)
            oprot.writeFieldEnd()
        if self.clientID is not None:
            oprot.writeFieldBegin('clientID', TType.STRING, 3)
            oprot.writeString(self.clientID.encode('utf-8') if sys.version_info[0] == 2 else self.clientID)
            oprot.writeFieldEnd()
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 4)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 5)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        if self.defaultSchema is not None:
            oprot.writeFieldBegin('defaultSchema', TType.STRING, 6)
            oprot.writeString(self.defaultSchema.encode('utf-8') if sys.version_info[0] == 2 else self.defaultSchema)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.connId is None:
            raise TProtocolException(message='Required field connId is unset!')
        if self.clientHostName is None:
            raise TProtocolException(message='Required field clientHostName is unset!')
        if self.clientID is None:
            raise TProtocolException(message='Required field clientID is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HostAddress(object):
    """
    Attributes:
     - hostName
     - port
     - ipAddress
     - serverType
    """


    def __init__(self, hostName=None, port=None, ipAddress=None, serverType=None,):
        self.hostName = hostName
        self.port = port
        self.ipAddress = ipAddress
        self.serverType = serverType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.hostName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.ipAddress = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.serverType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HostAddress')
        if self.hostName is not None:
            oprot.writeFieldBegin('hostName', TType.STRING, 1)
            oprot.writeString(self.hostName.encode('utf-8') if sys.version_info[0] == 2 else self.hostName)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.ipAddress is not None:
            oprot.writeFieldBegin('ipAddress', TType.STRING, 3)
            oprot.writeString(self.ipAddress.encode('utf-8') if sys.version_info[0] == 2 else self.ipAddress)
            oprot.writeFieldEnd()
        if self.serverType is not None:
            oprot.writeFieldBegin('serverType', TType.I32, 4)
            oprot.writeI32(self.serverType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.hostName is None:
            raise TProtocolException(message='Required field hostName is unset!')
        if self.port is None:
            raise TProtocolException(message='Required field port is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SnappyExceptionData(object):
    """
    Attributes:
     - reason
     - errorCode
     - sqlState
     - updateCounts
    """


    def __init__(self, reason=None, errorCode=None, sqlState=None, updateCounts=None,):
        self.reason = reason
        self.errorCode = errorCode
        self.sqlState = sqlState
        self.updateCounts = updateCounts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.reason = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.errorCode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.sqlState = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.updateCounts = []
                    (_etype102, _size99) = iprot.readListBegin()
                    for _i103 in range(_size99):
                        _elem104 = iprot.readI32()
                        self.updateCounts.append(_elem104)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SnappyExceptionData')
        if self.reason is not None:
            oprot.writeFieldBegin('reason', TType.STRING, 1)
            oprot.writeString(self.reason.encode('utf-8') if sys.version_info[0] == 2 else self.reason)
            oprot.writeFieldEnd()
        if self.errorCode is not None:
            oprot.writeFieldBegin('errorCode', TType.I32, 2)
            oprot.writeI32(self.errorCode)
            oprot.writeFieldEnd()
        if self.sqlState is not None:
            oprot.writeFieldBegin('sqlState', TType.STRING, 3)
            oprot.writeString(self.sqlState.encode('utf-8') if sys.version_info[0] == 2 else self.sqlState)
            oprot.writeFieldEnd()
        if self.updateCounts is not None:
            oprot.writeFieldBegin('updateCounts', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.updateCounts))
            for iter105 in self.updateCounts:
                oprot.writeI32(iter105)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.reason is None:
            raise TProtocolException(message='Required field reason is unset!')
        if self.errorCode is None:
            raise TProtocolException(message='Required field errorCode is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SnappyException(TException):
    """
    Attributes:
     - exceptionData
     - serverInfo
     - nextExceptions
    """


    def __init__(self, exceptionData=None, serverInfo=None, nextExceptions=None,):
        self.exceptionData = exceptionData
        self.serverInfo = serverInfo
        self.nextExceptions = nextExceptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exceptionData = SnappyExceptionData()
                    self.exceptionData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.serverInfo = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.nextExceptions = []
                    (_etype109, _size106) = iprot.readListBegin()
                    for _i110 in range(_size106):
                        _elem111 = SnappyExceptionData()
                        _elem111.read(iprot)
                        self.nextExceptions.append(_elem111)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SnappyException')
        if self.exceptionData is not None:
            oprot.writeFieldBegin('exceptionData', TType.STRUCT, 1)
            self.exceptionData.write(oprot)
            oprot.writeFieldEnd()
        if self.serverInfo is not None:
            oprot.writeFieldBegin('serverInfo', TType.STRING, 2)
            oprot.writeString(self.serverInfo.encode('utf-8') if sys.version_info[0] == 2 else self.serverInfo)
            oprot.writeFieldEnd()
        if self.nextExceptions is not None:
            oprot.writeFieldBegin('nextExceptions', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.nextExceptions))
            for iter112 in self.nextExceptions:
                iter112.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.exceptionData is None:
            raise TProtocolException(message='Required field exceptionData is unset!')
        if self.serverInfo is None:
            raise TProtocolException(message='Required field serverInfo is unset!')
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StatementAttrs(object):
    """
    Attributes:
     - resultSetType
     - updatable
     - holdCursorsOverCommit
     - requireAutoIncCols
     - autoIncColumns
     - autoIncColumnNames
     - batchSize
     - fetchReverse
     - lobChunkSize
     - maxRows
     - maxFieldSize
     - timeout
     - cursorName
     - possibleDuplicate
     - poolable
     - doEscapeProcessing
     - pendingTransactionAttrs
     - bucketIds
     - bucketIdsTable
     - retainBucketIds
     - metadataVersion
     - snapshotTransactionId
    """


    def __init__(self, resultSetType=None, updatable=None, holdCursorsOverCommit=None, requireAutoIncCols=None, autoIncColumns=None, autoIncColumnNames=None, batchSize=1024, fetchReverse=None, lobChunkSize=None, maxRows=None, maxFieldSize=None, timeout=None, cursorName=None, possibleDuplicate=None, poolable=None, doEscapeProcessing=None, pendingTransactionAttrs=None, bucketIds=None, bucketIdsTable=None, retainBucketIds=None, metadataVersion=None, snapshotTransactionId=None,):
        self.resultSetType = resultSetType
        self.updatable = updatable
        self.holdCursorsOverCommit = holdCursorsOverCommit
        self.requireAutoIncCols = requireAutoIncCols
        self.autoIncColumns = autoIncColumns
        self.autoIncColumnNames = autoIncColumnNames
        self.batchSize = batchSize
        self.fetchReverse = fetchReverse
        self.lobChunkSize = lobChunkSize
        self.maxRows = maxRows
        self.maxFieldSize = maxFieldSize
        self.timeout = timeout
        self.cursorName = cursorName
        self.possibleDuplicate = possibleDuplicate
        self.poolable = poolable
        self.doEscapeProcessing = doEscapeProcessing
        self.pendingTransactionAttrs = pendingTransactionAttrs
        self.bucketIds = bucketIds
        self.bucketIdsTable = bucketIdsTable
        self.retainBucketIds = retainBucketIds
        self.metadataVersion = metadataVersion
        self.snapshotTransactionId = snapshotTransactionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.resultSetType = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.updatable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.holdCursorsOverCommit = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.requireAutoIncCols = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.autoIncColumns = []
                    (_etype116, _size113) = iprot.readListBegin()
                    for _i117 in range(_size113):
                        _elem118 = iprot.readI32()
                        self.autoIncColumns.append(_elem118)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.autoIncColumnNames = []
                    (_etype122, _size119) = iprot.readListBegin()
                    for _i123 in range(_size119):
                        _elem124 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.autoIncColumnNames.append(_elem124)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.batchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.fetchReverse = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.lobChunkSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.maxRows = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.maxFieldSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.timeout = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRING:
                    self.cursorName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.BOOL:
                    self.possibleDuplicate = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.BOOL:
                    self.poolable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.BOOL:
                    self.doEscapeProcessing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.MAP:
                    self.pendingTransactionAttrs = {}
                    (_ktype126, _vtype127, _size125) = iprot.readMapBegin()
                    for _i129 in range(_size125):
                        _key130 = iprot.readI32()
                        _val131 = iprot.readBool()
                        self.pendingTransactionAttrs[_key130] = _val131
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.SET:
                    self.bucketIds = set()
                    (_etype135, _size132) = iprot.readSetBegin()
                    for _i136 in range(_size132):
                        _elem137 = iprot.readI32()
                        self.bucketIds.add(_elem137)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.STRING:
                    self.bucketIdsTable = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.BOOL:
                    self.retainBucketIds = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.I32:
                    self.metadataVersion = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.STRING:
                    self.snapshotTransactionId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StatementAttrs')
        if self.resultSetType is not None:
            oprot.writeFieldBegin('resultSetType', TType.BYTE, 1)
            oprot.writeByte(self.resultSetType)
            oprot.writeFieldEnd()
        if self.updatable is not None:
            oprot.writeFieldBegin('updatable', TType.BOOL, 2)
            oprot.writeBool(self.updatable)
            oprot.writeFieldEnd()
        if self.holdCursorsOverCommit is not None:
            oprot.writeFieldBegin('holdCursorsOverCommit', TType.BOOL, 3)
            oprot.writeBool(self.holdCursorsOverCommit)
            oprot.writeFieldEnd()
        if self.requireAutoIncCols is not None:
            oprot.writeFieldBegin('requireAutoIncCols', TType.BOOL, 4)
            oprot.writeBool(self.requireAutoIncCols)
            oprot.writeFieldEnd()
        if self.autoIncColumns is not None:
            oprot.writeFieldBegin('autoIncColumns', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.autoIncColumns))
            for iter138 in self.autoIncColumns:
                oprot.writeI32(iter138)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.autoIncColumnNames is not None:
            oprot.writeFieldBegin('autoIncColumnNames', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.autoIncColumnNames))
            for iter139 in self.autoIncColumnNames:
                oprot.writeString(iter139.encode('utf-8') if sys.version_info[0] == 2 else iter139)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.batchSize is not None:
            oprot.writeFieldBegin('batchSize', TType.I32, 7)
            oprot.writeI32(self.batchSize)
            oprot.writeFieldEnd()
        if self.fetchReverse is not None:
            oprot.writeFieldBegin('fetchReverse', TType.BOOL, 8)
            oprot.writeBool(self.fetchReverse)
            oprot.writeFieldEnd()
        if self.lobChunkSize is not None:
            oprot.writeFieldBegin('lobChunkSize', TType.I32, 9)
            oprot.writeI32(self.lobChunkSize)
            oprot.writeFieldEnd()
        if self.maxRows is not None:
            oprot.writeFieldBegin('maxRows', TType.I32, 10)
            oprot.writeI32(self.maxRows)
            oprot.writeFieldEnd()
        if self.maxFieldSize is not None:
            oprot.writeFieldBegin('maxFieldSize', TType.I32, 11)
            oprot.writeI32(self.maxFieldSize)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I32, 12)
            oprot.writeI32(self.timeout)
            oprot.writeFieldEnd()
        if self.cursorName is not None:
            oprot.writeFieldBegin('cursorName', TType.STRING, 13)
            oprot.writeString(self.cursorName.encode('utf-8') if sys.version_info[0] == 2 else self.cursorName)
            oprot.writeFieldEnd()
        if self.possibleDuplicate is not None:
            oprot.writeFieldBegin('possibleDuplicate', TType.BOOL, 14)
            oprot.writeBool(self.possibleDuplicate)
            oprot.writeFieldEnd()
        if self.poolable is not None:
            oprot.writeFieldBegin('poolable', TType.BOOL, 15)
            oprot.writeBool(self.poolable)
            oprot.writeFieldEnd()
        if self.doEscapeProcessing is not None:
            oprot.writeFieldBegin('doEscapeProcessing', TType.BOOL, 16)
            oprot.writeBool(self.doEscapeProcessing)
            oprot.writeFieldEnd()
        if self.pendingTransactionAttrs is not None:
            oprot.writeFieldBegin('pendingTransactionAttrs', TType.MAP, 17)
            oprot.writeMapBegin(TType.I32, TType.BOOL, len(self.pendingTransactionAttrs))
            for kiter140, viter141 in self.pendingTransactionAttrs.items():
                oprot.writeI32(kiter140)
                oprot.writeBool(viter141)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.bucketIds is not None:
            oprot.writeFieldBegin('bucketIds', TType.SET, 18)
            oprot.writeSetBegin(TType.I32, len(self.bucketIds))
            for iter142 in self.bucketIds:
                oprot.writeI32(iter142)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.bucketIdsTable is not None:
            oprot.writeFieldBegin('bucketIdsTable', TType.STRING, 19)
            oprot.writeString(self.bucketIdsTable.encode('utf-8') if sys.version_info[0] == 2 else self.bucketIdsTable)
            oprot.writeFieldEnd()
        if self.retainBucketIds is not None:
            oprot.writeFieldBegin('retainBucketIds', TType.BOOL, 20)
            oprot.writeBool(self.retainBucketIds)
            oprot.writeFieldEnd()
        if self.metadataVersion is not None:
            oprot.writeFieldBegin('metadataVersion', TType.I32, 21)
            oprot.writeI32(self.metadataVersion)
            oprot.writeFieldEnd()
        if self.snapshotTransactionId is not None:
            oprot.writeFieldBegin('snapshotTransactionId', TType.STRING, 22)
            oprot.writeString(self.snapshotTransactionId.encode('utf-8') if sys.version_info[0] == 2 else self.snapshotTransactionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ColumnValue(object):
    """
    Attributes:
     - bool_val
     - byte_val
     - i16_val
     - i32_val
     - i64_val
     - float_val
     - double_val
     - string_val
     - decimal_val
     - date_val
     - time_val
     - timestamp_val
     - binary_val
     - blob_val
     - clob_val
     - array_val
     - map_val
     - struct_val
     - null_val
     - java_val
    """


    def __init__(self, bool_val=None, byte_val=None, i16_val=None, i32_val=None, i64_val=None, float_val=None, double_val=None, string_val=None, decimal_val=None, date_val=None, time_val=None, timestamp_val=None, binary_val=None, blob_val=None, clob_val=None, array_val=None, map_val=None, struct_val=None, null_val=None, java_val=None,):
        self.bool_val = bool_val
        self.byte_val = byte_val
        self.i16_val = i16_val
        self.i32_val = i32_val
        self.i64_val = i64_val
        self.float_val = float_val
        self.double_val = double_val
        self.string_val = string_val
        self.decimal_val = decimal_val
        self.date_val = date_val
        self.time_val = time_val
        self.timestamp_val = timestamp_val
        self.binary_val = binary_val
        self.blob_val = blob_val
        self.clob_val = clob_val
        self.array_val = array_val
        self.map_val = map_val
        self.struct_val = struct_val
        self.null_val = null_val
        self.java_val = java_val

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.bool_val = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.byte_val = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.i16_val = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.i32_val = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.i64_val = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.float_val = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.double_val = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.string_val = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.decimal_val = Decimal()
                    self.decimal_val.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.date_val = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.time_val = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I64:
                    self.timestamp_val = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRING:
                    self.binary_val = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.blob_val = BlobChunk()
                    self.blob_val.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRUCT:
                    self.clob_val = ClobChunk()
                    self.clob_val.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.LIST:
                    self.array_val = []
                    (_etype146, _size143) = iprot.readListBegin()
                    for _i147 in range(_size143):
                        _elem148 = ColumnValue()
                        _elem148.read(iprot)
                        self.array_val.append(_elem148)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.MAP:
                    self.map_val = {}
                    (_ktype150, _vtype151, _size149) = iprot.readMapBegin()
                    for _i153 in range(_size149):
                        _key154 = ColumnValue()
                        _key154.read(iprot)
                        _val155 = ColumnValue()
                        _val155.read(iprot)
                        self.map_val[_key154] = _val155
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.LIST:
                    self.struct_val = []
                    (_etype159, _size156) = iprot.readListBegin()
                    for _i160 in range(_size156):
                        _elem161 = ColumnValue()
                        _elem161.read(iprot)
                        self.struct_val.append(_elem161)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.BOOL:
                    self.null_val = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRING:
                    self.java_val = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnValue')
        if self.bool_val is not None:
            oprot.writeFieldBegin('bool_val', TType.BOOL, 1)
            oprot.writeBool(self.bool_val)
            oprot.writeFieldEnd()
        if self.byte_val is not None:
            oprot.writeFieldBegin('byte_val', TType.BYTE, 2)
            oprot.writeByte(self.byte_val)
            oprot.writeFieldEnd()
        if self.i16_val is not None:
            oprot.writeFieldBegin('i16_val', TType.I16, 3)
            oprot.writeI16(self.i16_val)
            oprot.writeFieldEnd()
        if self.i32_val is not None:
            oprot.writeFieldBegin('i32_val', TType.I32, 4)
            oprot.writeI32(self.i32_val)
            oprot.writeFieldEnd()
        if self.i64_val is not None:
            oprot.writeFieldBegin('i64_val', TType.I64, 5)
            oprot.writeI64(self.i64_val)
            oprot.writeFieldEnd()
        if self.float_val is not None:
            oprot.writeFieldBegin('float_val', TType.I32, 6)
            oprot.writeI32(self.float_val)
            oprot.writeFieldEnd()
        if self.double_val is not None:
            oprot.writeFieldBegin('double_val', TType.DOUBLE, 7)
            oprot.writeDouble(self.double_val)
            oprot.writeFieldEnd()
        if self.string_val is not None:
            oprot.writeFieldBegin('string_val', TType.STRING, 8)
            oprot.writeString(self.string_val.encode('utf-8') if sys.version_info[0] == 2 else self.string_val)
            oprot.writeFieldEnd()
        if self.decimal_val is not None:
            oprot.writeFieldBegin('decimal_val', TType.STRUCT, 9)
            self.decimal_val.write(oprot)
            oprot.writeFieldEnd()
        if self.date_val is not None:
            oprot.writeFieldBegin('date_val', TType.I64, 10)
            oprot.writeI64(self.date_val)
            oprot.writeFieldEnd()
        if self.time_val is not None:
            oprot.writeFieldBegin('time_val', TType.I64, 11)
            oprot.writeI64(self.time_val)
            oprot.writeFieldEnd()
        if self.timestamp_val is not None:
            oprot.writeFieldBegin('timestamp_val', TType.I64, 12)
            oprot.writeI64(self.timestamp_val)
            oprot.writeFieldEnd()
        if self.binary_val is not None:
            oprot.writeFieldBegin('binary_val', TType.STRING, 13)
            oprot.writeBinary(self.binary_val)
            oprot.writeFieldEnd()
        if self.blob_val is not None:
            oprot.writeFieldBegin('blob_val', TType.STRUCT, 14)
            self.blob_val.write(oprot)
            oprot.writeFieldEnd()
        if self.clob_val is not None:
            oprot.writeFieldBegin('clob_val', TType.STRUCT, 15)
            self.clob_val.write(oprot)
            oprot.writeFieldEnd()
        if self.array_val is not None:
            oprot.writeFieldBegin('array_val', TType.LIST, 16)
            oprot.writeListBegin(TType.STRUCT, len(self.array_val))
            for iter162 in self.array_val:
                iter162.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.map_val is not None:
            oprot.writeFieldBegin('map_val', TType.MAP, 17)
            oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(self.map_val))
            for kiter163, viter164 in self.map_val.items():
                kiter163.write(oprot)
                viter164.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.struct_val is not None:
            oprot.writeFieldBegin('struct_val', TType.LIST, 18)
            oprot.writeListBegin(TType.STRUCT, len(self.struct_val))
            for iter165 in self.struct_val:
                iter165.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.null_val is not None:
            oprot.writeFieldBegin('null_val', TType.BOOL, 19)
            oprot.writeBool(self.null_val)
            oprot.writeFieldEnd()
        if self.java_val is not None:
            oprot.writeFieldBegin('java_val', TType.STRING, 20)
            oprot.writeBinary(self.java_val)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ColumnDescriptor(object):
    """
    Attributes:
     - type
     - precision
     - scale
     - name
     - fullTableName
     - updatable
     - definitelyUpdatable
     - nullable
     - autoIncrement
     - parameterIn
     - parameterOut
     - elementTypes
     - udtTypeAndClassName
    """


    def __init__(self, type=None, precision=None, scale=None, name=None, fullTableName=None, updatable=None, definitelyUpdatable=None, nullable=None, autoIncrement=None, parameterIn=None, parameterOut=None, elementTypes=None, udtTypeAndClassName=None,):
        self.type = type
        self.precision = precision
        self.scale = scale
        self.name = name
        self.fullTableName = fullTableName
        self.updatable = updatable
        self.definitelyUpdatable = definitelyUpdatable
        self.nullable = nullable
        self.autoIncrement = autoIncrement
        self.parameterIn = parameterIn
        self.parameterOut = parameterOut
        self.elementTypes = elementTypes
        self.udtTypeAndClassName = udtTypeAndClassName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.precision = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.scale = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.fullTableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.updatable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.definitelyUpdatable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.nullable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.autoIncrement = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.parameterIn = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.parameterOut = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.LIST:
                    self.elementTypes = []
                    (_etype169, _size166) = iprot.readListBegin()
                    for _i170 in range(_size166):
                        _elem171 = iprot.readI32()
                        self.elementTypes.append(_elem171)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRING:
                    self.udtTypeAndClassName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnDescriptor')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.precision is not None:
            oprot.writeFieldBegin('precision', TType.I16, 2)
            oprot.writeI16(self.precision)
            oprot.writeFieldEnd()
        if self.scale is not None:
            oprot.writeFieldBegin('scale', TType.I16, 3)
            oprot.writeI16(self.scale)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 4)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.fullTableName is not None:
            oprot.writeFieldBegin('fullTableName', TType.STRING, 5)
            oprot.writeString(self.fullTableName.encode('utf-8') if sys.version_info[0] == 2 else self.fullTableName)
            oprot.writeFieldEnd()
        if self.updatable is not None:
            oprot.writeFieldBegin('updatable', TType.BOOL, 6)
            oprot.writeBool(self.updatable)
            oprot.writeFieldEnd()
        if self.definitelyUpdatable is not None:
            oprot.writeFieldBegin('definitelyUpdatable', TType.BOOL, 7)
            oprot.writeBool(self.definitelyUpdatable)
            oprot.writeFieldEnd()
        if self.nullable is not None:
            oprot.writeFieldBegin('nullable', TType.BOOL, 8)
            oprot.writeBool(self.nullable)
            oprot.writeFieldEnd()
        if self.autoIncrement is not None:
            oprot.writeFieldBegin('autoIncrement', TType.BOOL, 9)
            oprot.writeBool(self.autoIncrement)
            oprot.writeFieldEnd()
        if self.parameterIn is not None:
            oprot.writeFieldBegin('parameterIn', TType.BOOL, 10)
            oprot.writeBool(self.parameterIn)
            oprot.writeFieldEnd()
        if self.parameterOut is not None:
            oprot.writeFieldBegin('parameterOut', TType.BOOL, 11)
            oprot.writeBool(self.parameterOut)
            oprot.writeFieldEnd()
        if self.elementTypes is not None:
            oprot.writeFieldBegin('elementTypes', TType.LIST, 12)
            oprot.writeListBegin(TType.I32, len(self.elementTypes))
            for iter172 in self.elementTypes:
                oprot.writeI32(iter172)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.udtTypeAndClassName is not None:
            oprot.writeFieldBegin('udtTypeAndClassName', TType.STRING, 13)
            oprot.writeString(self.udtTypeAndClassName.encode('utf-8') if sys.version_info[0] == 2 else self.udtTypeAndClassName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.precision is None:
            raise TProtocolException(message='Required field precision is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Row(object):
    """
    Attributes:
     - values
    """


    def __init__(self, values=None,):
        self.values = values

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype176, _size173) = iprot.readListBegin()
                    for _i177 in range(_size173):
                        _elem178 = ColumnValue()
                        _elem178.read(iprot)
                        self.values.append(_elem178)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Row')
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.values))
            for iter179 in self.values:
                iter179.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class OutputParameter(object):
    """
    Attributes:
     - type
     - scale
     - typeName
    """


    def __init__(self, type=None, scale=None, typeName=None,):
        self.type = type
        self.scale = scale
        self.typeName = typeName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.scale = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.typeName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('OutputParameter')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.scale is not None:
            oprot.writeFieldBegin('scale', TType.I32, 2)
            oprot.writeI32(self.scale)
            oprot.writeFieldEnd()
        if self.typeName is not None:
            oprot.writeFieldBegin('typeName', TType.STRING, 3)
            oprot.writeString(self.typeName.encode('utf-8') if sys.version_info[0] == 2 else self.typeName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RowSet(object):
    """
    Attributes:
     - rows
     - flags
     - cursorId
     - statementId
     - connId
     - token
     - source
     - offset
     - metadata
     - cursorName
     - warnings
     - rowIdsForUpdateOrDelete
    """


    def __init__(self, rows=None, flags=None, cursorId=None, statementId=None, connId=None, token=None, source=None, offset=None, metadata=None, cursorName=None, warnings=None, rowIdsForUpdateOrDelete=None,):
        self.rows = rows
        self.flags = flags
        self.cursorId = cursorId
        self.statementId = statementId
        self.connId = connId
        self.token = token
        self.source = source
        self.offset = offset
        self.metadata = metadata
        self.cursorName = cursorName
        self.warnings = warnings
        self.rowIdsForUpdateOrDelete = rowIdsForUpdateOrDelete

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.rows = []
                    (_etype183, _size180) = iprot.readListBegin()
                    for _i184 in range(_size180):
                        _elem185 = Row()
                        _elem185.read(iprot)
                        self.rows.append(_elem185)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.flags = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.cursorId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.source = HostAddress()
                    self.source.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.metadata = []
                    (_etype189, _size186) = iprot.readListBegin()
                    for _i190 in range(_size186):
                        _elem191 = ColumnDescriptor()
                        _elem191.read(iprot)
                        self.metadata.append(_elem191)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.cursorName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.warnings = SnappyExceptionData()
                    self.warnings.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.LIST:
                    self.rowIdsForUpdateOrDelete = []
                    (_etype195, _size192) = iprot.readListBegin()
                    for _i196 in range(_size192):
                        _elem197 = iprot.readI64()
                        self.rowIdsForUpdateOrDelete.append(_elem197)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RowSet')
        if self.rows is not None:
            oprot.writeFieldBegin('rows', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.rows))
            for iter198 in self.rows:
                iter198.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.BYTE, 2)
            oprot.writeByte(self.flags)
            oprot.writeFieldEnd()
        if self.cursorId is not None:
            oprot.writeFieldBegin('cursorId', TType.I64, 3)
            oprot.writeI64(self.cursorId)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 4)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 5)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 6)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        if self.source is not None:
            oprot.writeFieldBegin('source', TType.STRUCT, 7)
            self.source.write(oprot)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I32, 8)
            oprot.writeI32(self.offset)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.LIST, 9)
            oprot.writeListBegin(TType.STRUCT, len(self.metadata))
            for iter199 in self.metadata:
                iter199.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.cursorName is not None:
            oprot.writeFieldBegin('cursorName', TType.STRING, 10)
            oprot.writeString(self.cursorName.encode('utf-8') if sys.version_info[0] == 2 else self.cursorName)
            oprot.writeFieldEnd()
        if self.warnings is not None:
            oprot.writeFieldBegin('warnings', TType.STRUCT, 11)
            self.warnings.write(oprot)
            oprot.writeFieldEnd()
        if self.rowIdsForUpdateOrDelete is not None:
            oprot.writeFieldBegin('rowIdsForUpdateOrDelete', TType.LIST, 12)
            oprot.writeListBegin(TType.I64, len(self.rowIdsForUpdateOrDelete))
            for iter200 in self.rowIdsForUpdateOrDelete:
                oprot.writeI64(iter200)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.rows is None:
            raise TProtocolException(message='Required field rows is unset!')
        if self.flags is None:
            raise TProtocolException(message='Required field flags is unset!')
        if self.cursorId is None:
            raise TProtocolException(message='Required field cursorId is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        if self.connId is None:
            raise TProtocolException(message='Required field connId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PrepareResult(object):
    """
    Attributes:
     - statementId
     - statementType
     - parameterMetaData
     - resultSetMetaData
     - warnings
    """


    def __init__(self, statementId=None, statementType=None, parameterMetaData=None, resultSetMetaData=None, warnings=None,):
        self.statementId = statementId
        self.statementType = statementType
        self.parameterMetaData = parameterMetaData
        self.resultSetMetaData = resultSetMetaData
        self.warnings = warnings

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.statementType = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.parameterMetaData = []
                    (_etype204, _size201) = iprot.readListBegin()
                    for _i205 in range(_size201):
                        _elem206 = ColumnDescriptor()
                        _elem206.read(iprot)
                        self.parameterMetaData.append(_elem206)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.resultSetMetaData = []
                    (_etype210, _size207) = iprot.readListBegin()
                    for _i211 in range(_size207):
                        _elem212 = ColumnDescriptor()
                        _elem212.read(iprot)
                        self.resultSetMetaData.append(_elem212)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.warnings = SnappyExceptionData()
                    self.warnings.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PrepareResult')
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 1)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.statementType is not None:
            oprot.writeFieldBegin('statementType', TType.BYTE, 2)
            oprot.writeByte(self.statementType)
            oprot.writeFieldEnd()
        if self.parameterMetaData is not None:
            oprot.writeFieldBegin('parameterMetaData', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.parameterMetaData))
            for iter213 in self.parameterMetaData:
                iter213.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.resultSetMetaData is not None:
            oprot.writeFieldBegin('resultSetMetaData', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.resultSetMetaData))
            for iter214 in self.resultSetMetaData:
                iter214.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.warnings is not None:
            oprot.writeFieldBegin('warnings', TType.STRUCT, 5)
            self.warnings.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        if self.statementType is None:
            raise TProtocolException(message='Required field statementType is unset!')
        if self.parameterMetaData is None:
            raise TProtocolException(message='Required field parameterMetaData is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UpdateResult(object):
    """
    Attributes:
     - updateCount
     - batchUpdateCounts
     - generatedKeys
     - newDefaultSchema
     - warnings
    """


    def __init__(self, updateCount=None, batchUpdateCounts=None, generatedKeys=None, newDefaultSchema=None, warnings=None,):
        self.updateCount = updateCount
        self.batchUpdateCounts = batchUpdateCounts
        self.generatedKeys = generatedKeys
        self.newDefaultSchema = newDefaultSchema
        self.warnings = warnings

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.updateCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.batchUpdateCounts = []
                    (_etype218, _size215) = iprot.readListBegin()
                    for _i219 in range(_size215):
                        _elem220 = iprot.readI32()
                        self.batchUpdateCounts.append(_elem220)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.generatedKeys = RowSet()
                    self.generatedKeys.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.newDefaultSchema = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.warnings = SnappyExceptionData()
                    self.warnings.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UpdateResult')
        if self.updateCount is not None:
            oprot.writeFieldBegin('updateCount', TType.I32, 1)
            oprot.writeI32(self.updateCount)
            oprot.writeFieldEnd()
        if self.batchUpdateCounts is not None:
            oprot.writeFieldBegin('batchUpdateCounts', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.batchUpdateCounts))
            for iter221 in self.batchUpdateCounts:
                oprot.writeI32(iter221)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.generatedKeys is not None:
            oprot.writeFieldBegin('generatedKeys', TType.STRUCT, 3)
            self.generatedKeys.write(oprot)
            oprot.writeFieldEnd()
        if self.newDefaultSchema is not None:
            oprot.writeFieldBegin('newDefaultSchema', TType.STRING, 4)
            oprot.writeString(self.newDefaultSchema.encode('utf-8') if sys.version_info[0] == 2 else self.newDefaultSchema)
            oprot.writeFieldEnd()
        if self.warnings is not None:
            oprot.writeFieldBegin('warnings', TType.STRUCT, 5)
            self.warnings.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StatementResult(object):
    """
    Attributes:
     - resultSet
     - updateCount
     - batchUpdateCounts
     - procedureOutParams
     - generatedKeys
     - newDefaultSchema
     - warnings
     - preparedResult
    """


    def __init__(self, resultSet=None, updateCount=None, batchUpdateCounts=None, procedureOutParams=None, generatedKeys=None, newDefaultSchema=None, warnings=None, preparedResult=None,):
        self.resultSet = resultSet
        self.updateCount = updateCount
        self.batchUpdateCounts = batchUpdateCounts
        self.procedureOutParams = procedureOutParams
        self.generatedKeys = generatedKeys
        self.newDefaultSchema = newDefaultSchema
        self.warnings = warnings
        self.preparedResult = preparedResult

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.resultSet = RowSet()
                    self.resultSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.updateCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.batchUpdateCounts = []
                    (_etype225, _size222) = iprot.readListBegin()
                    for _i226 in range(_size222):
                        _elem227 = iprot.readI32()
                        self.batchUpdateCounts.append(_elem227)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.procedureOutParams = {}
                    (_ktype229, _vtype230, _size228) = iprot.readMapBegin()
                    for _i232 in range(_size228):
                        _key233 = iprot.readI32()
                        _val234 = ColumnValue()
                        _val234.read(iprot)
                        self.procedureOutParams[_key233] = _val234
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.generatedKeys = RowSet()
                    self.generatedKeys.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.newDefaultSchema = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.warnings = SnappyExceptionData()
                    self.warnings.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.preparedResult = PrepareResult()
                    self.preparedResult.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StatementResult')
        if self.resultSet is not None:
            oprot.writeFieldBegin('resultSet', TType.STRUCT, 1)
            self.resultSet.write(oprot)
            oprot.writeFieldEnd()
        if self.updateCount is not None:
            oprot.writeFieldBegin('updateCount', TType.I32, 2)
            oprot.writeI32(self.updateCount)
            oprot.writeFieldEnd()
        if self.batchUpdateCounts is not None:
            oprot.writeFieldBegin('batchUpdateCounts', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.batchUpdateCounts))
            for iter235 in self.batchUpdateCounts:
                oprot.writeI32(iter235)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.procedureOutParams is not None:
            oprot.writeFieldBegin('procedureOutParams', TType.MAP, 4)
            oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.procedureOutParams))
            for kiter236, viter237 in self.procedureOutParams.items():
                oprot.writeI32(kiter236)
                viter237.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.generatedKeys is not None:
            oprot.writeFieldBegin('generatedKeys', TType.STRUCT, 5)
            self.generatedKeys.write(oprot)
            oprot.writeFieldEnd()
        if self.newDefaultSchema is not None:
            oprot.writeFieldBegin('newDefaultSchema', TType.STRING, 6)
            oprot.writeString(self.newDefaultSchema.encode('utf-8') if sys.version_info[0] == 2 else self.newDefaultSchema)
            oprot.writeFieldEnd()
        if self.warnings is not None:
            oprot.writeFieldBegin('warnings', TType.STRUCT, 7)
            self.warnings.write(oprot)
            oprot.writeFieldEnd()
        if self.preparedResult is not None:
            oprot.writeFieldBegin('preparedResult', TType.STRUCT, 8)
            self.preparedResult.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EntityId(object):
    """
    Attributes:
     - id
     - type
     - connId
     - token
    """


    def __init__(self, id=None, type=None, connId=None, token=None,):
        self.id = id
        self.type = type
        self.connId = connId
        self.token = token

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.type = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.connId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EntityId')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.BYTE, 2)
            oprot.writeByte(self.type)
            oprot.writeFieldEnd()
        if self.connId is not None:
            oprot.writeFieldBegin('connId', TType.I64, 3)
            oprot.writeI64(self.connId)
            oprot.writeFieldEnd()
        if self.token is not None:
            oprot.writeFieldBegin('token', TType.STRING, 4)
            oprot.writeBinary(self.token)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.connId is None:
            raise TProtocolException(message='Required field connId is unset!')
        if self.token is None:
            raise TProtocolException(message='Required field token is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Decimal)
Decimal.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'signum', None, None, ),  # 1
    (2, TType.I32, 'scale', None, None, ),  # 2
    (3, TType.STRING, 'magnitude', 'BINARY', None, ),  # 3
)
all_structs.append(BlobChunk)
BlobChunk.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'chunk', 'BINARY', None, ),  # 1
    (2, TType.BOOL, 'last', None, None, ),  # 2
    (3, TType.I64, 'lobId', None, None, ),  # 3
    (4, TType.I64, 'offset', None, None, ),  # 4
    (5, TType.I64, 'totalLength', None, None, ),  # 5
)
all_structs.append(ClobChunk)
ClobChunk.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'chunk', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'last', None, None, ),  # 2
    (3, TType.I64, 'lobId', None, None, ),  # 3
    (4, TType.I64, 'offset', None, None, ),  # 4
    (5, TType.I64, 'totalLength', None, None, ),  # 5
)
all_structs.append(TransactionXid)
TransactionXid.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'formatId', None, None, ),  # 1
    (2, TType.STRING, 'globalId', 'BINARY', None, ),  # 2
    (3, TType.STRING, 'branchQualifier', 'BINARY', None, ),  # 3
)
all_structs.append(ServiceMetaData)
ServiceMetaData.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'productName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'productVersion', 'UTF8', None, ),  # 2
    (3, TType.I32, 'productMajorVersion', None, None, ),  # 3
    (4, TType.I32, 'productMinorVersion', None, None, ),  # 4
    (5, TType.I32, 'jdbcMajorVersion', None, None, ),  # 5
    (6, TType.I32, 'jdbcMinorVersion', None, None, ),  # 6
    (7, TType.STRING, 'identifierQuote', 'UTF8', None, ),  # 7
    (8, TType.LIST, 'sqlKeywords', (TType.STRING, 'UTF8', False), None, ),  # 8
    (9, TType.LIST, 'numericFunctions', (TType.STRING, 'UTF8', False), None, ),  # 9
    (10, TType.LIST, 'stringFunctions', (TType.STRING, 'UTF8', False), None, ),  # 10
    (11, TType.LIST, 'systemFunctions', (TType.STRING, 'UTF8', False), None, ),  # 11
    (12, TType.LIST, 'dateTimeFunctions', (TType.STRING, 'UTF8', False), None, ),  # 12
    (13, TType.STRING, 'searchStringEscape', 'UTF8', None, ),  # 13
    (14, TType.STRING, 'extraNameCharacters', 'UTF8', None, ),  # 14
    (15, TType.MAP, 'supportedCONVERT', (TType.I32, None, TType.SET, (TType.I32, None, False), False), None, ),  # 15
    (16, TType.STRING, 'schemaTerm', 'UTF8', None, ),  # 16
    (17, TType.STRING, 'procedureTerm', 'UTF8', None, ),  # 17
    (18, TType.STRING, 'catalogTerm', 'UTF8', None, ),  # 18
    (19, TType.STRING, 'catalogSeparator', 'UTF8', None, ),  # 19
    (20, TType.I32, 'maxBinaryLiteralLength', None, None, ),  # 20
    (21, TType.I32, 'maxCharLiteralLength', None, None, ),  # 21
    (22, TType.I32, 'maxColumnsInGroupBy', None, None, ),  # 22
    (23, TType.I32, 'maxColumnsInIndex', None, None, ),  # 23
    (24, TType.I32, 'maxColumnsInOrderBy', None, None, ),  # 24
    (25, TType.I32, 'maxColumnsInSelect', None, None, ),  # 25
    (26, TType.I32, 'maxColumnsInTable', None, None, ),  # 26
    (27, TType.I32, 'maxConnections', None, None, ),  # 27
    (28, TType.I32, 'maxIndexLength', None, None, ),  # 28
    (29, TType.I32, 'maxRowSize', None, None, ),  # 29
    (30, TType.I32, 'maxStatementLength', None, None, ),  # 30
    (31, TType.I32, 'maxOpenStatements', None, None, ),  # 31
    (32, TType.I32, 'maxTableNamesInSelect', None, None, ),  # 32
    (33, TType.I32, 'maxColumnNameLength', None, None, ),  # 33
    (34, TType.I32, 'maxCursorNameLength', None, None, ),  # 34
    (35, TType.I32, 'maxSchemaNameLength', None, None, ),  # 35
    (36, TType.I32, 'maxProcedureNameLength', None, None, ),  # 36
    (37, TType.I32, 'maxCatalogNameLength', None, None, ),  # 37
    (38, TType.I32, 'maxTableNameLength', None, None, ),  # 38
    (39, TType.I32, 'maxUserNameLength', None, None, ),  # 39
    (40, TType.I32, 'defaultTransactionIsolation', None, None, ),  # 40
    (41, TType.BYTE, 'defaultResultSetType', None, None, ),  # 41
    (42, TType.BOOL, 'defaultResultSetHoldabilityHoldCursorsOverCommit', None, None, ),  # 42
    (43, TType.BOOL, 'sqlStateIsXOpen', None, None, ),  # 43
    (44, TType.BOOL, 'catalogAtStart', None, None, ),  # 44
    (45, TType.MAP, 'transactionDefaults', (TType.I32, None, TType.BOOL, None, False), None, ),  # 45
    (46, TType.I32, 'rowIdLifeTime', None, None, ),  # 46
    (47, TType.SET, 'supportedFeatures', (TType.I32, None, False), None, ),  # 47
    (48, TType.MAP, 'featuresWithParams', (TType.I32, None, TType.LIST, (TType.I32, None, False), False), None, ),  # 48
)
all_structs.append(ServiceMetaDataArgs)
ServiceMetaDataArgs.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.BYTE, 'driverType', None, None, ),  # 2
    (3, TType.STRING, 'token', 'BINARY', None, ),  # 3
    (4, TType.STRING, 'schema', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'table', 'UTF8', None, ),  # 5
    (6, TType.LIST, 'tableTypes', (TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.STRING, 'columnName', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'foreignSchema', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'foreignTable', 'UTF8', None, ),  # 9
    (10, TType.STRING, 'procedureName', 'UTF8', None, ),  # 10
    (11, TType.STRING, 'functionName', 'UTF8', None, ),  # 11
    (12, TType.STRING, 'attributeName', 'UTF8', None, ),  # 12
    (13, TType.STRING, 'typeName', 'UTF8', None, ),  # 13
    (14, TType.I32, 'typeId', None, None, ),  # 14
)
all_structs.append(OpenConnectionArgs)
OpenConnectionArgs.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clientHostName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'clientID', 'UTF8', None, ),  # 2
    (3, TType.I32, 'security', None, None, ),  # 3
    (4, TType.STRING, 'userName', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'password', 'UTF8', None, ),  # 5
    (6, TType.BOOL, 'forXA', None, None, ),  # 6
    (7, TType.I32, 'tokenSize', None, None, ),  # 7
    (8, TType.BOOL, 'useStringForDecimal', None, None, ),  # 8
    (9, TType.MAP, 'properties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 9
)
all_structs.append(ConnectionProperties)
ConnectionProperties.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'connId', None, None, ),  # 1
    (2, TType.STRING, 'clientHostName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'clientID', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'userName', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'token', 'BINARY', None, ),  # 5
    (6, TType.STRING, 'defaultSchema', 'UTF8', None, ),  # 6
)
all_structs.append(HostAddress)
HostAddress.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'hostName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'port', None, None, ),  # 2
    (3, TType.STRING, 'ipAddress', 'UTF8', None, ),  # 3
    (4, TType.I32, 'serverType', None, None, ),  # 4
)
all_structs.append(SnappyExceptionData)
SnappyExceptionData.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'reason', 'UTF8', None, ),  # 1
    (2, TType.I32, 'errorCode', None, None, ),  # 2
    (3, TType.STRING, 'sqlState', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'updateCounts', (TType.I32, None, False), None, ),  # 4
)
all_structs.append(SnappyException)
SnappyException.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exceptionData', [SnappyExceptionData, None], None, ),  # 1
    (2, TType.STRING, 'serverInfo', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'nextExceptions', (TType.STRUCT, [SnappyExceptionData, None], False), None, ),  # 3
)
all_structs.append(StatementAttrs)
StatementAttrs.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'resultSetType', None, None, ),  # 1
    (2, TType.BOOL, 'updatable', None, None, ),  # 2
    (3, TType.BOOL, 'holdCursorsOverCommit', None, None, ),  # 3
    (4, TType.BOOL, 'requireAutoIncCols', None, None, ),  # 4
    (5, TType.LIST, 'autoIncColumns', (TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'autoIncColumnNames', (TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.I32, 'batchSize', None, 1024, ),  # 7
    (8, TType.BOOL, 'fetchReverse', None, None, ),  # 8
    (9, TType.I32, 'lobChunkSize', None, None, ),  # 9
    (10, TType.I32, 'maxRows', None, None, ),  # 10
    (11, TType.I32, 'maxFieldSize', None, None, ),  # 11
    (12, TType.I32, 'timeout', None, None, ),  # 12
    (13, TType.STRING, 'cursorName', 'UTF8', None, ),  # 13
    (14, TType.BOOL, 'possibleDuplicate', None, None, ),  # 14
    (15, TType.BOOL, 'poolable', None, None, ),  # 15
    (16, TType.BOOL, 'doEscapeProcessing', None, None, ),  # 16
    (17, TType.MAP, 'pendingTransactionAttrs', (TType.I32, None, TType.BOOL, None, False), None, ),  # 17
    (18, TType.SET, 'bucketIds', (TType.I32, None, False), None, ),  # 18
    (19, TType.STRING, 'bucketIdsTable', 'UTF8', None, ),  # 19
    (20, TType.BOOL, 'retainBucketIds', None, None, ),  # 20
    (21, TType.I32, 'metadataVersion', None, None, ),  # 21
    (22, TType.STRING, 'snapshotTransactionId', 'UTF8', None, ),  # 22
)
all_structs.append(ColumnValue)
ColumnValue.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'bool_val', None, None, ),  # 1
    (2, TType.BYTE, 'byte_val', None, None, ),  # 2
    (3, TType.I16, 'i16_val', None, None, ),  # 3
    (4, TType.I32, 'i32_val', None, None, ),  # 4
    (5, TType.I64, 'i64_val', None, None, ),  # 5
    (6, TType.I32, 'float_val', None, None, ),  # 6
    (7, TType.DOUBLE, 'double_val', None, None, ),  # 7
    (8, TType.STRING, 'string_val', 'UTF8', None, ),  # 8
    (9, TType.STRUCT, 'decimal_val', [Decimal, None], None, ),  # 9
    (10, TType.I64, 'date_val', None, None, ),  # 10
    (11, TType.I64, 'time_val', None, None, ),  # 11
    (12, TType.I64, 'timestamp_val', None, None, ),  # 12
    (13, TType.STRING, 'binary_val', 'BINARY', None, ),  # 13
    (14, TType.STRUCT, 'blob_val', [BlobChunk, None], None, ),  # 14
    (15, TType.STRUCT, 'clob_val', [ClobChunk, None], None, ),  # 15
    (16, TType.LIST, 'array_val', (TType.STRUCT, [ColumnValue, None], False), None, ),  # 16
    (17, TType.MAP, 'map_val', (TType.STRUCT, [ColumnValue, None], TType.STRUCT, [ColumnValue, None], False), None, ),  # 17
    (18, TType.LIST, 'struct_val', (TType.STRUCT, [ColumnValue, None], False), None, ),  # 18
    (19, TType.BOOL, 'null_val', None, None, ),  # 19
    (20, TType.STRING, 'java_val', 'BINARY', None, ),  # 20
)
all_structs.append(ColumnDescriptor)
ColumnDescriptor.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.I16, 'precision', None, None, ),  # 2
    (3, TType.I16, 'scale', None, None, ),  # 3
    (4, TType.STRING, 'name', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'fullTableName', 'UTF8', None, ),  # 5
    (6, TType.BOOL, 'updatable', None, None, ),  # 6
    (7, TType.BOOL, 'definitelyUpdatable', None, None, ),  # 7
    (8, TType.BOOL, 'nullable', None, None, ),  # 8
    (9, TType.BOOL, 'autoIncrement', None, None, ),  # 9
    (10, TType.BOOL, 'parameterIn', None, None, ),  # 10
    (11, TType.BOOL, 'parameterOut', None, None, ),  # 11
    (12, TType.LIST, 'elementTypes', (TType.I32, None, False), None, ),  # 12
    (13, TType.STRING, 'udtTypeAndClassName', 'UTF8', None, ),  # 13
)
all_structs.append(Row)
Row.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'values', (TType.STRUCT, [ColumnValue, None], False), None, ),  # 1
)
all_structs.append(OutputParameter)
OutputParameter.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.I32, 'scale', None, None, ),  # 2
    (3, TType.STRING, 'typeName', 'UTF8', None, ),  # 3
)
all_structs.append(RowSet)
RowSet.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'rows', (TType.STRUCT, [Row, None], False), None, ),  # 1
    (2, TType.BYTE, 'flags', None, None, ),  # 2
    (3, TType.I64, 'cursorId', None, None, ),  # 3
    (4, TType.I64, 'statementId', None, None, ),  # 4
    (5, TType.I64, 'connId', None, None, ),  # 5
    (6, TType.STRING, 'token', 'BINARY', None, ),  # 6
    (7, TType.STRUCT, 'source', [HostAddress, None], None, ),  # 7
    (8, TType.I32, 'offset', None, None, ),  # 8
    (9, TType.LIST, 'metadata', (TType.STRUCT, [ColumnDescriptor, None], False), None, ),  # 9
    (10, TType.STRING, 'cursorName', 'UTF8', None, ),  # 10
    (11, TType.STRUCT, 'warnings', [SnappyExceptionData, None], None, ),  # 11
    (12, TType.LIST, 'rowIdsForUpdateOrDelete', (TType.I64, None, False), None, ),  # 12
)
all_structs.append(PrepareResult)
PrepareResult.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'statementId', None, None, ),  # 1
    (2, TType.BYTE, 'statementType', None, None, ),  # 2
    (3, TType.LIST, 'parameterMetaData', (TType.STRUCT, [ColumnDescriptor, None], False), None, ),  # 3
    (4, TType.LIST, 'resultSetMetaData', (TType.STRUCT, [ColumnDescriptor, None], False), None, ),  # 4
    (5, TType.STRUCT, 'warnings', [SnappyExceptionData, None], None, ),  # 5
)
all_structs.append(UpdateResult)
UpdateResult.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'updateCount', None, None, ),  # 1
    (2, TType.LIST, 'batchUpdateCounts', (TType.I32, None, False), None, ),  # 2
    (3, TType.STRUCT, 'generatedKeys', [RowSet, None], None, ),  # 3
    (4, TType.STRING, 'newDefaultSchema', 'UTF8', None, ),  # 4
    (5, TType.STRUCT, 'warnings', [SnappyExceptionData, None], None, ),  # 5
)
all_structs.append(StatementResult)
StatementResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'resultSet', [RowSet, None], None, ),  # 1
    (2, TType.I32, 'updateCount', None, None, ),  # 2
    (3, TType.LIST, 'batchUpdateCounts', (TType.I32, None, False), None, ),  # 3
    (4, TType.MAP, 'procedureOutParams', (TType.I32, None, TType.STRUCT, [ColumnValue, None], False), None, ),  # 4
    (5, TType.STRUCT, 'generatedKeys', [RowSet, None], None, ),  # 5
    (6, TType.STRING, 'newDefaultSchema', 'UTF8', None, ),  # 6
    (7, TType.STRUCT, 'warnings', [SnappyExceptionData, None], None, ),  # 7
    (8, TType.STRUCT, 'preparedResult', [PrepareResult, None], None, ),  # 8
)
all_structs.append(EntityId)
EntityId.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.BYTE, 'type', None, None, ),  # 2
    (3, TType.I64, 'connId', None, None, ),  # 3
    (4, TType.STRING, 'token', 'BINARY', None, ),  # 4
)
fix_spec(all_structs)
del all_structs
