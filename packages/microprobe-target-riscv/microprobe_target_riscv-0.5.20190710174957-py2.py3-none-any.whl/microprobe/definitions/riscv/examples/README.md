# RISC-V Microprobe Examples

## tl;dr

```bash
./riscv_ipc.py
autoconf
mkdir build
cd build
../configure --with-riscvtools=$RISCV_TOOLS_DIRECTORY
make
```

## Instructions

The structure of this example is modeled off of [riscv-tests](https://github.com/riscv/riscv-tests).
However, the underlying tests are generated by Microprobe.

For this example, we explore variations in RAW dependency distance.
By dependency distance, we mean the distance (in terms of _number of instructions_) between which a register result is produced and it is consumed.
The following sequence of instructions has a dependency distance of 1:

```asm
ADD x10, x9, x5
ADD x12, x11, x10
ADD x14, x13, x12
```

Each instruction produces a result that is needed by the next instruction, e.g., `x10` is produced by the first instruction and consumed by the second.
The following sequence has a dependency distance of 2:

```asm
ADD x11, x10, x9
ADD x13, x12, x5
ADD x15, x14, x11
```

Here, `x11` is produced by the first instruction and consumed by the _third_.

The included program `riscv_ipc.py` will produce microbenchmarks that have different dependency distances.
Go ahead and run this now with `./riscv_ipc.py`.
This produces a number of benchmarks in `riscv_ipc/`, e.g., `ADD_V0_1.S` and `ADD_V0_2.S` that produce assembly sequences like those shown above.
Additionally, this produces a Makefile fragment, `tests.d`, that describes all the microbenchmarks that were generated.
The provided build flow will consume this later.

Now, we need to setup an out-of-source build environment.
These microbenchmarks depend on a number of header files provided by [`riscv-tests`](https://github.com/riscv/riscv-tests) and [`riscv-test-env`](https://github.com/riscv/riscv-test-env).
Hence, when configuring the project, we need to provide a path to an existing clone of `riscv-tools`, represented by the bash variable `$RISCV_TOOLS_DIRECTORY` (substitute in a real path here!)

```bash
autoconf
mkdir build
cd build
../configure --with-riscvtools=$RISCV_TOOLS_DIRECTORY
```

You need to have a suitable RISC-V cross compiler (specifically `riscv64-unknown-elf-gcc`) available on your path to compile the microbenchmarks.
You can then run `make` to compile all the Microprobe generated microbenchmarks int `build/riscv_ipc/`.

These can then be run on suitable RISC-V hardware or in a simulation/emulation environment, e.g., :

```
spike riscv_ipc/riscv_ipc-p-ADD_V0_1
```
